/********************************************************************************
 * Copyright (c) 2011-2017 Red Hat Inc. and/or its affiliates and others
 *
 * This program and the accompanying materials are made available under the 
 * terms of the Apache License, Version 2.0 which is available at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * SPDX-License-Identifier: Apache-2.0 
 ********************************************************************************/
package org.eclipse.ceylon.compiler.java.language;


import ceylon.language.finished_;
import ceylon.language.impl.BaseIterable;

import org.eclipse.ceylon.compiler.java.metadata.Ignore;
import org.eclipse.ceylon.compiler.java.runtime.model.TypeDescriptor;

/** 
 * A non-user-visible class that helps create iterables in 
 * generated bytecode. The {@link #iterator()} method should 
 * return a new instance in every call.
 * 
 * @author Enrique Zamudio
 */
public abstract class AbstractIterable<Element,Absent>
extends BaseIterable<Element,Absent>  {
    
//    @Ignore
//    private TypeDescriptor $reifiedElement;
//    @Ignore
//    private TypeDescriptor $reifiedAbsent;
//    
//    @Ignore
//    private final Iterable<?,?>[] $iterables;

    public AbstractIterable(@Ignore TypeDescriptor $reifiedElement, 
            @Ignore TypeDescriptor $reifiedAbsent) {
        super($reifiedElement, $reifiedAbsent);
//        this.$iterables = null;
    }
    
//    public AbstractIterable(@Ignore TypeDescriptor $reifiedElement, 
//          @Ignore TypeDescriptor $reifiedAbsent, 
//          Iterable<?,?>... iterables) {
//      super($reifiedElement, $reifiedAbsent);
//      this.$reifiedElement = $reifiedElement;
//      this.$reifiedAbsent = $reifiedAbsent;
//        this.$iterables = iterables;
//    }
//    
//    @Ignore
//    public Iterable<?,?>[] $getIterables$() {
//        return $iterables;
//    }
    
    @Override
    public boolean getEmpty() {
        return iterator().next() == finished_.get_();
    }
    
//    @Override
//    @Ignore
//    public final TypeDescriptor $getType$() {
//        return TypeDescriptor.klass(AbstractIterable.class, 
//              $reifiedElement, $reifiedAbsent);
//    }
    
    protected Object writeReplace() {
        return sequence();
    }
}
