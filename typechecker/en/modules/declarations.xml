<chapter id="declarations">
    <title>Declarations</title>
    
    <para>Ceylon is a statically typed language. Classes, interfaces, methods, attributes 
    and locals must be declared before use. The declaration of a method, attribute, or
    local must include an explicit type, or allow the type to be infered. This allows the 
    compiler to detect many errors, including:</para>
    
    <itemizedlist>
        <listitem><para>typing errors in identifier names,</para></listitem>
        <listitem><para>references to types which do not exist or are not 
        visible,</para></listitem>
        <listitem><para>references to type members which do not exist or are not 
        visible,</para></listitem>
        <listitem><para>argument lists which do not match parameter lists,</para></listitem>
        <listitem><para>type argument lists which do not match type parameter 
        lists,</para></listitem>
        <listitem><para>incompatible assignment of an expression of one type to a
        program element of a different type,</para></listitem>
        <listitem><para>evaluation of an attribute or local before its value has been
        explicitly specified or assigned,</para></listitem>
        <listitem><para>assignment to a non-<literal>variable</literal> attribute or
        local,</para></listitem>
        <listitem><para>failure to refine a <literal>formal</literal> member of a 
        supertype,</para></listitem>
        <listitem><para>refinement of a non-<literal>formal</literal>, 
        non-<literal>default</literal> member of a supertype,</para></listitem>
        <listitem><para><literal>switch</literal> statements which do not exhaust all
        values of an enumerated type, and</para></listitem>
        <listitem><para><literal>switch</literal> statements which do not exhaust all 
        cases of a type with enumerated subtypes.</para></listitem>
    </itemizedlist>
    
    <para>All declarations follow a general pattern:</para>
        
    <programlisting>Annotation* 
(keyword | UnionType) (TypeName | MemberName) TypeParams? Params*
CaseTypes? Metatypes? AdaptedTypes? ExtendedType? SatisfiedTypes? AbstractedType?
TypeConstraints?
(Definition | ";")</programlisting>

    <para>A type parameter does not need an explicit declaration of this form unless it has 
    constraints. In the case that it does have constraints, the constraint declaration does 
    follow the general pattern.</para>
    
    <para>This consistent pattern for declarations, together with the strict block structure
    of the language, makes Ceylon a highly regular language.</para>

    <section id="compilationunitstructure">
        <title>Compilation unit structure</title>
        
        <para>A <emphasis>compilation unit</emphasis> is a text file, with the 
        filename extension <literal>.ceylon</literal>.</para>
        
        <para>A compilation unit consists of a list of imported types, attributes, and 
        methods, followed by one or more toplevel type, attribute, or method definitions.</para>
        
        <programlisting>Import* ToplevelDeclaration+</programlisting>
        
        <section id="topleveldeclarations">
            <title>Toplevel declarations</title>
        
        <para>A <emphasis>toplevel declaration</emphasis> defines a type&mdash;a class or 
        interface&mdash;or a method or non-<literal>variable</literal> attribute.</para>
        
        <programlisting>ToplevelDeclaration: TypeDeclaration | Method | SimpleAttribute | AttributeGetter</programlisting>
        
        <programlisting>TypeDeclaration: Class | Object | Interface</programlisting>
        
        <!--
        <para>All toplevel declarations annotated <literal>shared</literal> must have the 
        same name as the compilation unit filename (after removing the file suffix 
        <literal>.ceylon</literal>). For example, a <literal>shared</literal> toplevel 
        class named <literal>Person</literal> must be defined in a file named 
        <literal>Person.ceylon</literal>. A <literal>shared</literal> toplevel method 
        named <literal>hello()</literal> must be defined in a file named 
        <literal>hello.ceylon</literal>. A <literal>shared</literal> toplevel attribute 
        named <literal>pi</literal> must be defined in a file named <literal>pi.ceylon</literal>. 
        </para>
        
        <comment><para>TODO: This doesn't work on platforms with case-insensitive filenames. 
        If I have a method named <literal>x</literal>, and a class named <literal>X</literal>,
        the filesystem can't distinguish them. We need a workaround!</para></comment>
        -->
        
        <para>A toplevel declaration may not be annotated <literal>formal</literal>,
        <literal>default</literal>, <!--literal>definite</literal--> or
        <literal>actual</literal>.</para>
        
        <comment><para>TODO: In a future version of the language, we might relax this 
        restriction and support package extension with toplevel member refinement. This
        can be viewed as a regularization of the language. The practical application is
        that it would make toplevel invocations and instantiations polymorphic, obviating
        the need for things like dependency injection.</para></comment>
        
        </section>
        
        <section id="nesteddeclarations">
            <title>Nested declarations</title>
            
            <para>Most toplevel declarations contain nested declarations.</para>
            
            <programlisting>Declaration: Method | Attribute | TypeDeclaration</programlisting>
            
            <para>Nested declarations are often mixed together with executable statements.</para>
            
        </section>
        
    </section>
    
        <section id="imports">
            <title>Imports</title>
        
        <para>Each compilation unit belongs to exactly one <emphasis>package</emphasis>.
        Code in one compilation unit may refer to a toplevel declaration in another 
        compilation unit in the same package without explicitly importing the declaration. 
        It may refer to a declaration defined in a compilation unit in another package 
        only if it explicitly <emphasis>imports</emphasis> the declaration using the 
        <literal>import</literal> statement.</para>
        
        <programlisting>Import: "import" FullPackageName "{" ImportElements "}"</programlisting>
        
        <para>A package is a namespace. A full package name is a period-separated list of 
        all-lowercase identifiers.</para>
        
        <programlisting>FullPackageName: PackageName ("." PackageName)*</programlisting>
        
        <para>For a given package, there may be at most one <literal>import</literal>
        statement per compilation unit.</para>
        
        <para>Each <literal>import</literal> statement imports one or more toplevel 
        declarations from the given package, specifying a list of <emphasis>import
        elements</emphasis>.</para>
        
        <programlisting>ImportElements: ImportElement ("," ImportElement)* ("," ImportWildcard)? | ImportWildcard</programlisting>
        
        <programlisting>ImportElement: ImportTypeElement | ImportMethodAttributeElement</programlisting>
        
        <para>An import element is a reference to either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a single toplevel type (a class or interface) of the package,</para>
            </listitem>
            <listitem>
                <para>a single toplevel method or attribute of the package, or</para>
            </listitem>
            <listitem>
                <para>all toplevel declarations of the package.</para>
            </listitem>
        </itemizedlist>
        
        <para>An import element may not refer to a non-<literal>shared</literal> 
        declaration.</para>
        
        <para>An <literal>import</literal> statement may not contain two import elements
        which refer to the same declaration.</para>
        
        <para>Note that toplevel declarations in the module <literal>ceylon.language</literal> 
        never need to be explicitly imported. They are implicitly imported by every 
        compilation unit.</para>
        
        <comment><para>Note: an unused import should result in a compiler warning.</para></comment>
                
        <section id="typeimports">
            <title>Type imports</title>
        
        <para>An import element that specifies a type name imports the toplevel type 
        with that name from the given package.</para>
        
        <programlisting>ImportTypeElement: TypeAlias? TypeName</programlisting>
        
        <para>A compilation unit may not import two types with the same name.</para>
        
        <programlisting>import ceylon.collection { Set, List, Map }</programlisting>
        
        </section>
        
        <section id="methodattributeimports">
            <title>Method and attribute imports</title>
        
        <para>An import element that specifies a method or attribute name imports the 
        toplevel method or attribute with that name from the given package.</para>
        
        <programlisting>ImportMethodAttributeElement: MethodAttributeAlias? MemberName</programlisting>
        
        <para>A compilation unit may not import two methods or attributes with the same 
        name.</para>
        
        <programlisting>import math { sqr, sqrt, e, pi }</programlisting>
        
        </section>
        
        <section id="aliasimports">
            <title>Alias imports</title>
               
        <para>The optional alias clause in a fully-explicit import allows resolution 
        of cross-namespace declaration name collisions.</para>
        
        <programlisting>TypeAlias: "local" TypeName "="</programlisting>
        
        <comment><para>TODO: Should we use <literal>class</literal> and 
        <literal>interface</literal> for declaring type aliases, instead of
        <literal>local</literal>? Or should we just drop the keyword altogether?</para></comment>

        <programlisting>MethodAttributeAlias: "local" MemberName "="</programlisting>
        
        <para>An alias assigns a different name to the imported declaration.</para>
        
        <programlisting>import java.util { local JavaMap = Map }</programlisting>
        
        <programlisting>import math { local fib = fibonnacciNumber }</programlisting>
        
        <comment><para>TODO: Currently, inheritance of two members with the same name
        from different unrelated types always results in a compile error. A similar 
        problem arises with introductions. We could let you resolve these kinds of problem 
        by renaming a member of a type you're importing. This is a bit similar to what 
        Eiffel does, but it would be a lexical thing, scoped to the compilation unit. 
        For example:</para>
        <programlisting>import org.formats { Format { local formatToString = format }, ... }</programlisting>
        </comment>
        
        </section>
        
        <section id="wildcardimports">
            <title>Wildcard imports</title>
        
        <para>The elipsis <literal>...</literal> acts as a wildcard in 
        <literal>import</literal> statements. An <literal>import</literal> statement 
        that specifies a wildcard imports all toplevel declarations of the package.</para>
        
        <programlisting>ImportWildcard: "..."</programlisting>
        
        <para>An <literal>import</literal> statement may specify a list of alias or 
        <literal>implicit</literal> imports followed by a wildcard. In this case, the 
        alias imports are imported with the specified names, and all other toplevel 
        declarations are imported with their declared names.</para>
        
        <programlisting>import ceylon.collection { ... }</programlisting>
        
        <programlisting>import math { local fib = fibonnacciNumber, ... }</programlisting>
                
        <para>Overuse of wildcard imports is discouraged.</para>
        
        </section>
        
        </section>
        
        <!--
        <section id="introductions">
            <title>Introductions</title>
            
            <para>An <emphasis>introduction</emphasis> results in an additional assignability
            relationship within a certain compilation unit. The <literal>adapt</literal>
            statement <emphasis>introduces</emphasis> one or more interfaces, called the
            <emphasis>introduced types</emphasis> to another type, called the
            <emphasis>adapted type</emphasis>:</para>
            
            <programlisting>Introduction: "adapt" Type SatisfiedTypes TypeConstraints? ";"</programlisting>
            
            <para>A single compilation unit may not have multiple <literal>adapt</literal>
            statements for the same adapted type.</para>
            
            <para>Every introduced type listed in the <literal>satisfies</literal> clause
            must satisfy the following:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the introduced type must not be a supertype of the adapted
                    type,</para>
                </listitem>
                <listitem>
                    <para>the adapted type must be a subtype of every class satisfied
                    by the introduced type,</para>
                </listitem>
                <listitem>
                    <para>for every <literal>formal</literal> member of the introduced 
                    type, there must be a member of the adapted type such that the two
                    members refine, directly or indirectly, a common member of a common
                    supertype, and</para>
                </listitem>
                <listitem>
                    <para>every <literal>actual</literal> member of the introduced type 
                    must also be declared <literal>default</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <comment><para>TODO: should we add the following requirements:</para>
            <itemizedlist>
                <listitem>
                    <para>the introduced type must not refine, directly or indirectly, 
                    a member of the adapted type,</para>
                </listitem>
                <listitem>
                    <para>if the introduced type and the adapted type both refine, 
                    directly or indirectly, a common member of a common supertype, the 
                    adapted type must directly or indirectly refine the member of the 
                    introduced type.</para>
                </listitem>
            </itemizedlist>
            </comment>
            
            <para>The list of introduced types must satisfy the following:</para>
            
            <itemizedlist>
                <listitem>
                    <para>if two introduced types both have a member that refines, 
                    directly or indirectly, a common member of a common supertype, then 
                    either the adapted type must also have a member that refines the 
                    common member, directly or indirectly, or one of the introduced type 
                    members must be declared <literal>formal</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Within the compilation unit that contains an introduction, the adapted
            type is assignable to the introduced type.</para>
            
            <para>At runtime, an operation upon the adapted type (method invocation, member 
            class instantiation, or attribute evaluation) is dispatched according to the 
            following rule:</para>
            
            <itemizedlist>
                <listitem>
                    <para>If the runtime type of the instance of the adapted type declares 
                    or refines the operation, the operation is dispatched to the runtime
                    type of the instance.
                    </para>
                </listitem>
                <listitem>
                    <para>Otherwise, the operation is dispatched to the unique introduced 
                    type that has a concrete definition of the operation.
                    </para>
                </listitem>
            </itemizedlist>
            
            <programlisting>adapt Sequence&lt;T&gt; 
        satisfies SequenceList&lt;T&gt;
        given T satisfies Equality;</programlisting>
            
        </section>
        -->
    
    <section id="interfaces">
        <title>Interfaces</title>
        
        <para>An <emphasis>interface</emphasis> is a type schema, together with 
        implementation details for some members of the type. Interfaces may not be 
        directly instantiated.</para>
        
        <programlisting>Interface: Annotation* InterfaceHeader (InterfaceBody | TypeSpecifier ";")</programlisting>
        
        <para>An interface declaration may optionally specify a list of type 
        parameters. An interface declaration may have a list of extended interfaces,
        a list of metatypes, an enumerated list of subtypes, and/or a list of type 
        constraints.</para>
        
        <programlisting>InterfaceHeader: "interface" TypeName TypeParams? InterfaceInheritance TypeConstraints?</programlisting>
        
        <programlisting>InterfaceInheritance: CaseTypes? Metatypes? AdaptedTypes? SatisfiedTypes?</programlisting>
        
        <para>To obtain a concrete instance of an interface, it is necessary to define 
        and instantiate a class that satisfies the interface, or define an anonymous 
        class that satisfies the interface.</para>
        
        <!--<section id="interfacebodies">
            <title>Interface bodies</title>-->
            
        <para>The body of an interface contains:</para>
        
        <itemizedlist>
            <listitem>
                <para>member (method, attribute, and member class) declarations, and</para>
            </listitem>
            <listitem>
                <para>nested interface and <literal>abstract</literal> class declarations.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>InterfaceBody: "{" Declaration* "}"</programlisting>
        
        <para>Unlike the body of a class, method, or attribute, the body of an interface
        is not executable, and does not directly contain procedural code.</para>

        <programlisting>shared interface Comparable&lt;Other&gt; {
    
    shared formal Comparison compare(Other other);
    
    shared Boolean greaterThan(Other other) {
        return compare(other)==larger;
    }
    
    shared Boolean lessThan(Other other) {
        return compare(other)==smaller;
    }
    
}</programlisting>

        <para>An interface may declare <literal>formal</literal> methods, attributes,
        and member classes, and concrete methods, attribute getters, attribute setters, 
        and member classes. An interface may not declare a concrete simple attribute.
        An interface may not declare a member <literal>object</literal>.</para>
        
        <!--para>A member of an interface may not be annotated <literal>definite</literal>.</para-->
        
        <para>A non-<literal>abstract </literal> nested class declaration is called a
        <emphasis>member class</emphasis> of the interface. A nested interface or 
        <literal>abstract</literal> class declaration is not part of the schema of the 
        interface type, and is therefore not considered a member of the interface.</para>
                
        <section id="interfacemembervisibility">
            <title>Interface member visibility</title>
            
            <para>An interface body is not an executable block of code, so the normal
            visibility rules that apply to declarations inside blocks do not apply.
            An interface member is always visible to all other members of the
            interface. An interface member annotated <literal>shared</literal> is 
            visible wherever the interface itself is visible.</para>
        
        </section>
        
        <section id="interfaceinheritance">
            <title>Interface inheritance</title>
            
            <para>An interface may satisfy any number of other interfaces.<!--and may satisfy
            a single class--></para>
        
            <programlisting>shared interface List&lt;Element&gt;
        satisfies Sequence&lt;Element&gt; &amp; Collection&lt;Element&gt; 
        given Element satisfies Equality {
    ...
}</programlisting>
        
            <para>The types listed after the <literal>satisfies</literal> keyword are 
            supertypes of the interface type. Every extended type must be an interface. 
            An interface may not satisfy the same interface twice (not even with distinct 
            type arguments).</para>
            
            <!--At most one supertype of the interface may be a class. The remaining 
            supertypes of an interface must be interfaces.-->
            
            <para>An interface may adapt any number of interfaces, and at most one class.</para>
            
            <programlisting>shared interface SequenceList&lt;Element&gt;
        adapts Sequence&lt;Element&gt;
        satisfies List&lt;Element&gt; 
        given Element satisfies Equality {
    ...
}</programlisting>
            
            <para>The types listed after the <literal>adapts</literal> keyword are also
            supertypes of the interface type. Every adapted type must be an interface or
            class. At most one adapted type may be a class. An interface may not adapt 
            the same type twice (not even with distinct type arguments).</para>
            
            <!--
            <para>If an interface does not explicitly declare the class it satisfies using
            <literal>satisfies</literal>, it satisfies the class 
            <literal>ceylon.language.Object</literal>.</para>
            -->
             
            <para>An interface inherits all members (methods, attributes and member types) 
            of every supertype, except for members refined by the interface or by some 
            supertype of the interface.</para>
            
            <!--
            <para>An interface inherits every class satisfied by every other interface the 
            interface satisfies. There must exist a unique satisfied class that is a subclass
            of all classes satisfied by the interface.</para>
            -->
            
            <para>The schema of the inherited members is formed by substituting type 
            arguments specified in the <literal>satisfies</literal> or <literal>adapts</literal> 
            clause.</para>
            
            <para>If an interface satisfies an introduction, the interface must itself be
            an introduction, and the adapted type of the interface must be a subtype of 
            the adapted type of the introduction it satisfies.</para>
            
            <!--
            <para>An interface may not inherit two non-<literal>formal</literal> members
            of different supertypes that both refine the same member of a third supertype.
            If two supertypes both declare non-<literal>formal</literal> members that
            refine the same member of a third supertype, the interface must also refine
            the member.</para>
            -->
            
             <para>An interface that satisfies a nested interface must be a member of the type 
             that declares the nested interface or of a subtype of the type that declares the 
             nested interface.</para>
             
        </section>
        
    <section id="interfaceswithcases">
        <title>Interfaces with enumerated cases</title>
        
        <para>The <literal>of</literal> clause of an interface declaration specifies the 
        list of cases of the interface.</para>
        
        <programlisting>shared interface Node&lt;Element&gt; 
        of Root&lt;Element&gt; | Branch&lt;Element&gt; | Leaf&lt;Element&gt; { ... }</programlisting>
        
        <para>The cases may be interfaces, classes, or toplevel anonymous classes. A case 
        may be an <literal>abstract</literal> class. Each case must be a subtype of the
        interface type.</para>
        
        <!--
        <para>If an anonymous class is a case of an interface type, it must extend the 
        class <literal>Case</literal> defined in <literal>ceylon.language</literal>, 
        directly or indirectly.</para>
        -->
        
        <para>If an interface has an <literal>of</literal> clause, then every subtype of 
        the interface must be subtype of one of the enumerated cases.</para>
                
    </section>
    
    <section id="interfacealiases">
        <title>Interface aliases</title>
        
        <para>An interface declaration which specifies a reference to another interface
        type defines an <emphasis>interface alias</emphasis> of the specified interface 
        type.</para>
        
        <programlisting>TypeSpecifier: "=" Type</programlisting>

        <para>The specified interface type may be a produced type (it may specify type 
        arguments). An interface alias simply assigns an alternative name to the original 
        interface type or produced type.</para>
        
        <programlisting>shared interface PeopleByName = Map&lt;String,Person&gt;;</programlisting>
        
        <programlisting>interface Compare&lt;Value&gt; = Callable&lt;Comparison,Value,Value&gt;;</programlisting>
                
        <para>Interface aliases are not reified types. The metamodel reference for an 
        interface alias&mdash;for example, <literal>PeopleByName</literal>&mdash;returns 
        the metamodel object for the aliased interface&mdash;in this case, 
        <literal>Map&lt;String,Person&gt;</literal>.</para>
    
    </section>
        
    </section>
    
    <section id="classes">
        <title>Classes</title>
        
        <para>A <emphasis>class</emphasis> is a stateful, instantiable type. It is a 
        type schema, together with implementation details of the members of the type.</para>

        <programlisting>Class: Annotation* ClassHeader (ClassBody | TypeSpecifier? ";")</programlisting>
        
        <para>An ordinary class declaration specifies a list of parameters required to 
        instantiate the type, and, optionally a list of type parameters.  A class 
        declaration may have a superclass, a list of extended interfaces, a list of 
        metatypes, an enumerated list of subtypes, and/or a list of type constraints.</para>
        
        <programlisting>ClassHeader: "class" TypeName TypeParams? Params ClassInheritance TypeConstraints?</programlisting>
        
        <programlisting>ClassInheritance: CaseTypes? Metatypes? ExtendedType? SatisfiedTypes?</programlisting>
        
        <para>To obtain an instance of a class, it is necessary to instantiate the
        class, or a subclass of the class.</para> 
        
    <!--<section id="classbodies">
        <title>Class bodies</title>-->
        
        <para>The body of a class contains:</para>
        
        <itemizedlist>
            <listitem>
                <para>member (method, attribute, and member class) declarations,</para>
            </listitem>
            <listitem>
                <para>nested interface and <literal>abstract</literal> class declarations, 
                and</para>
            </listitem>
            <listitem>
                <para>instance initialization code.</para>
            </listitem>
        </itemizedlist>

        <programlisting>ClassBody: "{" (Declaration | Statement)* "}"</programlisting>
        
        <para>The body of a class may contain executable code.</para>
        
        <programlisting>shared class Counter(Natural initialCount=0) {
    
    log.info("Initial count: " initialCount "");
    
    variable Natural n = initialCount;
    
    shared void increment() {
        n++;
        log.info("Count: " n "");
    }
    
    shared Natural count {
        return n;
    }
    
}</programlisting>
        
        <para>A non-<literal>abstract </literal> nested class declaration is called a
        <emphasis>member class</emphasis> of the class. A nested interface or 
        <literal>abstract</literal> class declaration is not part of the schema of the 
        class type, and is therefore not considered a member of the class.</para>
        
        <!--
        <para>The body of a class may invoke, evaluate or assign members of the instance 
        being initialized&mdash;the current instance of the class&mdash;without explicitly 
        specifying the receiver.</para>
        
        <para>The body of a member class may invoke, evaluate or assign members of the 
        current instance of the containing class or interface&mdash;the receiving instance 
        of the instantiation expression&mdash;without explicitly specifying the receiver.</para>
        
        <para>A class may be declared inside the body of a method, or attribute, in which 
        case the body of the class may refer to any non-<literal>variable</literal> local, 
        block local attribute getter or block local method declared earlier within the 
        containing scope. It may not refer to <literal>variable</literal> locals from the 
        containing scope.</para>
        -->

    <section id="initializerparameters">
        <title>Initializer parameters</title>
        
        <para>Ceylon classes do not support a Java-like constructor declaration syntax. 
        Instead, the body of the class declares <emphasis>initializer parameters</emphasis>. 
        An initializer parameter may be used anywhere in the class body, including in 
        method and attribute definitions.</para>
        
        <para>An initializer parameter may be used to specify or initialize the value 
        of an attribute:</para>
        
        <programlisting>shared class Key(Lock lock) {
    shared Lock lock = lock;
}</programlisting>
        
        <programlisting>shared class Counter(Natural initialCount=0) {
    shared variable Natural count := initialCount;
    shared void increment() { count++; }
}</programlisting>
        
        <para>An initializer parameter may even be used within the body of a method,
        attribute getter, or attribute setter:</para>
        
        <programlisting>shared class Key(Lock lock) {
    shared Lock lock { return lock; }
}</programlisting>

        <programlisting>shared class Key(Lock lock) {
    shared void lock() { lock.engage(this); }
    shared void unlock() { lock.disengage(this); }
}</programlisting>

        <comment><para>TODO: should class initializer parameters be allowed to be declared 
        <literal>shared</literal>, allowing a shortcut simple attribute declaration like in 
        Scala?</para></comment>
        
    </section>

    <section id="callabletypeofclass">
        <title>Callable type of a class</title>
        
        <para>The <emphasis>callable type</emphasis> of a class captures the type and parameter 
        types of the class. The callable type is <literal>Callable&lt;T,P...&gt;</literal>, where
        <literal>T</literal> is the class and <literal>P...</literal> are the parameter types 
        of the class. A sequenced parameter is considered of type <literal>T[]</literal>
        where <literal>T...</literal> is the declared sequenced type.</para>
        
        <para>An <literal>abstract</literal> class is not callable.</para>
    
    </section>
    
    <section id="initializersection">
        <title>Initializer section</title>
    
        <para>The initial part of the body of a class is called the <emphasis>initializer</emphasis> 
        and contains a mix of declarations, statements and control structures. The initializer 
        is executed every time the class is instantiated.</para>
           
        <para>A class initializer is responsible for initializing the state of the new 
        instance of the class, before a reference to the new instance is available to 
        clients.</para>
        
        <programlisting>shared abstract class Point() {
    shared formal Decimal x;
    shared formal Decimal y;
}</programlisting>
        
        <programlisting>shared class DiagonalPoint(Decimal distance) 
        extends Point() {
    
    Decimal pos = distance / 2**0.5;
    x = pos;
    y = pos;
    
    assert ("must have distance " distance " from origin") 
        that ( x**2 + y**2 &equals; distance**2 );
    
}</programlisting>
        
        <programlisting>shared object origin 
        extends Point() {
    x = 0.0;
    y = 0.0;
}</programlisting>
        
        <para>Within a class initializer, a <emphasis>self reference to the instance being 
        initialized</emphasis> is either:</para>
        
        <itemizedlist>
            <listitem>
                <para>the expression <literal>this</literal>, unless contained in a
                nested class declaration, or</para>
            </listitem>
            <listitem>
                <para>the expression <literal>outer</literal>, contained in a directly
                nested class declaration.</para>
            </listitem>
        </itemizedlist>
        
        <para>A statement or declaration that appears within the initializer of a class
        may not:</para>
        
        <itemizedlist>
           <listitem>
              <para>evaluate attributes, invoke methods, or instantiate member classes 
              that are declared later in the body of the class upon the instance that 
              is being initialized, including upon a self reference to the instance 
              being initialized.</para>
           </listitem>
           <listitem>
              <para>pass a self reference to the instance being initialized as an 
              argument of an instantiation or method invocation or as the value of an 
              attribute assignment or specification.</para>
           </listitem>
           <listitem>
              <para><literal>return</literal> a self reference to the instance being 
              initialized.</para>
           </listitem>
           <!-- 
           <listitem>
              <para>declare an <literal>abstract</literal> member class or an
              abstract method or attribute of the class.</para>
           </listitem>
           <listitem>
              <para>declare a <literal>default</literal> member class, method, 
              or attribute of the class.</para>
           </listitem>
           -->
           <listitem>
              <para>evaluate attributes, invoke methods, or instantiate member classes 
              declared in the declaration section of a superclass of the instance 
              being initialized, including upon a self reference to the instance being 
              initialized.</para>
           </listitem>
           <listitem>
              <para>invoke or evaluate a <literal>formal</literal> <!--or 
              <literal>definite</literal>--> member of the instance being initialized, 
              including upon a self reference to the instance being initialized.</para>
           </listitem>
           <listitem>
              <para>invoke or evaluate a <literal>default</literal> member of the 
              instance that is being initialized, except via the special 
              <literal>super</literal> self reference.</para>
           </listitem>
        </itemizedlist>
        
        <para>It is acceptable to invoke or evaluate any member of a superclass that is 
        refined by a non-<literal>formal</literal>, non-<literal>default</literal> <!--, 
        non-<literal>definite</literal>--> declaration appearing earlier in the body of the 
        class or by a declaration appearing in the declaration section of a different 
        superclass.</para>
        
        <para>Non-<literal>formal</literal>, non-<literal>default</literal><!--, 
        non-<literal>definite</literal>--> members declared in the initializer section of a 
        superclass may be invoked, evaluated or assigned anywhere inside the body of the 
        class. The superclass initializer is executed before the subclass initializer.</para>
        
        <comment><para>TODO: The compiler should try to make the initializer section as
        large as possible, including everything until the first statement or declaration
        that violates one of these restrictions. Formalize this!</para></comment>
        
        <comment><para>Note: these rules work as if the body of the subclass were inserted
        between the initializer and declaration sections of the superclass.</para></comment>
        
        <para>For example, the following code fragments are not legal:</para>
        
        <programlisting>class Graph() {
    OpenList&lt;Node&gt; nodes = ArrayList&lt;Node&gt;();
    class Node() {
        nodes.add(this);    //compiler error (this reference in initializer)
    }
}</programlisting>
        
        <programlisting>class Graph() {
    class Node() {}
    Node createNode() {
        Node node = Node();
        nodes.add(node);    //compiler error (forward reference in initializer)
        return node;
    }
    OpenList&lt;Node&gt; nodes = ArrayList&lt;Node&gt;();
}</programlisting>

        <para>But this code fragment is legal:</para>
        
        <programlisting>class Graph() {
    OpenList&lt;Node&gt; nodes = ArrayList&lt;Node&gt;();
    Node createNode() {
        Node node = Node();
        nodes.add(node);
        return node;
    }
    class Node() {}
}</programlisting>

    </section>
    
    <section id="declarationsection">
        <title>Declaration section</title>
        
        <para>The remainder of the body of the class consists purely of declarations, similar 
        to the body of an interface. <!--including <literal>abstract</literal> and 
        <literal>default</literal> methods and attributes. --> It may not contain:</para>
        
        <itemizedlist>
            <listitem>
                <para>a statement or control structure, unless it is nested inside a method,
                attribute, nested class, or nested interface declaration,</para>
            </listitem>
            <listitem>
                <para>a declaration with a specifier or initializer, unless it is nested inside 
                a method, attribute, nested class, or nested interface declaration,</para>
            </listitem>
            <listitem>
                <para>an <literal>object</literal> declaration with a non-empty initializer
                section, or</para>
            </listitem>
            <listitem>
                <para>a specification or initialization statement for a member of the instance 
                being initialized.</para>
            </listitem>
        </itemizedlist>
        
        <para>However, the declarations in this second section may freely use <literal>this</literal>
        and <literal>super</literal>, and may invoke any method, evaluate any attribute, or 
        instantiate any member class of the class or its superclasses. Furthermore, the usual 
        restriction that a declaration may only be used by code that appears later in the 
        block containing the declaration is relaxed.</para>
        
        <!--
        <comment><para>TODO: we could perhaps slightly relax the restrictions here. It's 
        probably OK to let you have expression statements and control structures in the 
        second part of the class body, just not specification or initialization 
        statements.</para></comment>
        -->
        
    </section>
           
    <section id="classmembervisibility">
        <title>Class member visibility</title>
        
        <para>Ordinarily, a declaration that occurs in a block of code is a block local
        declaration&mdash;it is visible only to statements and declarations that occur
        later in the same block. This rule is relaxed for certain declarations that occur 
        directly inside the body of a class:</para>
        
        <itemizedlist>
            <listitem>
                <para>declarations annotated <literal>shared</literal>&mdash;which are 
                visible wherever the class itself is visible, and</para>
            </listitem>
            <listitem>
                <para>declarations that occur in the second part of the body of the 
                class, after the last statement of the initializer&mdash;which are visible 
                to all other declarations in the second part of the body of the class.</para>
            </listitem>
        </itemizedlist>
        
    </section>

        <section id="classinheritance">
             <title>Class inheritance</title>
        
        <para>A class may extend another class.</para>
        
        <programlisting>shared class Customer(Name name, Organization? org = null) 
        extends Person(name, org) { 
    ... 
}</programlisting>

        <para>The class specified after the <literal>extends</literal> keyword is the
        superclass of the class.</para>

        <para>
        If a class does not explicitly specify a superclass using <literal>extends</literal>,
        its superclass is the class <literal>IdentifiableObject</literal> defined in 
        <literal>ceylon.language</literal>.
        </para>
        
        <para>A class may satisfy any number of interfaces.</para>

        <programlisting>class Token() 
        extends Datetime()
        satisfies Comparable&lt;Token&gt; &amp; Identifier {
    ... 
}</programlisting>
        
        <para>The interfaces listed after the <literal>satisfies</literal> keyword are 
        supertypes of the class. A class may not satisfy the same interface twice (not 
        even with distinct type arguments).</para>
        
        <para>A class:</para>
        
        <itemizedlist>
            <listitem>
                <para>inherits all members (methods, attributes, and member types) of every 
                supertype, except for members refined by the class or by some supertype 
                of the class,</para>
            </listitem>
            <!--listitem>
                <para>is assignable to any type to which its superclass is assignable,</para>
            </listitem-->
            <listitem>
                <para>must declare or inherit a member that refines each 
                <literal>formal</literal> member of every interface it satisfies directly 
                or indirectly, unless the class is declared <literal>abstract</literal> or
                <literal>formal</literal>, and</para>
            </listitem>
             <listitem>
                <para>must declare or inherit a member that refines each 
                <literal>formal</literal> member of its superclass, unless the class is 
                declared <literal>abstract</literal> or <literal>formal</literal>.</para>
            </listitem>
            <!--
            <listitem>
                <para>must directly or indirectly extend every class satisfied by every 
                interface it satisfies directly or indirectly.</para>
            </listitem>
            -->
            <!--listitem>
                <para>is assignable to any type to which any interface it satisfies is 
                assignable.</para>
            </listitem-->
        </itemizedlist>
        
        <para>The schema of the inherited members is formed by substituting type arguments
        specified in the <literal>extends</literal> or <literal>satisfies</literal> clause.</para>
        
        <!--
        <para>A class may not inherit two non-<literal>formal</literal> members of 
        different supertypes that both refine the same member of a third supertype.
        If two supertypes both declare non-<literal>formal</literal> members that
        refine the same member of a third supertype, the class must also refine
        the member.</para>
        -->
            
        <para>If a class satisfies an introduction, the class must be a subtype of the 
        adapted type of the introduction.</para>
            
        <para>The initializer of the superclass of a class is always executed before the 
        initializer of the class whenever the class or any one of its subclasses is 
        instantiated.</para>
        
        <para>A subclass must pass values to each superclass initialization parameter in 
        the <literal>extends</literal> clause.</para>

        <programlisting>shared class SpecialKey1()
        extends Key( SpecialLock() ) {
    ...
}</programlisting>

        <programlisting>shared class SpecialKey2(Lock lock) 
        extends Key(lock) {
    ...
}</programlisting>
         
         <para>A subclass of a nested class must be a member of the type that declares 
         the nested class or of a subtype of the type that declares the nested class. 
         A class that satisfies a nested interface must be a member of the type that 
         declares the nested interface or of a subtype of the type that declares the 
         nested interface.</para>
         
        </section>
        
        <section>
            <title>Restrictions on user-defined classes</title>
            
            <para>The following classes may not be directly extended by any class defined
            outside the module <literal>ceylon.language</literal>:</para>
            
            <itemizedlist>
                <listitem>
                    <para><literal>Gettable</literal> and <literal>Settable</literal>,</para>
                </listitem>
                <listitem>
                    <para>the built-in numeric types: <literal>Natural</literal>,
                    <literal>Integer</literal>, <literal>Float</literal>, <literal>Whole</literal>, 
                    and <literal>Decimal</literal>,</para>
                </listitem>
                <listitem>
                    <para><literal>Character</literal>,</para>
                </listitem>
                <listitem>
                    <para><literal>String</literal>,</para>
                </listitem>
                <listitem>
                    <para><literal>Entry</literal>, and</para>
                </listitem>
                <listitem>
                    <para><literal>Range</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>This allows the compiler to perform certain optimizations upon these 
            types.</para>
            
        </section>
       
        <!--
        <section id="overloadedclasses">
            <title>Overloaded classes</title>
            
            <para>Multiple toplevel classes belonging to the same package, or multiple 
            nested classes of the same containing body may declare the same name. The 
            classes are called <emphasis>overloaded</emphasis>.</para>
            
            <para>For any class name and package or containing body, there must be a 
            single <emphasis>root class</emphasis> with the given name belonging to 
            the given package or body. Other classes with the same name belonging to the 
            same package or body:</para>
            
            <itemizedlist>
                <listitem>
                    <para>must extend the root class,</para>
                </listitem>
                <listitem>
                    <para>must have distinct erased signatures,</para>
                </listitem>
                <listitem>
                    <para>may not declare default parameters, and</para>
                </listitem>
                <listitem>
                    <para>except for the root class, may not declare any member with a 
                    visibility modifier.</para>
                </listitem>
            </itemizedlist>
            
            <para>Then the class name always refers to the root class, except in 
            instantiation expressions. An instantiation expression is resolved to a 
            particular overloaded class declaration at compile time, using the argument 
            expression types.</para>
        
            <para>A package or body may not declare or inherit two classes with the 
            same name unless either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the classes are overloaded,</para>
                </listitem>
                <listitem>
                    <para>one class refines the other class, or</para>
                </listitem>
                <listitem>
                    <para>one class is defined by a supertype, and is not visible
                    to the subtype that defines the other class.</para>
                </listitem>
            </itemizedlist>
        
        </section>
        -->
        
    <section id="abstractandformalclasses">
        <title>Abstract, formal, and default classes</title>
        
        <para>A class may contain members annotated <literal>formal</literal>. Then
        the class must be either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a toplevel or nested class annotated <literal>abstract</literal>,</para>
            </listitem>
            <listitem>
                <para>a member class annotated <literal>formal</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>If the class is annotated <literal>formal</literal>, it is called a 
        <literal>formal</literal> member class, or, sometimes, an <emphasis>abstract 
        member class</emphasis>.</para>
        
        <para>If the class is annotated <literal>abstract</literal>, it is called an
        <literal>abstract</literal> class, or an <emphasis>abstract nested class</emphasis>.</para>
        
        <!-- 
        <para>Alternatively, a class may omit a class body entirely. Then the class must 
        be a member class and must be annotated <literal>formal</literal>.</para>
         
        <programlisting>shared formal class Buffer(Character...) satisfies Sequence&lt;Character&gt;;</programlisting>
        
        <para>In this case, also, it is considered a <literal>formal</literal> member 
        class.</para>
        
        <comment><para>TODO: In this case, do we need to limit the class to specifying 
        at most one supertype? Not sure exactly what limitations exist at the bytecode
        level.</para></comment>
        -->
        
        <para>A class annotated <literal>abstract</literal> may not be instantiated.</para>
        
        <para>A member class annotated <literal>formal</literal> may be instantiated.</para>
        
        <!--
        <para>A member of an <literal>abstract</literal> or <literal>formal</literal> class 
        may not be annotated <literal>definite</literal>.</para>
        -->
        
        <para>A class which is not annotated <literal>abstract</literal> or 
        <literal>formal</literal> is called a <emphasis>concrete</emphasis> class.</para>
        
        <para>A concrete member class may be annotated <literal>default</literal>.</para>

    </section>
            
    <section id="refiningmemberclasses">
        <title>Member class refinement</title>
        
        <para>Member class refinement is a unique feature of Ceylon, akin to the
        "factory method" pattern of many other languages.</para>
        
        <itemizedlist>
            <listitem>
                <para>A member class annotated <literal>formal</literal> or
                <literal>default</literal> may be refined by any class or 
                interface which is a subtype of the class or interface which 
                declares the member class.</para>
            </listitem>
            <listitem>
                <para>A member class annotated <literal>formal</literal> 
                <emphasis>must</emphasis> be refined by every concrete class 
                which is a subtype of the class or interface that declares the 
                member class, unless the class inherits a concrete member class 
                from a superclass that refines the <literal>formal</literal> 
                member class.</para>
            </listitem>
        </itemizedlist>
        
        <para>A member class of a subtype <emphasis>refines</emphasis> a member 
        class of a supertype if the first member class:</para>
        
        <itemizedlist>
            <listitem>
                <para>is annotated <literal>actual</literal>,</para>
            </listitem>
            <listitem>
                <para>has the same name as the member class it refines, and</para>
            </listitem>
            <listitem>
                <para>has a parameter list with the same signature as the member 
                class it refines, after substitution of type arguments specified 
                in the <literal>extends</literal> or <literal>satisfies</literal>
                clause, and either</para>
            </listitem>
            <listitem>
                <para>extends the member class it refines.</para>
            </listitem>
            <!--
            <listitem>
               <para>extends the superclass of the member class it refines and 
               satisfies all interfaces satisfied by the member class it 
               refines, where the member class it refines is a 
               <literal>formal</literal> member class with no body.</para>
            </listitem>
            -->
        </itemizedlist>
        
        <para>Finally, the refined member class must be visible to the member
        class annotated <literal>actual</literal>.</para>
        
        <para>If a member class is annotated <literal>actual</literal>, it must 
        refine some class defined by a supertype, and the class it refines 
        must be either <literal>formal</literal> or <literal>default</literal>.</para>
            
        <para>A member class may not, directly or indirectly, refine two different
        member classes not themselves annotated <literal>actual</literal>.</para>
        
        <para>Then instantiation of the member class is polymorphic, and the actual
        subtype instantiated depends upon the concrete type of the containing class
        instance.</para>
                
        <programlisting>shared abstract class Reader() {
    shared formal class Buffer(Character... chars) 
            satisfies Sequence&lt;Character&gt; {}
    ...
}</programlisting>

        <programlisting>shared class FileReader(File file) 
        extends Reader() {
    shared actual class Buffer(Character... chars) 
            extends Reader.Buffer(chars) {
        ...
    }
    ...
}</programlisting>
        
        <!--
        <para>But in the special case where the member class it refines does not
        specify a body, the refining class is not required to extend the member 
        class it refines:</para>
        
        <programlisting>shared abstract class Reader() {
    shared formal class Buffer(Character... chars) 
            satisfies Sequence&lt;Character&gt;;
    ...
}</programlisting>

        <programlisting>shared class FileReader(File file) 
        extends Reader() {
    shared actual class Buffer(Character... chars) 
            satisfies Sequence&lt;Character&gt; {
        ...
    }
    ...
}</programlisting>
        
        <para>A member class alias may refine a member class.</para>
        
        <programlisting>shared class FileReader(File file) 
        extends Reader() {
    shared actual class Buffer(Character... chars) = String;
    ...
}</programlisting>
        -->
         
    </section>
    
    <section id="anonymousclasses">
        <title>Anonymous classes</title>
        
        <para>An <literal>object</literal> declaration makes it possible to define
        a class, instantiate the class, and declare an attribute referring to the 
        resulting class instance in a single declaration.</para>
        
        <programlisting>Object: Annotation* ObjectHeader ClassBody</programlisting>
        
        <para>An <literal>object</literal> has an initial lowercase identifier.
        An <literal>object</literal> declaration does not specify parameters or
        type parameters.</para>
        
         <programlisting>ObjectHeader: "object" MemberName ObjectInheritance</programlisting>
         
         <programlisting>ObjectInheritance: ExtendedType? SatisfiedTypes?</programlisting>
         
         <para>An <literal>object</literal> declaration specifies the name of the
         attribute and the schema, supertypes, and implementation of the class. It
         does not specify a type name. Instead, the type has a name assigned 
         internally by the compiler that is not available at compilation time.</para>
         
         <para>An <literal>object</literal> class:</para>
         
         <itemizedlist>
             <!-- 
             <listitem>
                 <para>is implicitly <literal>final</literal>,</para>
             </listitem>
             -->
             <listitem>
                 <para>may not be extended by another class,</para>
             </listitem>
             <listitem>
                 <para>may not be <literal>abstract</literal> or <literal>formal</literal>, 
                 and</para>
             </listitem>
             <listitem>
                 <para>may not declare <literal>default</literal> members.</para>
             </listitem>
         </itemizedlist>
         
         <para>If the <literal>object</literal> is annotated <literal>shared</literal>, 
         the class is <literal>shared</literal>.<!-- If the <literal>object</literal> 
         is annotated <literal>variable</literal>, the class is a <literal>variable</literal> 
         class.--></para>
         
         <para>An <literal>object</literal> attribute:</para>
         
         <itemizedlist>
             <listitem>
                 <para>is non-<literal>variable</literal>, and</para>
             </listitem>
             <listitem>
                 <para>may not be refined or declared <literal>default</literal>.</para>
             </listitem>
         </itemizedlist>
         
         <para>If the <literal>object</literal> is annotated <literal>shared</literal>, 
         the attribute is <literal>shared</literal>. If the <literal>object</literal>
         is annotated <literal>actual</literal>, it refines an attribute of a 
         supertype.</para>
         
         <para>The following declaration:</para>
         
         <programlisting>shared object red extends Color('FF0000') {
     shared actual String string = "Red";
}</programlisting>

         <para>Is exactly equivalent to:</para>
         
         <programlisting>class Color_red extends Color('FF0000') {
     shared actual String string = "Red";
}

shared Color_red red = Color_red();</programlisting>
         
         <para>Where <literal>Color_red</literal> is a name generated by the compiler.
         The algorithm for generating this name is not specified here.</para>
         
         <para>Note that a member of an anonymous class that is not annotated 
         <literal>actual</literal> may only be accessed from within the body of 
         the anonymous class or by directly invoking the <literal>object</literal> 
         attribute.</para>
         
         <programlisting>shared object sql {
    shared String escape(String string) { ... }
}

...

String escapedSearchString = sql.escape(searchString);</programlisting>

        <comment><para>TODO: I'm increasingly inclined to think that this is backwards:
        a class should be an <literal>object</literal> with parameters. We could rewrite
        this stuff so that a <literal>class</literal> is equivalent to an interface with
        a typeclass that satisfies <literal>Callable</literal> and returns a nested 
        <literal>object</literal>. We might have to make an <literal>object</literal> a 
        type, and give it an uppercase name, and/or let you <literal>extend</literal> an
        <literal>object</literal> but that would end up a little more regular anyway, 
        since the <literal>of</literal> clause would now always contain a list of types. 
        The only oddity would be that some common values would getter uppercase names: 
        <literal>True</literal>, <literal>False</literal>, <literal>Null</literal>, 
        etc.</para></comment>
        
        <comment><para>TODO: Alternatively, a different approach to making this feature
        feel more regular, that is also perhaps more practically useful, would be to 
        reconceptualize the syntax above as a kind of attribute declaration, and also
        support a parameterized <literal>object</literal> declaration&mdash;which would
        be a useful shortcut for specifying a callable parameter value in a named argument 
        list or refining a method declaration when the callable parameter or method has an 
        abstract return type.</para></comment>
        
        <comment><para>TODO: Should we support <literal>object</literal>s as part of the
        expression syntax, like anonymous classes in Java. The syntax would be, for example:</para>
        <programlisting>return object extends AbstractReader(stream) { 
        ...
    };</programlisting>
        <programlisting>return object satisfies Usable { 
        actual void begin() { ... } 
        actual void close() { ... } 
    };</programlisting>
        <para>This is can be viewed as regular, following the same pattern as a regular 
        class instantiation, which can be written either as <literal>x = X { ... };</literal> 
        or as <literal>X x { ... }</literal>. Here we're letting you write either 
        <literal>x = object satisfies X { ... };</literal> or 
        <literal>object x satisfies X { ... }</literal>.</para>
        </comment>
        
        <comment><para>TODO: We could add a built-in type constructor to give access to 
        the concrete type of an <literal>object</literal>. It would look something like
        <literal>type&lt;sql&gt;</literal> and in theory you could let it accept any
        expression, even stuff like <literal>type&lt;foo.x+bar.y&gt;</literal>.</para></comment>
        
    </section>
    
    <section id="classeswithcases">
        <title>Classes with enumerated cases</title>
        
        <para>The <literal>of</literal> clause of a class declaration specifies the 
        list of cases of the class.</para>
        
        <programlisting>shared abstract class Boolean() 
        of true | false 
        extends Case() {}
        
shared object true extends Boolean() {}
shared object false extends Boolean() {}</programlisting>

        <programlisting><![CDATA[shared abstract class Node<Element>(String name) 
        of Branch<Element> | Leaf<Element> { ... }
        
shared class Leaf<Element>(String name, Element value) 
        extends Node<Element>(name) { ... }
        
shared class Branch<Element>(String name, Node<Element> left, Node<Element> right) 
        extends Node<Element>(name) { ... }]]></programlisting>
                
        <para>The cases may be classes or toplevel anonymous classes. A case may 
        be an <literal>abstract</literal> class. Each case must be a subclass of 
        the class.</para>
        
        <!--
        <para>If an anonymous class is a case of a class, the class must extend
        the class <literal>Case</literal> defined in <literal>ceylon.language</literal>, 
        directly or indirectly.</para>
        -->
                
        <para>If a class has an <literal>of</literal> clause, then every subtype 
        of the class must be a subtype of one of the enumerated cases.</para>
        
        <para>A non-<literal>abstract</literal> class may not have an <literal>of</literal> 
        clause.<!--A <literal>final</literal> class may not have an <literal>of</literal> 
        clause. --></para>
        
        <comment><para>TODO: We could default the <literal>extends Case()</literal>
        for classes with an <literal>of</literal> clause.</para></comment>
        
        <!--
        <comment><para>TODO: We could let a non-<literal>abstract</literal> class
        limit its subtypes. In which case we could use the syntax <literal>of none</literal> 
        to mean <literal>final</literal>.</para></comment>
        -->
        
        <comment><para>TODO: Should we introduce an abbreviated syntax like:</para>
        <programlisting>shared abstract class Boolean() of case true | case false {}</programlisting>
        <para>Note that it must be <literal>case</literal> instead of <literal>object</literal>
        to resolve an ambiguity between an annotation and the class body followed by 
        a declaration.</para>
        </comment>
        
    </section>
        
    <section id="classaliases">
        <title>Class aliases</title>
        
        <para>A class declaration which specifies a reference to another class type 
        defines a <emphasis>class alias</emphasis> of the specified class type.</para>
        
        <para>The specified class type may be a produced type (it may specify type 
        arguments). A class alias simply assigns an alternative name to the original 
        class type or produced type.</para>
        
        <programlisting>shared class People(Person... people) = ArrayList&lt;Person&gt;;</programlisting>
        
        <para>The callable type of the specified type must be assignable to the 
        callable type of the class alias.</para>
        
        <para>Class aliases are not reified types. The metamodel reference for a class 
        alias&mdash;for example, <literal>People</literal>&mdash;returns the metamodel 
        object for the aliased class&mdash;in this case, 
        <literal>ArrayList&lt;Person&gt;</literal>.</para>
    
    </section>
        
    </section>
    
    
    <!-- <programlisting>shared interface TransactionPropagation {
    void propagate(Transaction tx);
}

shared choice TransactionPropagationStyle 
        satisfies TransactionPropagation {
        
    abstract class BaseTransactionPropagation()
            satisfies TransactionPropagation {
        
        shared actual void propagate(Transaction tx) {
            if (tx.inProgress) {
                inProgress(tx);
            }
            else {
                notInProgress(tx);
            }
        }
        
        shared void inProgress(Transaction tx);
        
        shared void notInProgress(Transaction tx);
        
    }
    
    shared object required 
            extends BaseTransactionPropagation() { 
        shared actual void inProgress(Transaction tx) {}
        shared actual void notInProgress(Transaction tx) {
            tx.begin();
        }
    }
    
    shared object supports 
            extends BaseTransactionPropagation() {
        shared actual void inProgress(Transaction tx) {}
        shared actual void notInProgress(Transaction tx) {}
    }
    
    shared object mandatory 
            extends BaseTransactionPropagation() { 
        shared actual void inProgress(Transaction tx) {}
        shared actual void notInProgress(Transaction tx) {
            throw TransactionMandatory();
        }
    }
    
    shared object notSupported 
            extends BaseTransactionPropagation() { 
        shared actual void inProgress(Transaction tx) {
            throw TransactionNotSupported();
        }
        shared actual void notInProgress(Transaction tx) {}
    }
    
    shared object requiresNew 
            extends BaseTransactionPropagation() { 
        shared actual void inProgress(Transaction tx) {
            throw TransactionRequiresNew();
        }
        shared actual void notInProgress(Transaction tx) {
            tx.begin();
        }
    }
    
}</programlisting>-->
        
    <section id="methods">
        <title>Methods</title>
        
        <para>A <emphasis>method</emphasis> is a callable block of code. Methods may 
        have parameters and may return a value.</para>
        
        <programlisting>Method: Annotation* MethodHeader (Block | NamedArguments | Specifier? ";")</programlisting>
        
        <para>All method declarations specify the method name, one or more parameter 
        lists, and, optionally, a list of type parameters. A method declaration may 
        specify a type, called the <emphasis>return type</emphasis>, to which the 
        values the method returns are assignable, or it may specify that the method 
        is a <literal>void</literal> method&mdash;a method which does not return a 
        value. The return type of a <literal>void</literal> method is considered to 
        be <literal>Void</literal>. A method declaration may have a list of type 
        constraints.</para>
        
        <programlisting>MethodHeader: (InferableType | "void") MemberName TypeParams? Params+ Metatypes? TypeConstraints?</programlisting>
        
        <para>The Ceylon compiler preserves the names of method parameters.</para>
        
        <!--<section id="methodbodies">
            <title>Method bodies</title>-->
        
        <para>A method implementation may be specified using either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a block of code, or</para>
            </listitem>
            <listitem>
                <para>a reference to another method, or</para>
            </listitem>
            <listitem>
                <para>a named argument list.</para>
            </listitem>
        </itemizedlist>
        
        <!--
        <para>A member method body may invoke, evaluate or assign members of the instance
        being invoked&mdash;the current instance of the class which defines the 
        method&mdash;without explicitly specifying the receiver.</para>
        
        <para>A member method body of a member class may invoke, evaluate or assign members 
        of the current instance of the containing class or interface (the containing instance 
        of the instance upon which the method was invoked) without explicitly specifying the 
        receiver.</para>
        
        <para>A toplevel method body may not refer to <literal>this</literal> or 
        <literal>super</literal>, since there is no current instance.</para>
        
        <para>A method may be declared inside the body of another method or attribute, in 
        which case it may refer to any non-<literal>variable</literal> local, block local 
        attribute getter or block local method declared earlier within the containing scope. 
        It may not refer to <literal>variable</literal> locals from the containing scope.</para>
        -->
        
        <section id="callabletype">
            <title>Callable type of a method</title>
            
        <para>The <emphasis>callable type</emphasis> of a method captures the return
        type and parameter types of the method.</para>
        
        <itemizedlist>
        <listitem>
            <para>The callable type of a method with a single parameter list is 
            <literal>Callable&lt;R,P...&gt;</literal> where <literal>R</literal> is the 
            return type of the method, or <literal>Void</literal> if the method is 
            <literal>void</literal>, and <literal>P...</literal> are the parameter types 
            of the method.</para>
        </listitem>
        <listitem>
            <para>The callable type of a method with multiple parameter lists is 
            <literal>Callable&lt;O,P...&gt;</literal>, where <literal>O</literal> is the
            callable type of a method produced by eliminating the first parameter list, 
            and <literal>P...</literal> are the parameter types of the first parameter 
            list of the method.</para>
        </listitem>
        </itemizedlist>
        
        <para>A sequenced parameter is considered of type <literal>T[]</literal> where 
        <literal>T...</literal> is the declared sequenced type.</para>
        
        </section>
        
        <section id="methodswithblocks">
            <title>Methods with blocks</title>
            
        <para>A method implementation may be a block. If the method is a <literal>void</literal> 
        method, the block may not contain a <literal>return</literal> directive that 
        specifies an expression. Otherwise, every conditional execution path of the block 
        must end in a <literal>return</literal> directive that specifies an expression
        assignable to the return type of the method.</para>
        
        <programlisting>shared Integer add(Integer x, Integer y) {
    return x + y;
}</programlisting>
    
        <programlisting>Identifier createToken() {
    return Token();
}</programlisting>

        <programlisting>shared void print(Object... objects) {
    for (Object obj in objects) {
        log.info($obj);
    }
}</programlisting>

        <programlisting>shared void addEntry(Key key -> Value value) {
    map.define(key,value);
}</programlisting>

        <programlisting><![CDATA[shared Set<Element> singleton<Element>(Element element) 
        given Element satisfies Comparable<Element> {
    return TreeSet(element);
}]]></programlisting>
        
        <!--
        <programlisting>shared Float[n] float&lt;#n&gt;(Decimal[n] decimals) {
    return Vector&lt;Float,#n&gt;() 
                containing (Bounded&lt;#n&gt; i) (decimals[i].float);
}</programlisting>
        -->
        
        <para>Note that a method which declares the return type <literal>Void</literal>
        is not a <literal>void</literal> method. A method with declared type 
        <literal>Void</literal> must return a value of type <literal>Void</literal> 
        (any value will do).</para>
        
        <programlisting>void say(String) { ... }

void hello() {
    say("hello");
}
        
Void goodbye() {
    return say("goodbye");
}</programlisting>
        
        <para>A non-<literal>void</literal> block local method may be declared using 
        the keyword <literal>local</literal> in place of the explicit return type 
        declaration. Then the method return type is inferred:</para>
        
        <itemizedlist>
            <listitem>
                <para>if the method contains no <literal>return</literal> directive,
                then the return type of the method is <literal>Bottom</literal> (this
                is the case where the method always terminates in a <literal>throw</literal>
                directive), or</para>
            </listitem>
            <listitem>
                <para>otherwise, the return type of the method is the union of all 
                returned expression types of <literal>return</literal> directives
                of the method body.</para>
            </listitem>
        </itemizedlist>
        
        <para>This method has inferred return type <literal>Integer</literal>.</para>

        <programlisting>local add(Integer x, Integer y) {
    return x + y;
}</programlisting>

        <para>This method has inferred return type <literal>Float|Integer</literal>.</para>

        <programlisting>local unit(Boolean floating=false) {
    if (floating) {
        return 1.0;
    }
    else {
        return +1;
    }
}</programlisting>

        <para>This method has inferred return type <literal>Bottom</literal>.</para>

        <programlisting>local die() {
    throw;
}</programlisting>

        
        </section>
        
        <section id="methodswithspecifiers">
            <title>Methods with specifiers</title>
            
        <para>Alternatively, a method implementation may be an expression that evaluates 
        to a callable object, specified using <literal>=</literal>. The type of the 
        callable object must be assignable to the callable type of the method.</para>
        
        <programlisting>Float say(String words) = person.say;</programlisting>
        
        <programlisting>Float sqrt(Float x) = 2.root;</programlisting>
        
        <programlisting>Comparison order(String x, String y) = getOrder();</programlisting>
        
        <para>The callable object expression may not refer to parameters of the
        method.</para>
        
        <para>A block local method which specifies a callable object expression may be 
        declared using the keyword <literal>local</literal> in place of the explicit 
        return type declaration. The return type of the method is inferred to be the
        type of the type argument to the first type parameter of the expression type
        <literal>Callable</literal> (the return type).</para>
        
        <programlisting>local sqrt(Float x) = 2.root;</programlisting>
        
        </section>
        
        <section id="methodswithnamedarguments">
            <title>Methods with named argument lists</title>
            
            <para>The final possibility is that a method implementation may be a named
            argument list. A method with a named argument list must explicitly declare 
            an invocable type (a non-<literal>abstract</literal> class, or any other
            type with a callable metatype) as the return type. The method simply 
            invokes the return type with the specified named arguments and returns the 
            resulting value.</para>
            
            <para>The following declarations are equivalent:</para>
            
            <programlisting>Html login(HttpRequest request) {
    head = Head { title="Hello" };
    body = Body { 
        Div { "Hello World" } 
    };
}</programlisting>
            
            <programlisting>Html login(HttpRequest request) {
    return Html {
        head = Head { title="Hello" };
        body = Body { 
            Div { "Hello World" } 
        };
    };
}</programlisting>
            
            <comment><para>TODO: we could add a keyword or punctuation to help 
            disambiguate the two forms of method implementation, for example:</para>
            <programlisting>Html login(HttpRequest request) with {
    Head head with { ... }
    Body body with { ... }
}</programlisting>
            <para>The following option is especially interesting because it 
            would unify nicely with the sequence enumeration syntax we already 
            have:</para>
            <programlisting>Html login(HttpRequest request) = {
    Head head = { ... }
    Body body = { ... }
}</programlisting>
            <para>However, <literal>=</literal> already means specification of 
            an immutable value, which is not what is happening here!</para>
            </comment>
            
        </section>
                
        <section id="multipleparameterlists">
            <title>Methods with multiple parameter lists</title>
            
        <para>A method may declare multiple lists of parameters. A method which 
        declares more than one parameter list returns instances of 
        <literal>Callable</literal>, usually method references.</para>
        
        <para>The type of the expression specified by the <literal>return</literal> 
        directive may be be assignable to either:</para>
        
        <itemizedlist>
            <listitem><para>the callable type of a method produced by taking the 
            method with multiple parameter lists and eliminating the first parameter 
            list, or</para></listitem>
            <listitem><para>the declared return type of the method.</para></listitem>
        </itemizedlist>
        
        <para>If the <literal>return</literal> expression type is assignable to the 
        callable type of the method produced by eliminating the first parameter 
        list of the method, the method body may <emphasis>only</emphasis> refer to 
        parameters in the first parameter list. It may not refer to parameters of 
        other parameter lists. Parameters declared by parameter lists other than the 
        first parameter list are not considered visible inside the body of the 
        method.</para>
        
        <programlisting>Comparison getOrder()(Natural x, Natural y) {
    Comparison order(Natural x, Natural y) { return x&lt;=&gt;y; }
    return order;
}</programlisting>

        <para>Otherwise, if the <literal>return</literal> expression type is assignable 
        to the declared return type of the method, the method body may refer to any
        parameter in any one of the parameter lists of the method. The compiler 
        automatically infers a series of nested methods, one for each parameter list of 
        the method. The declarations and statements in the method body form the body of 
        the most nested inferred method.</para>
        
        <para>This method declaration:</para>
        
        <programlisting>Comparison getOrder()(Natural x, Natural y) {
    return x&lt;=&gt;y;
}</programlisting>

        <para>is equivalent to the previous example. The compiler infers a method with
        the same signature and implementation as <literal>order()</literal> above.</para>

        <para>For a method with <literal>n</literal> parameter lists, there are 
        <literal>n</literal> inferred methods. The <literal>i</literal>th inferred 
        method:</para>
        
        <itemizedlist>
            <listitem>
                <para>has the same return type as the original declared method,</para>
            </listitem>
            <listitem>
                <para>has the same parameter lists as the declared method, after 
                eliminating the first <literal>i-1</literal> parameter lists, 
                and</para>
            </listitem>
            <listitem>
                <para>if <literal>i&lt;n</literal>, has a body which contains the
                definition of the <literal>i+1</literal>th inferred method and 
                simply returns a reference to that method, or</para>
            </listitem>
            <listitem>
                <para>otherwise, if <literal>i=n</literal>, has the body of the original
                declared method.</para>
            </listitem>
        </itemizedlist>
        
        <para>The first inferred method replaces the original declared method in the 
        definition of the class.</para>
        
        <para>This method declaration:</para>
        
        <programlisting>shared String fullName(String firstName)(String middleName)(String lastName) {
    return firstName + " " + middleName + " " lastName;
}</programlisting>
        
        <para>Is equivalent to:</para>
        
        <programlisting>shared String fullName(String firstName)(String middleName)(String lastName) {
    String fullName2(String middleName)(String lastName) {
        String fullName3(String lastName) {
            return firstName + " " + middleName + " " + lastName;
        }
        return fullName3;
    }
    return fullName2;
}</programlisting>
                
        <comment><para>TODO: To be totally complete and regular with attribute getters,
        I suppose we should let any method body return a method reference with the same 
        signature as the method. But I'm not really sure how practically useful this
        would be.</para></comment>
                
        </section>
        
        <!--
        <section id="overloadedmethods">
            <title>Overloaded methods</title>
            
            <para>Multiple toplevel methods belonging to the same package, or multiple 
            methods of the same containing body may may declare the same name. A class or
            interface may declare or inherit multiple methods with the same name. The 
            methods are called <emphasis>overloaded</emphasis>. Overloaded methods:</para>
            
            <itemizedlist>
                <listitem>
                    <para>must have distinct erased signatures, and</para>
                </listitem>
                <listitem>
                    <para>may not declare default parameters.</para>
                </listitem>
            </itemizedlist>
            
            <para>A class may not not declare or inherit a method with the same name as
            an attribute it declares or inherits.</para>
            
            <para>An invocation expression is resolved to a particular overloaded method 
            declaration at compile time, using the argument expression types.</para>
            
            <para>A package or body may not declare or inherit two methods with the 
            same name unless either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the methods are overloaded,</para>
                </listitem>
                <listitem>
                    <para>one method refines the other method, or</para>
                </listitem>
                <listitem>
                    <para>one method is defined by a supertype, and is not visible
                    to the subtype that defines the other method.</para>
                </listitem>
            </itemizedlist>
        
        </section>
        -->
        
       <section id="formalmethods">
            <title>Formal and default methods</title>
            
            <para>If there is no method implementation in a method declaration, then
            either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the implementation of the method must be specified later in 
                    the body containing the method declaration,</para>
                </listitem>
                <listitem>
                    <para>the method must be a member of an interface, and the method
                    must be annotated <literal>formal</literal>, or</para>
                </listitem>
                <listitem>
                    <para>the method must be a member of a class, the method must be 
                    annotated <literal>formal</literal>, and the class that declares 
                    the method must be annotated <literal>formal</literal> or
                    <literal>abstract</literal>.</para>
                </listitem>
            </itemizedlist> 
            
            <para>If the method is annotated <literal>formal</literal>, it is called a 
            <literal>formal</literal> method, or, sometimes, an <emphasis>abstract 
            method</emphasis>.</para>
            
            <para>A method annotated <literal>formal</literal> may not specify an
            implementation (a block, specifier, or named argument list).</para>
        
            <programlisting>shared formal Value? get(Key key);</programlisting>
            
            <para>A toplevel method may not be annotated <literal>formal</literal> and 
            must have a method implementation (a block of code, or a reference to another 
            method).</para>
            
            <para>A block local method may not be annotated <literal>formal</literal> 
            and must have a method implementation.</para>

            <para>A method which is not annotated <literal>formal</literal> is called a 
            <emphasis>concrete</emphasis> method.</para>
        
            <para>A concrete member method may be annotated <literal>default</literal>.
            <!-- or <literal>definite</literal> <emphasis>(Note that <literal>definite</literal> is 
            a proposed feature for a future version of the language.)</emphasis--></para>            
            
        </section>
                
        <section id="refiningmethods">
            <title>Method refinement</title>
            
            <para>Methods may be refined, just like in other object-oriented languages.</para>
            
            <itemizedlist>
            <listitem>
                <para>A class or interface may refine any <literal>formal</literal> 
                or <literal>default</literal> method it inherits, unless it inherits 
                a non-<literal>formal</literal> non-<literal>default</literal> method that 
                refines the method.</para>
            </listitem>
            <listitem>
                <para>A concrete class must refine every <literal>formal</literal> 
                <!--or <literal>definite</literal>--> method it inherits, unless it inherits 
                a non-<literal>formal</literal> <!--non-<literal>definite</literal>--> 
                method that refines the method.</para>
            </listitem>
            </itemizedlist>           
            
            <para>A method of a subtype <emphasis>refines</emphasis> a method of
            a supertype if the first method:</para>
            
            <itemizedlist>
                <listitem>
                    <para>is annotated <literal>actual</literal>,</para>
                </listitem>
                <listitem>
                    <para>has the same name as the method it refines,</para>
                </listitem>
                <listitem>
                    <para>has the same number of parameter lists, with the same
                    signatures, as the method it refines, after substitution of 
                    type arguments specified in the <literal>extends</literal> or 
                    <literal>satisfies</literal> clause of the class, and</para>
                </listitem>
                 <listitem>
                    <para>has a return type that is assignable to the return type 
                    of the method it refines in the compilation unit containing
                    the method annotated <literal>actual</literal>, after 
                    substitution of type arguments specified in the 
                    <literal>extends</literal> or <literal>satisfies</literal> 
                    clause of the class.</para>
                </listitem>
            </itemizedlist>
            
            <para>Finally, the refined method must be visible to the method
            annotated <literal>actual</literal>.</para>
            
            <para>If a method is annotated <literal>actual</literal>, it must 
            refine some method defined by a supertype, and the method it refines 
            must be either <literal>formal</literal> or <literal>default</literal>. 
            <!--or <literal>definite</literal>.--></para>
            
            <para>A method may not, directly or indirectly, refine two different
            methods not themselves annotated <literal>actual</literal>.</para>
        
            <para>Then invocation of the method is polymorphic, and the actual
            method invoked depends upon the concrete type of the class instance.</para>
            
            <programlisting>shared abstract class AbstractSquareRooter() {
    shared formal Float squareRoot(Float x);
}</programlisting>

            <programlisting>class ConcreteSquareRooter()
        extends AbstractSquareRooter() {
    shared actual Float squareRoot(Float x) { ... }
}</programlisting>
            
            <para>For <literal>formal</literal> methods, a special shortcut form of 
            refinement is permitted. A subclass initializer may simply specify an 
            instance of <literal>Callable</literal> as the implementation of the method 
            declared by the supertype. No parameter list, return type declaration, or 
            <literal>actual</literal> annotation is necessary.</para>
            
            <programlisting>class ConcreteSquareRooter()
        extends AbstractSquareRooter() {
    Float sqrt(Float x) { ... }
    squareRoot = sqrt;
}</programlisting>
            
            <para>Toplevel methods cannot be refined, and so toplevel method invocation 
            is never polymorphic.</para>
            
            <comment><para>TODO: are you allowed to refine the default value of a 
            defaulted parameter?</para></comment>
            
            <comment><para>TODO: are you required to have the same parameter names in 
            the two methods? I don't see that this would be necessary. In a named 
            argument invocation, you just use the names declared by the member of the 
            compile-time type, and they are mapped positionally to the parameters of 
            the refining method.</para></comment>
        
        </section>
        
    </section>
    
    <section id="attributes">
        <title>Attributes</title>
        
        <para>There are three kinds of declarations related to <emphasis>attribute</emphasis> 
        definition:</para>
        
        <itemizedlist>
            <listitem>
                <para>Simple attribute declarations define state (very similar to a 
                Java field or local variable).</para>
            </listitem>
            <listitem>
                <para>Attribute getter declarations define how the value of a derived 
                attribute is obtained.</para>
            </listitem>
            <listitem>
                <para>Attribute setter declarations define how the value of a derived 
                attribute is assigned.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>Attribute: Annotation* (SimpleAttribute | AttributeGetter | AttributeSetter)</programlisting>
    
        <para>Unlike Java fields, Ceylon attribute access is polymorphic and attribute 
        definitions may be refined by subclasses.</para>
        
        <para>All attributes have a type and name. The type of the attribute is specified
        by the simple attribute declaration or attribute getter declaration. An attribute 
        may be <literal>variable</literal>, in which case its value can be assigned using 
        the <literal>:=</literal> and compound assignment operators. This is the case for
        simple attributes explicitly annotated <literal>variable</literal>, or for 
        attributes with a setter declaration.</para>
            
        <programlisting>AttributeHeader: InferableType MemberName</programlisting>
        
        <para>Note that an attribute declaration is essentially a method declaration with 
        zero parameter lists. Likewise, an attribute evaluation is essentially a method 
        invocation with zero argument lists.</para>
        
        <para>A toplevel attribute may not be <literal>variable</literal>.</para>
        
        <para>If a class declares or inherits a <literal>variable</literal> attribute, it 
        must (directly or indirectly) extend the class <literal>IdentifiableObject</literal> 
        defined in <literal>ceylon.language</literal>.</para>
        
        <para>An attribute of type <literal>Gettable</literal> or <literal>Settable</literal> 
        may not be <literal>variable</literal>.</para>
        
        <!--<section id="attributebodies">
            <title>Attribute bodies</title>-->
        <!-- 
        <para>A member attribute body may invoke, evaluate or assign members of the 
        instance being invoked&mdash;the current instance of the class which defines the 
        method&mdash;without explicitly specifying the receiver.</para>
        
        <para>A member attribute body of a member class may invoke, evaluate or assign 
        members of the current instance of the containing class or interface (the containing 
        instance of the instance upon which the attribute was invoked) without explicitly 
        specifying the receiver.</para>
        
        <para>A toplevel attribute body may not refer to <literal>this</literal> or 
        <literal>super</literal>, since there is no current instance.</para>
        
        <para>An attribute may be declared inside the body of another method or attribute, 
        in which case it may refer to any non-<literal>variable</literal> local, block local 
        attribute getter or block local method declared earlier withing the containing scope. 
        It may not refer to <literal>variable</literal> locals from the containing scope.</para>
        -->
        
        <section id="simpleattributesandlocals">
            <title>Simple attributes and locals</title>
            
        <para>A simple attribute defines state.</para>
        
        <programlisting>SimpleAttribute: AttributeHeader ( (Specifier | Initializer)? ";" | NamedArguments )</programlisting>
        
        <para>A simple attribute or local annotated <literal>variable</literal> represents a
        value that can be assigned multiple times. A simple attribute or local not annotated
        <literal>variable</literal> represents a value that can be specified exactly once.</para>
        
        <para>The value of a non-<literal>variable</literal> attribute is specified using 
        <literal>=</literal>. A <literal>variable</literal> attribute may be initialized using 
        the assignment operator <literal>:=</literal>.</para>

        <programlisting>Initializer: ":=" Expression</programlisting>

        <para>Parameters of classes and methods are also considered to be locals.</para>
                 
        <programlisting>variable Natural count := 0;</programlisting>
        
        <programlisting>shared Integer max = +99;</programlisting>

        <programlisting>shared Decimal pi = calculatePi();</programlisting>
        
        <programlisting>shared Natural[] evenDigits = {0,2,4,6,8};</programlisting>

        <para>A simple attribute declared directly inside the body of a class represents state 
        associated with the instance of the class. Repeated evaluation of the attribute of a 
        particular instance of the class returns the same result until the attribute of the 
        instance is assigned a new value.</para>
        
        <para>A <emphasis>local</emphasis> represents state associated with execution of a
        particular block of code. A local is really just a special case of a simple attribute 
        declaration, but one whose state is not held across multiple executions of the block
        of code in which the local is defined.</para> 
        
        <itemizedlist>
            <listitem>
                <para>A simple attribute declared inside a block (the body of a method, attribute 
                getter or attribute setter) is a local.</para>
            </listitem>
             <listitem>
                <para>A block local simple attribute declared inside the body of a class is a 
                local if it is not used inside a method, attribute setter or attribute getter 
                declaration.</para>
            </listitem>
           <listitem>
                <para>A parameter of a class is a local if it is not used inside a method, 
                attribute setter or attribute getter declaration.</para>
            </listitem>
            <listitem>
                <para>A parameter of a method is a local.</para>
            </listitem>
        </itemizedlist>
        
        <para>A local is a block local declaration&mdash;it is visible only to statements and 
        declarations that occur later in the same block or class body, and therefore it may not 
        be annotated <literal>shared</literal>.</para>
        
        <para>The semantics of locals are identical to Java local variables.</para>
        
        <para>The compiler is permitted to optimize block local simple attributes to a simple 
        Java field declaration or local variable. Block local attributes may not be accessed 
        via reflection.</para>
        
        <para>A block local simple attribute with a specifier or initializer may be declared 
        using the keyword <literal>local</literal> in place of the explicit type declaration. 
        The type of the local or attribute is inferred to be the type of the specifier or
        initializer expression.</para>
        
        <programlisting>local names = List&lt;String&gt;();</programlisting>
        <programlisting>variable local count:=0;</programlisting>
                
        </section>
        
        <section id="attributeswithnamedarguments">
            <title>Attributes with named argument lists</title>
            
            <para>Alternatively, a non-<literal>variable</literal> simple attribute may 
            specify a named argument list. An attribute with a named argument list must 
            explicitly declare an invocable type (a non-<literal>abstract</literal> 
            class, or any other type with a callable metatype) as the attribute type. 
            The attribute value is determined by simply invoking the return type with 
            the specified named arguments.</para>
            
            <para>The following declarations are equivalent:</para>
            
            <programlisting>Module module {
    name = 'org.hibernate';
    version = '3.0.0';
}</programlisting>
            
            <programlisting>Module module = Module {
    name = 'org.hibernate';
    version = '3.0.0';
}</programlisting>
            
            <!--
            <comment><para>TODO: should this syntax build a new object each time the attribute 
            is evaluated, or should it construct the object once and return the same object
            each time?</para></comment>
            -->
             
        </section>
        
         <section id="attributegetters">
            <title>Attribute getters</title>
            
            <para>An attribute getter is a callable block of code with no parameters,
            that returns a value.</para>
            
            <programlisting>AttributeGetter: AttributeHeader Block</programlisting>
            
            <para>An attribute getter defines how the value of a derived attribute is
            obtained.</para>
                                
            <programlisting>shared Float total {
    Float sum := 0.0;
    for (LineItem li in lineItems) {
        sum += li.amount;
    }
    return sum;
}</programlisting>
        
            <para>If an attribute getter has a matching attribute setter, we say that 
            the attribute is <literal>variable</literal>. Otherwise we say it is 
            non-<literal>variable</literal>.</para>
                        
            <para>A block local attribute getter may be declared using the keyword 
            <literal>local</literal> in place of the explicit type declaration. Then 
            the attribute type is inferred:</para>
        
        <itemizedlist>
            <listitem>
                <para>if the getter contains no <literal>return</literal> directive,
                then the type of the attribute is <literal>Bottom</literal> (this is 
                the case where the getter always terminates in a <literal>throw</literal>
                directive), or</para>
            </listitem>
            <listitem>
                <para>otherwise, the type of the attribute is the union of all returned 
                expression types of <literal>return</literal> directives of the getter 
                body.</para>
            </listitem>
        </itemizedlist>
        
            <para>This attribute has inferred type <literal>Name</literal>.</para>
        
            <programlisting>local name { 
    return Name(firstName, initial, lastName);
}</programlisting>
                
        </section>
                
        <section id="attributesetters">
            <title>Attribute setters</title>
                    
            <para>An attribute setter is a callable block of code that accepts a
            single value and does not return a value.</para>
            
            <programlisting>AttributeSetter: "assign" MemberName Block</programlisting>

            <para>An attribute setter defines how the value of a derived attribute is
            assigned. Every attribute setter must have a corresponding getter with the
            same name.</para>

            <programlisting>shared String name { return join(firstName, lastName); }
shared assign name { firstName := first(name); lastName := last(name); }</programlisting>
                        
            <comment><para>TODO: should we require that the corresponding getter be 
            annotated <literal>variable</literal>?</para></comment>
            
            <!--
            <comment><para>TODO: should we allow overloaded attribute setters, for example:</para>
            <programlisting>assign Name name { firstName = name.firstName; lastName = name.lastName; }</programlisting>
            </comment>
            -->
            
        </section>
        
        <section id="formalattributes">
            <title>Formal and default attributes</title>
            
            <para>If there is no specifier, initializer, or getter implementation, then
            either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the value or implementation of the attribute must be specified 
                    later in the body containing the attribute declaration,</para>
                </listitem>
                <listitem>
                    <para>the attribute must be a member of an interface, and the 
                    attribute must be annotated <literal>formal</literal>, or</para>
                </listitem>
                <listitem>
                    <para>the attribute must be a member of a class, the attribute must 
                    be annotated <literal>formal</literal>, and the class that declares 
                    the attribute must be annotated <literal>formal</literal> or
                    <literal>abstract</literal>.</para>
                </listitem>
            </itemizedlist> 
            
            <para>If the attribute is annotated <literal>formal</literal>, it is called 
            a <literal>formal</literal> attribute, or, sometimes, an <emphasis>abstract 
            attribute</emphasis>.</para>
            
            <para>An attribute annotated <literal>formal</literal> may not specify an
            implementation (a specifier, initializer, or getter implementation).</para>
        
            <programlisting>shared formal variable String firstName;</programlisting>

            <para>A toplevel attribute declaration may not be annotated <literal>formal</literal> 
            and must have a specifier or getter implementation.</para>

            <para>A block local attribute may not be annotated <literal>formal</literal> 
            and must have a specifier or getter implementation.</para>

            <para>An attribute which is not annotated <literal>formal</literal> is called 
            a <emphasis>concrete</emphasis> attribute.</para>
        
            <para>A concrete member attribute may be annotated <literal>default</literal>.
            <!--or <literal>definite</literal> <emphasis>(Note that <literal>definite</literal> is a 
            proposed feature for a future version of the language.)</emphasis> --></para>
            
        </section>
                
        <section id="refiningattributes">
            <title>Attribute refinement</title>
            
            <para>Ceylon allows attributes to be refined, just like methods. This helps
            eliminate the need for Java-style getter and setter methods.</para>
            
            <itemizedlist>
            <listitem>
                <para>A class or interface may refine any <literal>formal</literal> 
                or <literal>default</literal> attribute it inherits, unless it inherits 
                a non-<literal>formal</literal> non-<literal>default</literal> 
                attribute that refines the attribute.</para>
            </listitem>
            <listitem>
                <para>A concrete class must refine every <literal>formal</literal> 
                <!--or <literal>definite</literal>--> attribute it inherits, unless it 
                inherits a non-<literal>formal</literal> <!--non-<literal>definite</literal>-->
                attribute that refines the attribute.</para>
            </listitem>
            </itemizedlist>           
            
            <para>A non-<literal>variable</literal> attribute may be refined by a simple 
            attribute or attribute getter. A <literal>variable</literal> attribute may be 
            refined by a <literal>variable</literal> simple attribute or by an attribute 
            getter and setter pair.</para>
            
            <comment><para>TODO: are you allowed to refine a getter or setter without also 
            refining its matching setter or getter?</para></comment>
            
            <para>An attribute of a subtype <emphasis>refines</emphasis> an attribute of
            a supertype if the first attribute:</para>
            
            <itemizedlist>
                <listitem>
                    <para>is annotated <literal>actual</literal>,</para>
                </listitem>
                <listitem>
                    <para>has the same name as the attribute it refines,</para>
                </listitem>
                 <listitem>
                    <para>has a type that is assignable to the type of the attribute it 
                    refines in the compilation unit containing the attribute annotated 
                    <literal>actual</literal>, after substitution of type arguments 
                    specified in the <literal>extends</literal> or <literal>satisfies</literal> 
                    clause of the class,</para>
                </listitem>
                 <listitem>
                    <para>or has <emphasis>exactly the same type</emphasis> as the 
                    attribute it refines, after substitution of type arguments specified 
                    in the <literal>extends</literal> or <literal>satisfies</literal> clause
                    of the class, if the attribute it refines is <literal>variable</literal>, 
                    and</para>
                </listitem>
                <listitem>
                    <para>is <literal>variable</literal>, if the attribute it refines is 
                    <literal>variable</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Finally, the refined attribute must be visible to the attribute 
            annotated <literal>actual</literal>.</para>
        
            <para>If an attribute is annotated <literal>actual</literal>, it must 
            refine some attribute defined by a supertype, and the attribute it 
            refines must be either <literal>formal</literal> or <literal>default</literal>. 
            <!--or <literal>definite</literal>.--></para>
            
            <para>An attribute may not, directly or indirectly, refine two different
            attributes not themselves annotated <literal>actual</literal>.</para>
        
            <para>A non-<literal>variable</literal> attribute may be refined by a 
            <literal>variable</literal> attribute.</para>
            
            <comment><para>TODO: Is that really allowed? It could break the superclass.
            Should we say that you are allowed to do it when you refine an interface
            attribute, but not when you refine a superclass attribute?</para></comment>
            
            <para>Then evaluation and assignment of the attribute is polymorphic, and 
            the actual attribute evaluated or assigned depends upon the concrete type 
            of the class instance.</para>
            
            <programlisting>shared abstract class AbstractPi() {
    shared formal Float pi;
}</programlisting>

            <programlisting>class ConcretePi() 
        extends AbstractPi() {
    shared actual Float pi { ... }
}</programlisting>
            
            <para>For <literal>formal</literal> attributes, a special shortcut form 
            of refinement is permitted. A subclass initializer may simply specify or 
            assign a value to the attribute declared by the superclass. No type 
            declaration or <literal>actual</literal> annotation is necessary.</para>
            
            <programlisting>class ConcretePi() 
        extends AbstractPi() {
    Float calculatePi() { ... }
    pi = calculatePi();
}</programlisting>

            <comment><para>TODO: Why not also allow this for <literal>default</literal>
            attributes and methods??</para></comment>
            
            <para>Toplevel attributes cannot be refined, and so toplevel attribute 
            evaluation and assignment is never polymorphic.</para>
            
        </section>
        
        <!--section id="getterandsettermethods">
            <title>Getter and setter methods</title>
            
            <para>For each attribute, one or two methods exist implicitly:</para>
            
            <itemizedlist>
                <listitem>
                    <para>a <emphasis>getter method</emphasis> with no parameters 
                    which returns the attribute type, and</para>
                </listitem>
                <listitem>
                    <para>a <literal>void</literal> <emphasis>setter method</emphasis> 
                    with a single parameter of the attribute type, if the attribute is 
                    <literal>variable</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>These methods may be referred to using the <literal>get</literal> and 
            <literal>set</literal> keywords, for example:</para>
            
            <programlisting>String name = get person.name();</programlisting>
            <programlisting>set person.name(newName);</programlisting>
            
        
        </section-->
                
    </section>
        
    <section id="declarationmodifiers">
        <title>Declaration modifiers</title>
        
        <para>In Ceylon, all declaration modifiers are annotations.</para>
        
    <section id="compilerinstructions">
        <title>Summary of compiler instructions</title>
        
        <para>The following annotations are compiler instructions:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>shared</literal> specifies that a 
                declaration is visible outside of the package or body in 
                which it occurs.</para>
            </listitem>
            <listitem>
                <para><literal>abstract</literal> specifies that a class
                cannot be instantiated.</para>
            </listitem>
             <listitem>
                <para><literal>formal</literal> specifies that a member 
                does not specify an implementation and must therefore be 
                refined by every concrete subclass.</para>
            </listitem>
            <listitem>
                <para><literal>default</literal> specifies that a method, 
                attribute, or member class may be refined by subtypes.</para>
            </listitem>
            <listitem>
                <para><literal>actual</literal> indicates that a method,
                attribute, or member type refines a method, attribute, 
                or member type defined by a supertype.</para>
            </listitem>
            <listitem>
                <para><literal>variable</literal> specifies that an attribute
                or local may be assigned.</para>
            </listitem>
            <listitem>
                <para><literal>deprecated</literal> indicates that a method, 
                attribute or type is deprecated. It accepts an optional
                <literal>String</literal> argument. The compiler produces a
                warning when compiling code that depends upon a deprecated
                program element.</para>
            </listitem>
            <!--
            <listitem>
                <para><literal>definite</literal> specifies that a method or
                attribute must be refined by every concrete subclass. 
                <emphasis>(Note that <literal>definite</literal> is a proposed 
                feature for a future version of the language.)</emphasis></para>
            </listitem>
            -->
            <!-- 
            <listitem>
                <para><literal>final</literal> specifies that a class may not 
                be extended.</para>
            </listitem>
             -->
            <listitem>
                <para><literal>literal</literal> specifies that a class or 
                interface has a single quoted literal format.</para>
            </listitem>
        </itemizedlist>
        
        <para>The following annotation is a hint to the compiler that lets 
        the compiler optimize compiled bytecode for non-64 bit architectures:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>small</literal> specifies that a value of type
                <literal>Natural</literal>, <literal>Integer</literal> or
                <literal>Float</literal> contains 32-bit values.</para>
            </listitem>
        </itemizedlist>
        
        <para>By default, <literal>Natural</literal>, <literal>Integer</literal>
        and <literal>Float</literal> are assumed to represent 64-bit values.</para>
        
        <!--
        <para>The annotation names in this section are treated as keywords by 
        the Ceylon compiler. This is a performance optimization to minimize 
        the need for lookahead in the parser.</para>
        -->
        
        <!--
        <comment><para>TODO: should we have <literal>final</literal> to specify 
        that a class may not be extended?</para></comment>
        -->
        
        <!--
        <comment><para>TODO: should we make <literal>actual</literal> a keyword, 
        to save the effort of redeclaring the attribute type or method return type?</para></comment>
        -->
        
        <comment><para>TODO: how hard would it be to add a <literal>recursive</literal>
        annotation to force the compiler to optimize a tail-recursive method or
        getter?</para></comment>
        
    </section>
       
       <!--
       <para>The following annotations are important to the Ceylon SDK.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>id</literal> specifies that an attribute should
                be tested by the <literal>equals()</literal> method, and included
                in the <literal>hash</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>transient</literal> specifies that an attribute 
                is not included in the serialized form of the object.</para>
            </listitem>
            <listitem>
                <para><literal>read</literal> and <literal>write</literal>
                indicate methods or attributes that are protected from multithreaded
                access using a reentrant read/write lock with deadlock detection.</para>
            </listitem>
            <listitem>
                <para><literal>once</literal> indicates that a method or
                attribute getter is executed at most once, and the resulting 
                value is cached.</para>
            </listitem>
        </itemizedlist>
        -->
    
    <section id="refinement">
        <title>Refinement modifiers</title>
        
        <para>A declaration may not be annotated both <literal>formal</literal> 
        and <literal>default</literal>. <!--<literal>definite</literal>.--></para>
        
        <para>If a declaration is annotated <literal>formal</literal>, 
        <literal>default</literal>, <!--<literal>definite</literal>,--> or 
        <literal>actual</literal> then it must also be annotated 
        <literal>shared</literal>.</para>
        
    </section>
    
    <section id="visibility">
        <title>Visibility and name resolution</title>
        
        <para>Classes, interfaces, methods, attributes, locals, parameters and type 
        parameters have names. Occurrence of a name in code implies a hard dependency 
        from the code in which the name occurs to the schema of the named declaration. 
        We say that a class, interface, method, attribute, parameter or type parameter 
        is <emphasis>visible</emphasis> to a certain program element if its name may 
        occur in the code that defines that program element.</para>
                
        <para>The visibility of a declaration depends upon where it occurs, and upon 
        whether it is annotated <literal>shared</literal>. A toplevel or member 
        declaration may be annotated <literal>shared</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>If a toplevel declaration is annotated <literal>shared</literal>, 
                it is visible wherever the package that contains it is visible.
                Otherwise, a toplevel declaration is visible only to code in the 
                package containing its compilation unit.</para>
            </listitem>
            <listitem>
                <para>If a member declaration is annotated <literal>shared</literal>, 
                it is visible wherever the class or interface that contains it is 
                visible. Otherwise, a declaration that occurs directly inside a class 
                or interface body is visible only inside the class or interface 
                declaration.</para>
            </listitem>
        </itemizedlist>
        
        <para>A parameter, type parameter, or declaration that occurs directly inside
        a block (the body of a method, attribute getter or attribute setter) may not 
        be annotated <literal>shared</literal>.</para>
        
        <itemizedlist>
            <listitem>
                <para>A parameter or type parameter is visible only inside the 
                declaration to which it belongs.</para> 
            </listitem>
            <listitem>
                <para>A declaration that occurs directly inside a block is visible 
                only inside the block.</para>
            </listitem>
        </itemizedlist>
        
        <para>A declaration not annotated <literal>shared</literal> is called a 
        <emphasis>block local</emphasis> declaration.</para>
        
        <comment><para>TODO: Should we allow you to limit the effect of the 
        <literal>shared</literal> annotation by specifying a containing program 
        element or package? Program element is easy, since we already have a
        typesafe syntax for referring to a method or type: 
        <literal>shared(ContainingClass)</literal>. Package is a bit tricker.
        Of course we could use a single quoted literal, 
        <literal>shared('org.example.containing.package')</literal>, but perhaps 
        this would justify introducing a literal package name syntax:
        <literal>shared(:org:example:containing:package)</literal>.</para>
        </comment>
        
    </section>
        
    <section id="documentation">
        <title>Documentation</title>
    
        <para>The following annotations are instructions to the documentation
        compiler:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>doc</literal> specifies the description of a 
                program element.</para>
            </listitem>
            <listitem>
                <para><literal>by</literal> specifies the authors of a program 
                element.</para>
            </listitem>
            <listitem>
                <para><literal>see</literal> specifies a related member or 
                type.</para>
            </listitem>
            <listitem>
                <para><literal>throws</literal> specifies a thrown exception
                type.</para>
            </listitem>
        </itemizedlist>
        
        <para>The <literal>String</literal> arguments to the <literal>deprecated</literal>, 
        <literal>doc</literal>, <literal>throws</literal> and <literal>by</literal> 
        annotations are parsed by the documentation compiler as Seam Text, a 
        simple ANTLR-based wiki text format.</para>
        
        <para>These annotations are defined by the package <literal>doc</literal>:</para>
        
        <programlisting>shared class Description(String description)
        satisfies OptionalAnnotation&lt;Description,Annotated&gt; {
    shared String description = description;
}

shared Description doc(String description) {
    return Description(description.normalize());
}</programlisting>
    
        <programlisting>shared class Authors(String... names)
        satisfies OptionalAnnotation&lt;Authors,Annotated&gt; {
    shared String[] names = names;
}

shared Authors by(String... authors) {
    return Authors( from (String author in authors) select (author.normalize()) );
}</programlisting>
    
        <programlisting>shared class RelatedElement(Annotated programElement -> String description)
        satisfies SequencedAnnotation&lt;RelatedElement,Annotated&gt; {
    shared Annotated programElement = programElement;
    shared String description = description;
}

shared RelatedElement see(Annotated programElement -> String description) {
    return RelatedElement(programElement -> description.normalize());
}</programlisting>
    
        <programlisting>shared class RelatedElements(Annotated... programElements)
        satisfies OptionalAnnotation&lt;RelatedElements,Annotated&gt; {
    shared Annotated[] programElements = programElements;
}

shared RelatedElements seeAlso(Annotated... programElements) {
    return RelatedElements(programElements);
}</programlisting>
    
        <programlisting>shared class ThrownException(Type&lt;Exception&gt; type -> String description)
        satisfies SequencedAnnotation&lt;ThrownException,Annotated&gt; {
    shared Type&lt;Exception&gt; type = type;
    shared String description = description;
}

shared ThrownException throws(Type&lt;Exception&gt; type -> String description) {
    return ThrownException(type -> description.normalize());
}</programlisting>

        <programlisting>shared class ThrownExceptions(Type&lt;Exception&gt;... types)
        satisfies OptionalAnnotation&lt;ThrownExceptions,Annotated&gt; {
    shared Type&lt;Exception&gt;[] types = types;
}

shared ThrownExceptions throwsAlso(Type&lt;Exception&gt;... types) {
    return ThrownExceptions(types);
}</programlisting>
        
        <comment><para>TODO: Should the documentation annotations be erased by 
        the compiler? Perhaps there should be a compiler switch.</para></comment>
        
     </section>
        
     </section>

</chapter>