<chapter id="expressions">
    <title>Expressions</title>
    
    <para>Ceylon expressions are significantly more flexible than Java, allowing a 
    more declarative style of programming.</para>
    
    <para>Expressions are formed from:</para>
    
    <itemizedlist>
        <listitem>
            <para>literal values, self references, and metamodel references,</para>
        </listitem>
        <listitem>
            <para>callable references and anonymous functions,</para>
        </listitem>
        <listitem>
            <para>invocation of methods and instantiation of classes,</para> 
        </listitem>
        <listitem>
            <para>evaluation and assignment of attributes,</para>
        </listitem>
        <listitem>
            <para>comprehensions, and</para>
        </listitem>
        <!--listitem>
            <para>enumeration of sequences, and</para>
        </listitem-->
        <listitem>
            <para>operators.</para>
        </listitem>
    </itemizedlist>
    
    <para>Ceylon expressions are validated for typesafety at compile time. To 
    determine whether an expression is assignable to a program element such as 
    an attribute, local, or parameter, Ceylon considers the 
    <emphasis>type</emphasis> of the expression (the type of the objects that 
    are produced when the expression is evaluated). An expression is assignable 
    to a program element if the type of the expression is assignable to the 
    declared type of the program element.</para>
    
    <comment><para>TODO: We need a definition of a "constant expression".
    We might use it for:</para>
    <itemizedlist>
    <listitem><literal>case</literal> expressions (when are these evaluated?),</listitem>
    <listitem>annotations available at compile time,</listitem>
    <listitem>default parameter values (when are these evaluated?), and even</listitem>
    <listitem>initializer/specifier expressions in declaration section of class body.</listitem>
    </itemizedlist>
    <para>For example we could follow Java's very restrictive model, and say 
    that a constant expression must be anything formed from literals, metamodel 
    references, the <literal>..</literal> and <literal>-></literal> operators.
    Or we could be much less restrictive and just say that it is any expression 
    that could be used to initialize a toplevel attribute of the package.</para>
    <para>At the very least, we need to properly define the scope in which the 
    above things are actually evaluated.</para></comment>
    
    <comment><para>TODO: For user interfaces, some kind of support for pass by
    reference would be especially helpful.</para></comment>
    
    <section id="objectinstancesidentity">
        <title>Object instances, identity, and reference passing</title>
        
        <para>An <emphasis>object</emphasis> is a unique identifier, together with a 
        reference to a class, and a value for each simple attribute of the class 
        (including inherited simple attributes). The object is said to be an 
        <emphasis>instance</emphasis> of the class.</para>
        
        <para>A <emphasis>value</emphasis> is a reference to an object (a copy of its 
        unique identifier). At a particular point in the execution of the program, 
        every attribute of every object that exists, and every initialized local of 
        every method or initializer that is currently executing has a value. 
        Furthermore, every time an expression is executed, it produces a value.</para>
        
        <para>Two values are said to be <emphasis>identical</emphasis> if they are
        references to the same object&mdash;if they hold the same unique identifier. The 
        program may determine if two values of type <literal>IdentifiableObject</literal> 
        are identical using the <literal>&identical;</literal> operator. It may not 
        directly obtain the unique identifier (which is a purely abstract construct). The 
        program has no way of determining the identity of a value which is not of type 
        <literal>IdentifiableObject</literal>.</para>
        
        <para>Invocation of a method or class initializer results in execution of the 
        method with parameter values that are copies of the value produced by executing 
        the argument expressions of the invocation, and a reference to the receiving 
        instance that is a copy of the value produced by executing the receiver expression. 
        The value produced by the invocation expression is a copy of the value produced by 
        execution of the <literal>return</literal> directive expression.</para>
        
        <programlisting>Person myself(Person me) { return me; }
Person p = ...;
assert() that (myself(p)&identical;p); //assertion never fails</programlisting>

        <programlisting>Semaphore s = Semaphore();
this.semaphore = s;
assert() that (semaphore&identical;s); //assertion never fails</programlisting>
        
        <para>A new object is produced by execution of a class instantiation expression.
        The Ceylon compiler guarantees that if execution of a class initializer terminates
        with no uncaught exception, then every simple attribute of the object has been
        initialized. The value of an non-<literal>variable</literal> simple attribute or 
        local is initialized for the first time by execution of a specifier. Every class 
        instantiation expression results in an object with a new unique identifier shared 
        by no other existing object. The object exists from the point at which execution 
        of its initializer terminates. <emphasis>Conceptually</emphasis>, the object exists 
        until execution of the program terminates.</para>
        
        <para>In practice, the object exists at least until the point at which it is not 
        reachable by recursively following references from a local in a method or
        initializer currently being executed, or from an expression in a statement 
        currently being executed. At this point, its simple attribute values are no 
        longer accessible to expressions which subsequently execute and the object may 
        be destroyed by the virtual machine. There is no way for the program to determine
        that an object has been destroyed by the virtual machine (unlike Java, Ceylon
        does not provide object finalizers).</para>
        
        <para>As a special exception to the rules defined above:</para>
        
        <itemizedlist>
        <!--listitem>
            <para>The compiler is permitted to emit bytecode that unexpectedly creates or
            avoids creating an actual instance of <literal>Gettable</literal> or 
            <literal>Settable</literal>, when an expression is evaluated, as long as this 
            does not affect the observable behavior of the program.</para>
        </listitem-->
        <listitem>
            <para>The compiler is permitted to emit bytecode that produces a new instance of 
            certain types in the module <literal>ceylon.language</literal> without execution of 
            the initializer of the class, whenever any expression is evaluated. These types are:
            any of the the built-in numeric types, <!-- of <literal>Bits&lt;#n&gt;</literal>,
            <literal>Bounded&lt;#n&gt;</literal>,--> <literal>Character</literal>, 
            <literal>Range</literal>, <literal>Entry</literal>, and <literal>String</literal>. 
            Furthermore, it is permitted to use such a newly-produced instance as the value of 
            the expression, as long as the newly-produced instance is equal to the value expected 
            according to the rules above, as determined using the <literal>==</literal> operator.</para>
        </listitem>
        </itemizedlist>
        
        <para>Therefore, the types listed above directly extend <literal>Object</literal> or
        <literal>Void</literal> instead of <literal>IdentifiableObject</literal>.</para>
                
        <para>The execution of a Ceylon program complies with the rules laid out by the Java 
        programming language's execution model (Chapter 17 of the Java Language Specification).
        Ceylon attributes and locals are considered <emphasis>variables</emphasis> in the 
        sense of the JLS. Evaluation is considered a <emphasis>use</emphasis> operation, 
        and assignment is considered an <emphasis>assign</emphasis> operation, again in 
        terms of the JLS.</para>
        
    </section>
    
    <!--  
    <section id="lazyevaluation">
        <title>PROPOSAL: Lazy evaluation</title>
        
        <comment><para>NOTE: Lazy evaluation of expressions is a proposed feature for 
        a future version of the language.</para></comment>
        
        <para>Ceylon supports <emphasis>lazy evaluation</emphasis> of expressions.
        Conceptually, what triggers evaluation of an expression is not execution
        of the expression itself, but use of the expression in a context where its 
        value is required.</para>
        
        <para>The first statement of this code fragment causes immediate evaluation 
        of the expression <literal>calculatePi()</literal>:</para>
        
        <programlisting>Float pi = calculatePi();
Float area = pi * radius**2;</programlisting>
        
        <para>But in the following code, <literal>calculatePi()</literal> is not
        evaluated until the second statement:</para>
        
        <programlisting>Gettable&lt;Float&gt; pi = calculatePi();
Float area = pi * radius**2;</programlisting>
    
        <para>The type <literal>Gettable&lt;T&gt;</literal> represents a reference
        to a value of type <literal>T</literal> that can be computed if and when
        required.</para>
        
        <para>One application of lazy evaluation is <emphasis>pass by 
        reference</emphasis>. Even <literal>variable</literal> attributes may be 
        passed by reference, as in the following code:</para>
        
        <programlisting>void setGreeting(Settable&lt;String&gt; ref) {
    ref:="Que honda!";
}

shared variable String greeting := "'sup!";
setGreeting(greeting);</programlisting>
        
        <comment><para>TODO: Do we need to say the following:
        A <literal>Gettable</literal> object representing an expression that 
        contains a reference to a <literal>variable</literal> local may not be assigned 
        to an attribute, passed as a method argument, passed to a control directive, 
        or referred to by a nested method or class. It may be assigned to a local, or 
        invoked directly inside the block that obtained it.</para></comment>
    
    </section>
    -->
    
    <section id="literalvalues">
        <title>Literal values</title>
    
    <para>Ceylon supports literal values of the following types:</para>
    
    <itemizedlist>
        <listitem>
            <para><literal>Integer</literal> and <literal>Float</literal>,</para>
        </listitem>
        <listitem>
            <para><literal>Character</literal>, and</para>
        </listitem>
        <listitem>
            <para><literal>String</literal>, along with</para>
        </listitem>
        <listitem>
            <para>single quoted literals.</para>
        </listitem>
    </itemizedlist>
    
    <para>The types <literal>Integer</literal>, <literal>Float</literal>, 
    <literal>Character</literal>, and <literal>String</literal> are defined in the 
    module <literal>ceylon.language</literal>.</para>
    
    <para>Ceylon does not need a special syntax for <literal>Boolean</literal> literal 
    values, since <literal>Boolean</literal> is just a class with the cases 
    <literal>true</literal> and <literal>false</literal>. Likewise, <literal>null</literal> 
    is just the singleton value of an anonymous class.</para>
    
    <programlisting>Literal: IntegerLiteral | FloatLiteral | CharacterLiteral | StringLiteral | QuotedLiteral</programlisting>
    
    <para>All literal values are instances of immutable types. The value of a literal 
    expression is an instance of the type. How this instance is produced is not specified 
    here.</para>
    
    <!--section id="datetime">
        <title><literal>Date</literal> and <literal>Time</literal> literals</title>
        
        <para>A <literal>Date</literal> literal has the form:</para>
        
        <programlisting>DateLiteral: 
"'" 
Digit{1,2} "/" Digit{1,2} "/" Digit{4} 
"'"</programlisting>
        
        <para>A <literal>Time</literal> literal has the form:</para>
        
        <programlisting>TimeLiteral: 
"'" 
Digit{1,2} ":" Digit{2} ( ":" Digit{2} ( ":" Digit{3} )? )? 
(" " "AM"|"PM")? 
(" " Character{3,4})? 
"'"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Date date = '25/03/2005';</programlisting>
        <programlisting>Time time = '12:00 AM PST';</programlisting>
        
        <para>A <literal>Datetime</literal> may be composed from a <literal>Date</literal> and 
        a <literal>Time</literal> using the <literal>@</literal> operator.</para>
        
        <programlisting>Datetime datetime = '25/03/2005' @ '12:00 AM PST';</programlisting>
        
        <comment><para>TODO: alternatively, we could follow RFC3339-style datetimes, for example:
        <literal>1996-12-19T16:39:57-08:00</literal>.</para></comment>
        
        <comment><para>TODO: should we allow wildcards and ranges, to get cron-style expressions 
        like <literal>'1/*/*' @ '00:00 GMT'</literal>?</para></comment>
        
        <para>The <literal>..</literal> operator lets us construct intervals:</para>
        
        <programlisting>Interval&lt;Date&gt; timeRange = '0:0:00' .. '12:59:59 PM';</programlisting>
        <programlisting>Interval&lt;Date&gt; dateRange = '1/1/2008' .. '31/12/2007';</programlisting>
        <programlisting>Interval&lt;Datetime&gt; datetimeRange = '1/1/2008' @ '0:0:00' .. '31/12/2007' @ '12:59:59 PM';</programlisting>
        
    </section-->
    
        <!--
        
        <para>The attributes <literal>hours</literal>, <literal>minutes</literal>, <literal>seconds</literal>,
        <literal>years</literal>, <literal>months</literal>, <literal>days</literal>, <literal>weeks</literal>
        of the <literal>Integer</literal> class let us construct durations.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 12.hours + 34.minutes;</programlisting>
        <programlisting>Duration&lt;Date&gt; duration = 1.year + 2.months + 3.days;</programlisting>
        
        <para>Durations may be composed using the arithmetic operators <literal>+</literal>, 
        <literal>-</literal>, <literal>*</literal> and <literal>/</literal>.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 1.seconds / 10 - 1.seconds / 1000;</programlisting> 
        
        <para>The methods <literal>before()</literal> and <literal>after()</literal> let us add and
        subtract durations to and from datetimes.</para>
        
        <programlisting>Time time = 10.seconds.before('12:00 AM');</programlisting>
        <programlisting>Date date = 1.week.after('2/9/1974');</programlisting>
        
        -->
        
    <section id="naturalnumber">
        <title>Integer number literals</title>
        
        <para>An integer literal <literal>n</literal> is an 
        expression of type <literal>Integer</literal>.</para>
        
        <programlisting>Integer five = 5;</programlisting>
                
    </section>
    
    <section id="floatnumber">
        <title>Floating point number literals</title>
        
        <para>A floating point literal is an expression of 
        type <literal>Float</literal>.</para>
        
        <programlisting>shared Float pi = 3.14159;</programlisting>
        
        <comment><para>TODO: Actually, this is not the best definition,
        since if we assign the literal to <literal>Decimal</literal>,
        we don't want it to go through an intermediate conversion to
        floating point representation.</para></comment>
        
    </section>
    
    <section id="character">
        <title>Character literals</title>
        
        <para>A single character literal is an expression of type 
        <literal>Character</literal>.</para>
                
        <programlisting>if ( string[i] &equals; `+` ) { ... }</programlisting>
        
        <comment><para>TODO: do we really need character literals?</para></comment>
        
    </section>
    
    <section id="string">
        <title>Character string literals</title>
        
        <para>A character string literal is an expression of type
        <literal>String</literal>.</para>
        
        <programlisting>person.name := "Gavin King";</programlisting>
        
        <programlisting>String multiline = "Strings may
span multiple lines
if you prefer.";</programlisting>

        <programlisting>display("Melbourne\tVic\tAustralia\nAtlanta\tGA\tUSA\nGuanajuato\tGto\tMexico\n");</programlisting>
                
    </section>
    
    <section id="quoted">
        <title>Single quoted literals</title>
        
        <para>Single-quoted strings are used to express literal values for dates, 
        times, regexes and hexadecimal numbers, and even for more domain-specific 
        things like names, cron expressions, internet addresses, and phone numbers.
        This is an important facility since Ceylon is a language for expressing 
        structured data.</para>
        
        <!--
        <para>A single quoted literal must be combined with an explicit type 
        annotation to form an expression.</para>
        
        <programlisting>TypedQuotedLiteral: TypeName QuotedLiteral</programlisting>
        
        <para>The type of the expression is the specified type.</para>
                
        <programlisting>Date date = Date '25/03/2005';</programlisting>
        <programlisting>Time time = Time '12:00 AM PST';</programlisting>
        <programlisting>Boolean isEmail = Regex '^\w+@((\w+)\.)+$'.matches(email);</programlisting>
        <programlisting>Cron schedule = Cron '0 0 23 ? * MON-FRI';</programlisting>
        <programlisting>Color color = Color 'FF3B66';</programlisting>
        <programlisting>Url url = Url 'http://jboss.org/ceylon';</programlisting>
        <programlisting>mail.to := Email 'gavin@hibernate.org';</programlisting>
        <programlisting>Phone ph = Phone '+1 (404) 129 3456';</programlisting>
        <programlisting>Duration duration = Duration '1h 30m';</programlisting>
        -->
        
        <programlisting>Regex regex = '^\w+@((\w+)\.)+$';</programlisting>
        <programlisting>ph = '+1 (404) 129 3456';</programlisting>
        <programlisting>Duration duration = '1h 30m';</programlisting>
        <programlisting>Datetime dt = Datetime('25/03/2005', '12:00 AM PST');</programlisting>
        <programlisting>Timer { schedule = '0 0 23 ? * MON-FRI'; onTimeout=purge; }.start();</programlisting>
        <programlisting>Text { color = 'FF3B66'; "Hello World!" }</programlisting>
        <programlisting>Link { url = 'http://jboss.org/ceylon'; "Powered by Ceylon" }</programlisting>
        <programlisting>Email { to = 'gavin@hibernate.org'; subject="Ceylon"; text = "Need some help with the compiler?"; }</programlisting>
        
        <para>A single quoted literal may only appear in the following positions:</para>
        
        <itemizedlist>
            <listitem>
                <para>as the right hand side of a specifier for a local or
                attribute with an explicitly declared type, or</para>
            </listitem>
            <listitem>
                <para>as an argument of an invocation or instantiation.</para>
            </listitem>
        </itemizedlist>
        
        <para>In either case:</para>
        
        <itemizedlist>
            <listitem>
                <para>the declared type of the local, attribute, or parameter 
                must be a class or interface annotated <literal>literal</literal>,
                and</para>
            </listitem>
            <listitem>
                <para>the single quoted literal must match the pattern specified
                by the <literal>format</literal> argument of the 
                <literal>literal</literal> annotation.</para>
            </listitem>
        </itemizedlist>
        
        <para>The type of the literal expression is the declared type of the
        local, attribute, or parameter. At runtime, an instance of this type
        is produced by calling the method specified by the <literal>parser</literal>
        argument of the <literal>literal</literal> annotation.</para>
        
        <programlisting>Color parseColor(String literal) { ... }

literal { 
    format = '[0-9A-F]{6}|red|blue|green|yellow|black|white'; 
    parser = parseColor;
}
shared interface Color { ... }</programlisting>
        
        <comment><para>TODO: Single quoted operator literals should come built-in.
        For example: <literal>'+'</literal> and <literal>'&lt;='</literal>.</para></comment>
        
        <comment><para>TODO: we should try to support interpolated expressions, 
        just like we do for string literals.</para></comment>
        
    </section>

    </section>

    <section id="stringtemplates">
        <title>String templates</title>
        
        <para>A character string <emphasis>template</emphasis> contains interpolated 
        expressions, surrounded by character string fragments.</para>
        
        <programlisting>StringTemplate: StringLiteral (Expression StringLiteral)+</programlisting>
        
        <para>An interpolated expression may not begin with a string literal or the 
        unary prefix <literal>+</literal> operator.</para>
        
        <para>Each interpolated expression contained in the string template must have 
        a type assignable to <literal>Object</literal> defined in 
        <literal>ceylon.language</literal>.</para>
        
        <!--
        <para>The entire character string template is an expression of type 
        <literal>Gettable&lt;String&gt;</literal>.</para>
        -->
        
        <programlisting>log.info("Hello, " person.firstName " " person.lastName ", the time is " Time() ".");</programlisting>
        
        <programlisting>log.info("1 + 1 = " 1 + 1 "");</programlisting>
        
        <para>An interpolated expression in a string template may invoke or evaluate:</para>
        
        <itemizedlist>
            <listitem>
                <para>any class member that is visible to the containing scope in 
                which the literal appears, and</para>
            </listitem>
            <listitem>
                <para>any non-<literal>variable</literal> local, block local attribute 
                getter or block local method declared earlier within the containing 
                scope.</para>
            </listitem>
        </itemizedlist>
        
        <!-- 
        <para>Interpolated expressions are evaluated when the 
        <literal>Gettable&lt;String&gt;</literal> is evaluated to produce a constant 
        character string.</para>
        -->
        
        <comment><para>TODO: Should string templates be evaluated lazily?</para></comment>
        
    </section>
    
    <section id="selfreferences">
        <title>Self references</title>
        
        <para>The type of the following expressions depends upon the context in which 
        they appear.</para>
        
        <programlisting>SelfReference: "this" | "super" | "outer"</programlisting>
        
        <section>
            <title><literal>super</literal></title>
            
        <para>The keyword <literal>super</literal> refers to the current instance 
        (the instance that is being invoked), and has the same members as the 
        immediate superclass of the class, except for <literal>formal</literal> 
        <!-- and <literal>definite</literal>--> 
        members. Any invocation of this reference is processed by the method or 
        attribute defined or inherited by the superclass, bypassing any method 
        declaration that refines the method on the current class or any subclass 
        of the current class. The <literal>super</literal> reference is not assignable 
        to any type. Nor may not be narrowed to any type using <literal>if (is ...)</literal>.
        There is no <literal>super</literal> reference in an interface member body. 
        <!--<emphasis>(Note that <literal>definite</literal> is a proposed 
        feature for a future version of the language.)</emphasis>--></para>
        
        <comment><para>TODO: <literal>super</literal> doesn't let you call a refined
        member belonging to an interface. A solution would be to let you rename 
        the refined member in an <literal>import</literal> statement. Another
        possibility would be to introduce a specialized syntax, for example something
        like <literal>super(Writer).write(string)</literal>.</para></comment>
        
    </section>
        
    <section>
        <title><literal>this</literal></title>
            
        <para>The keyword <literal>this</literal> refers to the current instance, 
        and is assignable to the type of the current class or interface (the class 
        or interface in which the expression appears).<!--, and to the special 
        type <literal>subtype</literal>, which represents the concrete type of the 
        current instance.--></para>
        
        </section>
        
        <section>
            <title><literal>outer</literal></title>
            
        <para>The keyword <literal>outer</literal> refers to the current instance
        of the class or interface which immediately contains the current class or 
        interface and is assignable to the type of this containing class or 
        interface.</para>
        
        </section>
                
    </section>
    
    <section id="compoundexpressions">
        <title>Compound expressions</title>

        <para>An <emphasis>atom</emphasis> is a literal or self reference, an 
        enumeration expression, or a parenthesized expression.</para>
    
        <programlisting>Atom: Literal | StringTemplate | SelfReference | ParExpression</programlisting>
    
        <para>A <emphasis>primary</emphasis> is formed by recursively invoking or 
        evaluating members of an atom, toplevel method, toplevel attribute, or
        class.</para>
    
        <programlisting>Primary: Atom | Meta | MemberReference | Invocation</programlisting>

        <programlisting>MemberReference: CallableReference | ValueReference</programlisting>
    
        <para>More complex expressions are formed by combining expressions using 
        operators, including assignment operators.</para>    
    
        <programlisting>Expression: Primary | OperatorExpression</programlisting>
    
        <para>Parentheses are used for grouping:</para>
    
        <programlisting>ParExpression: "(" Expression ")"</programlisting>
    
    <section id="receiverexpressions">
        <title>Receiver expressions</title>
        
        <para>A callable reference or value reference may specify a <emphasis>receiver 
        expression</emphasis>. The receiver expression produces the instance upon which 
        a member is invoked or evaluated. The type of the receiver expression must have 
        a member with the specified name.</para>
        
        <programlisting>Receiver: Primary</programlisting>
        
        <para>A receiver expression must be explicitly specified, unless:</para>
        
        <itemizedlist>
            <listitem>
                <para>the reference is to a toplevel method, toplevel attribute, 
                or class,</para>
            </listitem>
            <listitem>
                <para>the reference is to a local or parameter, or</para>
            </listitem>
            <listitem>
                <para>the current instance of a containing class is the receiver.</para>
            </listitem>
        </itemizedlist>
        
        <para>When a callable reference with a receiver expression is executed, the 
        receiver expresson is evaluated and a reference to the resulting value is 
        held as part of the callable reference. When a value reference with a 
        receiver expression is executed, the receiver expression is evaluated and a 
        reference to the resulting value is held as part of the value reference.</para>
        
        <!--
        <para>An outer instance reference may also specify a receiver expression. The
        receiver expression must be explicitly specified unless the current instance
        of the current class is the receiver.</para>
        -->
        
    </section>
        
    </section>
    
    <!--
    <section id="outerinstancereferences">
        <title>Outer instance references</title>
        
        <para>For a nested class, the containing instance may be obtained using
        the keyword <literal>outer</literal>.</para>
        
        <programlisting>OuterReference: (Receiver ".")? "outer"</programlisting>
        
        <para>The type of the outer instance reference is the type that contains 
        the declaration of the receiver expression type (which must be a nested 
        class). If no receiver expression is specified, the type of the outer 
        instance reference is the type that contains the declaration of the 
        current class (the class in which the expression appears, which must be 
        a nested class).</para>
        
        <programlisting>Node node = tree.Node().Node();
assert() that (tree &equals; node.outer.outer);</programlisting>

        <programlisting>class Catalog() {
    class Schema() {
        Catalog catalog { return outer; }
        class Table() {
            Schema schema { return outer; }
            Catalog catalog { return outer.outer; }
        }
    }
}</programlisting>
        
    </section>
    -->
    
        <section id="anonymousfunctions">
            <title>Anonymous functions</title>
            
            <para>An anonyomous function declaration may occur in a positional argument 
            list, <literal>return</literal> directive, or specifier. An anonymous
            function defines a method with no method name. It comprises one or more
            parameter lists, followed by an expression.</para>
            
            <programlisting>Function: ("function" | "void")? Params+ Expression</programlisting>
            
            <para>The parameters are the parameters of the method. The expression is 
            the return value of the method, and the type of the expression is the 
            return type of the method, unless the method is explicitly declared using 
            the <literal>void</literal> keyword.</para>
            
            <para>An anonymous function declaration is treated as an expression. The
            type of the expression is the callable byte of the method.</para>
            
            <para>For example:</para>
            
            <programlisting>() say("Hello")</programlisting>
                    
            <programlisting>(Value x, Value y) x&lt;=&gt;y</programlisting>

            <programlisting>void (String name) print(name)</programlisting>
        
        </section>
        
    <section id="valuereferences">
        <title>Value references</title>
                
        <para>A <emphasis>value reference</emphasis> is a reference to  something&mdash;for 
        example, an attribute, a local, or an invocation expression&mdash;that can be 
        <emphasis>evaluated</emphasis>.</para>

        <!--para>A value reference may be transparently converted to the actual current 
        value of the attribute or local, or to the return value of the invocation, or 
        it may be passed, as a reference, to other code, which may use the reference to 
        <emphasis>evaluate</emphasis> the current value of the attribute or local, or
        to perform the invocation. A reference to a <literal>variable</literal> attribute 
        or local may be used to <emphasis>assign</emphasis> a new value to the attribute 
        or local.</para-->
        
        <para>A value reference expression is assignable to <!--<literal>Gettable&lt;T&gt;</literal> 
        or <literal>Settable&lt;T&gt;</literal> where <literal>T</literal>--> the type 
        of the attribute or local, or the return type of the invocation expression.</para>
        
        <section id="attributeandlocalreferences">
            <title>Attribute and local references</title>
        
        <para>An <emphasis>attribute reference</emphasis> is a reference to an attribute
        of some object. A <emphasis>local reference</emphasis> is a reference to a 
        local or parameter. An attribute reference specifies the name of the attribute. 
        A local reference specifies the name of the local or parameter.</para>
        
        <programlisting>ValueReference: (Receiver ".")? MemberName</programlisting>
        
        <para>The type of an attribute reference or local reference expression for an 
        attribute, local, or parameter of declared type <literal>X</literal> is simply
        <literal>X</literal>.</para>
        
        <!--
        <itemizedlist>
            <listitem>
                <para><literal>X</literal>, if <literal>X</literal> is assignable
                to <literal>Gettable&lt;Object&gt;</literal>, or, otherwise,</para>
            </listitem>
            <listitem>
                <para><literal>Gettable&lt;X&gt;</literal>, if the attribute, local, 
                or parameter is not <literal>variable</literal>, or if the setter is 
                not visible to the block containing the attribute or local reference, 
                or</para>
            </listitem>
            <listitem>
                <para><literal>Settable&lt;X&gt;</literal>, if the attribute, local, 
                or parameter is <literal>variable</literal> and the setter, if any, 
                is visible to the block containing the attribute or local 
                reference.</para>
            </listitem>
        </itemizedlist>
        -->
        
        </section>
        
        <!--section id="passbyreference">
            <title>PROPOSAL: Pass by reference</title>
            
            <comment><para>NOTE: Lazy evaluation and pass by reference is a proposed feature for 
            a future version of the language.</para></comment>
        
            <para>An expression of type <literal>Gettable</literal> or <literal>Settable</literal> 
            may be assigned to an attribute or local, passed as an argument to a method or initializer, 
            or returned by a method. If the attribute, local, or parameter to which the expression is 
            assigned is of declared type <literal>Gettable</literal> or <literal>Settable</literal>, 
            or if the method which returns the expression is of declared type <literal>Gettable</literal> 
            or <literal>Settable</literal>, this is called <emphasis>pass by reference</emphasis>, 
            since it does not result in immediate evaluation of the referenced value. Instead, the 
            attribute, local, or parameter holds a <emphasis>reference</emphasis> to the value of some 
            other attribute, local, or parameter.</para>
            
            <para>This local holds a reference:</para>
            
            <programlisting>Gettable&lt;String&gt; nameRef = person.name;</programlisting>
            
            <para>This method returns a reference:</para>
            
            <programlisting>Settable&lt;String&gt; getName(Person p) { return p.name; }</programlisting>
            
            <para>This class has an initialization parameter which accepts a reference:</para>
            
            <programlisting>class Input(Settable&lt;String&gt; model) { ... }</programlisting>
            
            <para>This attribute holds a reference to an invocation expression:</para>
            
            <programlisting>shared Gettable&lt;Decimal&gt; total = order.calculateTotal();</programlisting>
            
            <para>An attribute or local of type <literal>Gettable</literal> or <literal>Settable</literal> 
            may not be declared <literal>variable</literal>.</para>
            
        </section-->
        
    </section>

    <section id="callablereferences">
        <title>Callable references</title>
        
        <para>A <emphasis>callable reference</emphasis> is a reference to 
        something&mdash;a method, callable parameter, or class&mdash;that can be 
        <emphasis>invoked</emphasis> by specifying a list of arguments.</para>
        
        <programlisting>CallableReference: MethodReference | InitializerReference</programlisting>
        
        <para>A callable reference may be invoked immediately, or it may be passed 
        to other code which may invoke the reference. A callable reference captures 
        the return type and parameter lists of the method, callable parameter, or 
        class it refers to, allowing compile-time validation of argument types when 
        the callable reference is invoked.</para>
        
        <para>A callable reference expression is assignable to 
        <literal>Callable&lt;T,P...&gt;</literal> where <literal>T</literal> and 
        <literal>P...</literal> depend upon the schema of the method or class.</para>
        
        <!--comment><para>TODO: we can support LINQ to SQL-like queries by making 
        <literal>Callable</literal> provide an AST of the statements contained
        in the method declaration, allowing translation to SQL.</para></comment-->
                
        <section id="typearguments">
            <title>Type arguments</title>
            
            <para>If a callable reference expression refers to a generic declaration, 
            either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>it must be immediately followed by an argument list, 
                    allowing the compiler to infer the type arguments, or</para>
                </listitem>
                <listitem>
                    <para>it must specify an explicit type argument list.</para>
                </listitem>
            </itemizedlist>
            
        </section>
        
        <section id="methodreferences">
            <title>Method references</title>
        
        <para>If a callable reference specifies a method name (or callable parameter 
        name), it is called a <emphasis>method reference</emphasis>.</para>

        <programlisting>MethodReference: (Receiver ".")? MemberName TypeArguments?</programlisting>        

        <para>The type of a method reference expression is assignable to the callable 
        type of <!--every overloaded version of--> the method. Calling the method 
        reference results in execution of the method.</para>
        
        </section>

        <section id="initializerreferences">
            <title>Initializer references</title>
        
        <para>If a callable reference specifies a class name, it is called an 
        <emphasis>initializer reference</emphasis>.</para>
        
        <programlisting>InitializerReference: (Receiver ".")? TypeName TypeArguments?</programlisting>
        
        <para>The type of an initializer reference expression is assignable to the 
        callable type of <!-- every overloaded version of--> the class. Calling the 
        initializer reference results in instantiation of the class.</para>
        
        </section>
        
        <!--
        <section>
            <title>Method reference typing</title>
        
        <para>Method references do not, strictly speaking, have types. However, the schema
        of a method reference determines if it can appear to the right of the <literal>=</literal>
        specifier in a method declaration, or as an argument to a functional parameter. In this
        case we say the method reference <emphasis>conforms</emphasis> to the schema of the
        method or functional parameter.</para>

        <para>A method reference schema <emphasis>conforms</emphasis> to a method or functional 
        parameter schema if:</para>
        
        <itemizedlist>
            <listitem>
                <para>the return type of the method reference is assignable to the declared
                return type of the method or functional parameter, and</para>
            </listitem>
            <listitem>
                <para> the method reference has exactly the same number of parameters, 
                with the same types, as the method or functional parameter.</para>
            </listitem>
        </itemizedlist>
        
        <para>Thus, method schemas are covariant in return type, and invariant in parameter 
        types.</para>
        
        <para>The schema also restricts the the argument list that can be specified when the
        method reference is invoked.</para>
        
        <para>Additionally, method references are assignable to <literal>Callable&lt;X&gt;</literal>
        where <literal>X</literal> is the return type. Note that <literal>Callable</literal>
        does not capture parameter types, and so references of type 
        <literal>Callable&lt;X&gt;</literal> are therefore not method references.</para>
        
        <comment><para>TODO: could we make method references contravariant in the parameter
        types? If so, we should use the same rule for refining.</para></comment>
        
        <comment><para>TODO: does a method schema with a defaulted parameter conform to a method 
        schema without that parameter?</para></comment>
        
        </section>
         -->
         
        <section id="callableobjectsasmethodimplementations">
            <title>Callable objects as method implementations</title>
            
        <para>An expression of type <literal>Callable</literal> may be used to define a 
        method using <literal>=</literal>. The expression type must be assignable to the 
        callable type of the method being defined.</para>
        
        <programlisting>Comparison order&lt;Value&gt;(Value x, Value y) = reverse;</programlisting>
        
        <programlisting>void display(String message) = log.info;</programlisting>
        
        <programlisting>String newString(Character... chars) = String;</programlisting>
        
        <programlisting>String name(Person p) = Person.name;</programlisting>
        
        <programlisting>void print&lt;Printable&gt;(Printable printable) given Printable of String | Integer | Float = printer.print;</programlisting>
        <programlisting>void printStr(String string) = printer.print&lt;String&gt;;</programlisting>
        
        </section>
        
        <section id="callableobjectsascallableparameterarguments">
            <title>Callable objects as callable parameter arguments</title>
            
        <para>An expression of type <literal>Callable</literal> may appear as an argument 
        to a callable parameter, either as a positional argument, or as an argument 
        specified using <literal>=</literal> in a named argument invocation. The expression 
        type must be assignable to the callable type of the callable parameter.</para>
        
        <para>This method has a callable parameter:</para>
        
        <programlisting>void sort(List&lt;String&gt; list, Comparison by(String x, String y)) { ... }</programlisting>

        <para>This code passes a reference to a local method to the method.</para>
        
        <programlisting>Comparison reverseAlpha(String x, String y) { return y&lt;=&gt;x; }
sort(names, reverseAlpha);</programlisting>
        
        <para>This class has two callable parameters:</para>
        
        <programlisting>shared class TextInput(Integer size=30, String onInit(), String onUpdate(String s)) { ... }</programlisting>
 
        <para>This code instantiates the class, passing references to methods which set and
        get the attribute <literal>person.name</literal>:</para>
        
        <programlisting>TextInput input { 
    size=15; 
    onInit = set(person.name);
    onUpdate = get(person.name);
}</programlisting>
        
        </section>
        
        <section id="callableobjectsasmethodreturnvalues">
            <title>Callable objects as method return values</title>
        
        <!--  
        <para>An expression of type <literal>Callable</literal> may be returned by a method 
        with multiple parameter lists. The expression must be assignable to the callable 
        type of a method formed by eliminating the first parameter list of the method.</para>
        
        <programlisting>Comparison getOrder(Boolean reverse=false)(Integer x, Integer y) {
    if (reverse) {
        Comparison reverse(Integer x, Integer y) { return y&lt;=&gt;x; }
        return reverse;
    }
    else {
        Comparison natural(Integer x, Integer y) { return x&lt;=&gt;y; }
        return natural;
    }
}</programlisting>

        <para>This is slightly simpler using type inference:</para>

        <programlisting>Comparison getOrder(Boolean reverse=false)(Integer x, Integer y) {
    if (reverse) {
        function reverse(Integer x, Integer y) { return y&lt;=&gt;x; }
        return reverse;
    }
    else {
        function natural(Integer x, Integer y) { return x&lt;=&gt;y; }
        return natural;
    }
}</programlisting>
        -->
        
        <para>Calling a method with multiple parameter lists is called <emphasis>partial 
        application</emphasis> of the method.</para>
        
        <programlisting>Comparison order(Integer x, Integer y) = getOrder();
Comparison comp = order(1,-1);</programlisting>

        <para>This is even simpler using type inference:</para>

        <programlisting>function order(Integer x, Integer y) = getOrder();
value comp = order(1,-1);</programlisting>

        <para>Or, if we don't need parameter names, we don't even need to explicitly declare the 
        parameter list:</para>

        <programlisting>value order = getOrder();
value comp = order(1,-1);</programlisting>

        <para>In this case, <literal>order</literal> is actually not a method at all&mdash;it's
        just a local of type <literal>Callable&lt;Comparison,Integer,Integer&gt;</literal>.</para>

        <para>Of course, more than one argument list may be specified in a single expression:</para>
        
        <programlisting>Comparison comp = getOrder(true)(10, 100);</programlisting>
        
        </section>
        
    </section>
    
    <section id="invocationexpressions">
        <title>Invocation expressions</title>
        
        <para>A callable object&mdash;any instance of <literal>Callable</literal>&mdash;is 
        <emphasis>invokable</emphasis>. An <emphasis>invocation</emphasis> consists of an 
        <emphasis>invoked expression</emphasis> of type <literal>Callable&lt;T,P...&gt;</literal>, 
        together with an argument list and, optionally, an explicit type argument list.</para>
        
        <programlisting>Invocation: Primary Arguments | SequenceInstantiation</programlisting>
            
        <para>Any invocation expression where the invoked expression is a callable reference 
        expression is called a <emphasis>direct invocation expression</emphasis> of the 
        method, callable parameter, or class. In the case of a direct invocation expression, 
        the compiler has additional information about the schema of the method or class that 
        is not reified by the <literal>Callable</literal> interface. The compiler is aware 
        of:</para>
        
        <itemizedlist>
            <!--
            <listitem>
                <para>all the overloaded versions of the method or class (the various
                <literal>Callable</literal> types to which the callable reference
                expression is assignable),</para>
            </listitem>
            -->
            <listitem>
                <para>the names of the parameters of the method or class,</para>
            </listitem>
            <listitem>
                <para>which parameters are defaulted, and their default values, and</para>
            </listitem>
            <listitem>
                <para>whether the last parameter in the list is a sequenced parameter.</para>
            </listitem>
        </itemizedlist>
        
        <para>(Furthermore, in the case of a direct invocation expression, type argument 
        inference is possible, since the compiler is aware of the type parameters and 
        constraints of the method or class.)</para>
        
        <para>An invocation expression must specify arguments for parameters of the callable 
        object, either by listing parameter values in order or, in the case of a direct 
        invocation, listing named parameter values.</para>
        
        <programlisting>Arguments: PositionalArguments FunctionalArguments? | NamedArguments</programlisting>
        
        <para>Arguments to required parameters must be specified.</para>
        
        <itemizedlist>
            <listitem>
                <para>If the invocation expression is a direct invocation expression, 
                arguments to defaulted parameters may optionally be specified, and one or 
                more arguments to a sequenced parameter may optionally be specified.</para>
            </listitem>
            <listitem>
                <para>Otherwise, an argument must be specified for each defaulted parameter, 
                and a single argument must be specified for the sequenced parameter.</para>
            </listitem>
        </itemizedlist>
        
        <para>For a required or defaulted parameter of type <literal>T</literal>, the type 
        of the corresponding argument expression must be assignable to <literal>T</literal>.</para>
        
        <para>If the invocation expression is a direct invocation expression, then for a 
        sequenced parameter of type <literal>T...</literal>, there may be either:</para>
        
        <itemizedlist>
            <listitem>
                <para>an arbitrary number of argument expressions of type assignable to 
                <literal>T</literal>, or</para>
            </listitem>
            <listitem>
                <para>a single argument expression of type assignable to 
                <literal>T[]</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Otherwise, if the invocation is not a direct invocation expression, then a
        sequenced parameter of type <literal>T...</literal> is treated like an ordinary 
        required parameter and an argument to the sequenced parameter is always a single
        expression of type assignable to <literal>T[]</literal>.</para>
        
        <comment><para>TODO: Alternatively, we could have a special type that represents a
        sequenced parameter, allowing the usual invocation semantics even when it's not a
        direct invocation expression. <literal>String...</literal> would be an abbreviation 
        for <literal>SequencedArgument&lt;String&gt;</literal> and <literal>names...</literal>
        would be an abbreviation for <literal>SequencedArgument(names)</literal>.</para></comment>
        
        <para>For a tuple parameter of psuedo-type <literal>P...</literal>, the type of the 
        corresponding argument expression must be <literal>P...</literal>. (That is, it
        must be a tuple parameter of declared type <literal>P...</literal>.)</para>
        
        <!--    
        <itemizedlist>
            <listitem>
                <para><literal>R</literal>, if <literal>R</literal> is assignable
                to <literal>Gettable&lt;Object&gt;</literal>, or, otherwise,</para>
            </listitem>
            <listitem>
                <para><literal>Gettable&lt;R&gt;</literal></para>
            </listitem>
        </itemizedlist>
         -->
        <para>The type of an invocation expression is simply <literal>R</literal>
        where <literal>R</literal> is the type argument to the first type parameter 
        of the expression type <literal>Callable</literal> (the return type).</para>
        
        <section id="methodinvocation">
            <title>Method invocation</title>
            
            <para>For a method invocation, the invocation expression is of type <literal>R</literal>
            <!--literal>Gettable&lt;R&gt;</literal--> where <literal>R</literal> is the return 
            type of the method. The type of a <literal>void</literal> method invocation 
            expression is <literal>Void</literal>. <!--literal>Gettable&lt;Void&gt;</literal--></para>
            
            <programlisting>log.info("Hello world!")</programlisting>
            <programlisting>log.info { message = "Hello world!"; }</programlisting>
            <programlisting>printer.print { join = ", "; "Gavin", "Emmanuel", "Max", "Steve" }</programlisting>
            <!--programlisting>printer.print { "Names: ", from (Person p in people) select (p.name) }</programlisting-->
            <programlisting>hash(default, firstName, initial, lastName)</programlisting>
            <programlisting>hash { algorithm=default; firstName, initial, lastName }</programlisting>

            <!-- 
            <programlisting>set(person.name)("Gavin")</programlisting>
            <programlisting>get(process.arguments)()</programlisting>
            
            <programlisting>amounts.sort() by (Float x, Float y) (x&lt;=&gt;y)</programlisting>
            <programlisting>people.each() perform (Person p) { log.info(p.name); }</programlisting>
            <programlisting>map.filter() by (String key->String item) (item nonempty)</programlisting>
                        
            <programlisting>from (people) where (Person p) (p.age>18) select (Person p) (p.name)</programlisting>
            <programlisting>iterate (map) 
    perform (String name->Object item) { 
        log.info("Entry: " name "->" item ""); 
    };</programlisting>
             -->
    
            <programlisting>perform {
    as = subject;
    void action() {
        exec("java Hello");
    }
}</programlisting>

            <programlisting>check {
    FilePermission {
        path = "/usr/bin";
        action = read | execute;
    }
}</programlisting>
             
        </section>
        
        <section id="classinstantiation">
            <title>Class instantiation</title>
            
            <para>Invocation of an initializer reference is called <emphasis>instantiation</emphasis> 
            of the class. For a class instantation, the invocation expression is of type <literal>T</literal>
            <!--literal>Gettable&lt;T&gt;</literal--> where <literal>T</literal> is the class.</para>
            
            <programlisting>HashMap&lt;String, Person&gt;(entries)</programlisting>
            <programlisting>Point { x=1.1; y=-2.3; }</programlisting>
            <programlisting>ArrayList&lt;String&gt; { capacity=10; "gavin", "max", "emmanuel", "steve", "christian" }</programlisting>
            <programlisting>input.Tokens()</programlisting>
            
        </section>
        
        <section id="sequenceinstantiation">
            <title>Sequence instantiation</title>
            
            <para>An instantiation expression for the type <literal>Sequence</literal> may
            be written in an abbreviated form where the type name is eliminated.</para>
        
            <programlisting>SequenceInstantiation: "{" Sequence? "}"</programlisting>
            
            <para>The following expression:</para>
            
            <programlisting>{ "hello", "world" }</programlisting>
            
            <para>Is equivalent to:</para>
            
            <programlisting>Sequence { "hello", "world" }</programlisting>
            
            <para>The type of a sequence instantiation expression is:</para>
            
            <itemizedlist>
                <listitem>
                    <literal>Empty</literal> if there are no argument expressions, or
                </listitem>
                <listitem>
                    <literal>Sequence&lt;X|Y|Z...&gt;</literal> where <literal>X</literal>,
                    <literal>Y</literal>, <literal>Z</literal> are the types of the argument 
                    expressions, otherwise.
                </listitem>
            </itemizedlist>
            
            <comment><para>TODO: alternatively, we could support a Java-style syntax of form
            <literal>String[] { "hello", "world" }</literal>.</para></comment>
        
        </section>
        
        <section id="positionalarguments">
            <title>Positional arguments</title>
        
        <para>When arguments are listed, the arguments list is enclosed in parentheses.</para>
            
        <programlisting>PositionalArguments: "(" PositionalArgument ("," PositionalArgument)* ("," Sequence)? | Sequence? ")"</programlisting>
        <programlisting>PositionalArgument: Expression | Function</programlisting>
        
        <para>Positional arguments must be listed in the same order as the corresponding
        parameters.</para>
        
        <itemizedlist>
            <listitem>
                <para>First, an argument of each required parameters must be specified, in the 
                order in which the required parameters were declared. There must be at least as 
                many arguments as required parameters.</para>
            </listitem>
            <listitem>
                <para>Next, arguments of the first arbitrary number of defaulted parameters may 
                be specified, in the order in which the defaulted parameters were declared. If 
                there are fewer arguments than defaulted parameters, the remaining defaulted 
                parameters are assigned their default values.</para>
            </listitem>
            <listitem>
                <para>Finally, if arguments to all defaulted parameters have been specified,
                and if the method declares a sequenced parameter, an arbitrary number of arguments 
                to the sequenced parameter may be specified. 
                </para>
            </listitem>
        </itemizedlist>
        
        <para>For example:</para>
        
        <programlisting>(getProduct(id), 1)</programlisting>
        <programlisting>((Float x, Float y) x+y)</programlisting>
        
        </section>
        
        <section id="namedarguments">
            <title>Named arguments</title>
            
        <para>When arguments are named, the argument list is enclosed in braces.</para>
        
        <programlisting>NamedArguments: "{" NamedArgument* Sequence? "}"</programlisting>
        
        <para>Named arguments may be listed in a different order to the corresponding
        parameters.</para>

        <para>Required and defaulted parameter arguments are specified by name. Arguments to
        a sequenced parameter are specified by listing them, without specifying a name, at the 
        end of the argument list.</para>

        <para>A named argument is either:</para> 
        
        <itemizedlist>
            <listitem>
                <para>a specification statement where the name of the value being specified is
                the parameter name&mdash;it specifies its value using <literal>=</literal>, 
                followed by an expression, and is terminated by a semicolon, or</para>
            </listitem>
            <listitem>
                <para>a local declaration with a getter or named argument list where the name 
                of the local is the parameter name&mdash;it specifies the type of the attribute 
                or <literal>value</literal>, and a block or code or named argument list used to 
                instantiate the return type, or</para>
            </listitem>
            <listitem>
                <para>a local anonymous class declaration where the name of the local is the
                parameter name&mdash;an <literal>object</literal> declaration, or</para>
            </listitem>
            <listitem>
                <para>only for callable parameters, a local method declaration with a block or
                named parameter list where the name of the method is the parameter name&mdash;it 
                specifies the return type or <literal>function</literal>, a parameter list and a 
                block of code or named argument list used to instantiate the return type.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>NamedArgument: SpecifiedNamedArgument | LocalNamedArgument | FunctionalNamedArgument | Object</programlisting>
        
        <programlisting>SpecifiedNamedArgument: MemberName Specifier ";"</programlisting>
        
        <programlisting>LocalNamedArgument: (UnionType | "value") MemberName (Block | NamedArguments)</programlisting>
        
        <programlisting>FunctionalNamedArgument: (UnionType | "function" | "void") MemberName Params+ (Block | NamedArguments)</programlisting>
        
        <para>For example:</para>
        
        <programlisting>{ 
    product = getProduct(id); 
    quantity = 1; 
}</programlisting>
        
        <programlisting>{
    description = "Total";
    Float amount { 
        variable Float total := 0.0;
        for (Item item in items) {
            sum += item.amount;
        }
        return total;
    }
}</programlisting>
        
        <programlisting>{
    Head head { title="Hello"; }
    Body body {
        Div { "Hello " name "!" }
    }
}</programlisting>

        <programlisting>{
    object iterator 
            satisfies Iterator&lt;Order&gt; {
        head = order;
        tail = null;
    }   
}</programlisting>

        <programlisting>{ 
    label = "Say Hello"; 
    void onClick() { 
        say("Hello"); 
    } 
}</programlisting>
        
        <programlisting>{ 
    Comparison by(Value x, Value y) { 
        return x&lt;=&gt;y; 
    } 
}</programlisting>

        <para>This is simpler using type inference:</para>

        <programlisting>{ 
    function by(Value x, Value y) { 
        return x&lt;=&gt;y; 
    } 
}</programlisting>

        <comment><para>TODO: Should the named argument list be allowed to contain arbitrary 
        statements? This is more regular, since you can do it in the body of a class, and 
        attribute/method refinement is the model that we are following here. And it could be 
        very useful when defining structured data.</para></comment>
        
        <!--comment><para>TODO: Especially, should we support <literal>if/else</literal> and
        <literal>for</literal> in a named argument list. This might be super-useful for
        templating, for example:</para>
        <programlisting>ul { 
    if (error) { 
        color = red;
        li { "oops, something bad happened!" }
    } 
    else { 
        color = yellow;
        for (r in results) {
            li { r.successMessage }
        }
    } 
}</programlisting>
        <para>But the truth is that this would actually be a generally useful part of the 
        expression syntax.</para>
        </comment-->
        
        <comment><para>TODO: Should we let you define a getter/setter pair for parameters 
        which are passed by reference?</para></comment>
        
        </section>

        <section id="sequencedarguments">
            <title>Sequenced and tuple arguments</title>
            
        <para>For a sequenced parameter of type <literal>T...</literal> in a direct 
        invocation expression, there may be either:</para> 
        
        <itemizedlist>
            <listitem>
                <para>multiple arguments separated by commas, or</para>
            </listitem>
            <listitem>
                <para>a single argument followed by an ellipsis.</para>
            </listitem>
        </itemizedlist>

        <para>In the first case, the argument expressions are evaluated and collected into 
        an instance of <literal>Iterable&lt;T&gt;</literal> when the invocation is executed.</para>
                
        <para>In the second case, the single argument expression must be of type 
        <literal>Iterable&lt;T&gt;</literal>, and must be followed by an ellipsis 
        <literal>...</literal>, to indicate that it is <emphasis>not</emphasis> necessary 
        to wrap the value in an <literal>Iterable</literal>.</para>
        
        <para>An argument to a tuple parameter is always a single expression followed by 
        an ellipsis.</para>
                        
        <programlisting>Sequence: Expression ("," Expression)* | Expression "..."</programlisting>
        
        <comment><para>Note: the ellipsis <literal>...</literal> is like the opposite of 
        a sequence instantiation: <literal>{ x... }</literal> means <literal>x</literal>
        and <literal>{ x, y }...</literal> means <literal>x, y</literal>.</para></comment>
        
        <para>For example:</para>
        
        <programlisting>(1, 1, 2, 3, 5, 8)</programlisting>
        <programlisting>(names...)</programlisting>
        <programlisting>(args...)</programlisting>
        
        <para>TODO: syntax for comprehensions.</para>
        
        <comment><para>TODO: Should we let you write <literal>{ x..., y... }</literal> to
        pass the concatenation of two sequences to a sequenced parameter? Or even things
        like <literal>{ x, y... }</literal> and <literal>{ x..., y }</literal>?</para></comment>
                
        <comment><para>TODO: Should we allow an argument to a sequenced parameter in a named
        argument list to be a local declaration, thus allowing the object to be referred to
        later?</para>
            <programlisting>Panel {
    label = "Hello";
    Input i = Input(),
    Button {
        label = "Hello";
        void action() {
            log.info(i.text);
        }
    }
}</programlisting>            
        </comment>
        
        <!--
        <comment><para>TODO: actually, upon reflection, I think it might be better and more
        regular to use semicolons to separate sequenced arguments in a named argument 
        invocation.</para></comment>
        -->
        
        </section>
                    
        <section id="defaultarguments">
            <title>Default arguments</title>
        
        <para>When no argument is assigned to a defaulted parameter by the caller, the 
        default argument defined by the parameter declaration is used. The default argument 
        expression is evaluated every time the method is invoked with no argument specified 
        for the defaulted parameter.</para>
        
        <para>This class:</para>
        
        <programlisting>shared class Counter(Integer initialCount=0) {
    
    variable Integer count := initialCount;
    
    ...
    
}</programlisting>
        
        <para>May be instantiated using any of the following:</para>
        
        <programlisting>Counter()</programlisting>
        <programlisting>Counter(1)</programlisting>
        <programlisting>Counter {}</programlisting>
        <programlisting>Counter { initialCount=10; }</programlisting>
                
            <para>This method:</para>
        
            <programlisting>shared class Counter() {
    
    variable Integer count := 0;
    
    shared void init(Integer initialCount=0) {
        count:=initialCount;
    }
    
    ...

}</programlisting>
            
            <para>May be invoked using any of the following:</para>
        
            <programlisting>counter.init()</programlisting>
            <programlisting>counter.init(1)</programlisting>
            <programlisting>counter.init {}</programlisting>
            <programlisting>counter.init { initialCount=10; }</programlisting>

        </section>
        
        <!--
        <section id="callablearguments">
            <title>Inline callable arguments</title>
            
        <para>After a positional argument list, arguments to callable parameters 
        may be specified with certain punctuation eliminated:</para>
        
        <itemizedlist>
            <listitem>
                <para>the return type is not declared,</para>
            </listitem>
            <listitem>
                <para>if the callable parameter has an empty parameter list, the 
                empty parentheses may be eliminated, and</para>
            </listitem>
            <listitem>
                <para>if the body of the method implementation consists of a single
                <literal>return</literal> directive followed by a parenthesized
                expression, the braces and <literal>return</literal> keyword may be 
                eliminated.</para>
            </listitem>
        </itemizedlist>
        
        <para>These arguments are called an <emphasis>inline callable arguments</emphasis> 
        of a positional argument invocation. (This is what Ceylon provides instead of
        lambda expressions.)</para>
                
        <programlisting>FunctionalArguments: (MemberName FunctionalBody)+</programlisting>
        
        <programlisting>FunctionalBody: Params? ( Block | "(" Expression ")" )</programlisting>
                
        <para>For example:</para>
        
        <programlisting>where (Person p) (p.age>18)</programlisting>
        
        <programlisting>by (Float x, Float y) (x&lt;=&gt;y)</programlisting>
        
        <programlisting>ifTrue (x+1)</programlisting>
        
        <programlisting>perform { count+=1; }</programlisting>
        
        <programlisting>perform (Person p) { log.info(p.name); }</programlisting>
        
        <programlisting>by (String key->String item) (item nonempty)</programlisting>
        
        <para>Inline callable arguments are listed without any additional punctuation:</para>
        
        <programlisting>ifTrue (x+1) ifFalse (x-1)</programlisting>
        
        <programlisting>select (Person p) (p.name) where (Person p) (p.age>18)</programlisting>
        
        <para>Arguments must be listed in the same order as the parameters are declared by the 
        method declaration.</para>
        
        <comment><para>TODO: should we outlaw <literal>return</literal> directives in the body
        of an inline callable argument?</para></comment>
        
        <comment><para>TODO: Should we provide "true" anonymous function support, according to
        the same syntax:</para>
        <programlisting>void logName(Person p) = (Person p) { log.info(p.name); };</programlisting>
        <programlisting>Boolean adult(Person p) = (Person p) (p.age>18);</programlisting>
        <para>Perhaps readability would be enhanced by a keyword:</para>
        <programlisting>void logName(Person p) = void (Person p) { log.info(p.name); };</programlisting>
        <programlisting>Boolean adult(Person p) = function (Person p) (p.age>18);</programlisting>
        </comment>
        
        <comment><para>TODO: Should we introduce the ability to declare functional parameters
        outside the parentheses in method and class definitions, in order to better respect the 
        intended invocation syntax? For example:</para>
        <programlisting>shared void assert(Gettable&lt;String&gt; message) Boolean that { ... }</programlisting>
        <programlisting>shared Value when&lt;Value&gt;(Boolean condition) Value then Value otherwise { ... }</programlisting>
        <programlisting>shared void repeat(Integer repetitions) void times(Integer i) { ... }</programlisting>
        </comment>
        
        <comment><para>TODO: Since this is our solution for "anonymous methods" (lambda 
        expressions), we could reuse exactly the same syntax for something like Java's 
        anonymous classes. Essentially this would be an inline anonymous class declaration
        where you are allowed to omit the <literal>object</literal> keyword. So you would 
        be left with the parameter name, the <literal>extends</literal> and/or 
        <literal>satisfies</literal> clauses, and the class body. For example:</para>
        <programlisting>File file = ... ;
using() resource satisfies Usable {
    shared actual void begin() {
        file.create();
    }
    shared actual void end() { 
        file.close();
    }
    shared actual void end(Exception e) { 
        file.delete();
    }
}</programlisting>
        <para>Perhaps the <literal>extends</literal> or <literal>satisfies</literal> 
        clause could be inferred from the parameter type in some cases.</para></comment>
        
        <comment><para>TODO: Should we support type inference for the parameters?
        For example:</para>
        <programlisting>by (value x, value y) (x&lt;=&gt;y)</programlisting>
        <programlisting>where (value p) (p.age>18)</programlisting></comment>

        </section>
        -->
            <!--
            <section id="resolvingoverloadedmethodsandtypes">
                <title>Resolving direct invocations of overloaded methods and classes</title>
                
                <para>A direct invocation is resolved to a specific toplevel declaration or 
                member of the receiving type at compile time, even if the method or class it 
                refers to is overloaded.</para>
                
                <para>The <emphasis>initial signature</emphasis> of a method or class in a direct
                invocation is formed by:</para>
        
                <itemizedlist>
                    <listitem>
                        <para>taking the signature of the parameter list of the class, or of the 
                        first parameter list of the method, and</para>
                    </listitem>
                    <listitem>
                        <para>replacing each occurrence of any type parameter of the receiving type
                        in the signature with the type argument of that parameter in the callable 
                        object expression type, and</para>
                    </listitem>
                    <listitem>
                        <para>replacing each occurrence of any type parameter of the method or class 
                        in the signature with the explicitly specified type argument, if type 
                        arguments were specified, or with the first declared upper bound of the type 
                        parameter, or <literal>ceylon.language.Void</literal> if the type parameter 
                        has no declared upper bound.</para>
                    </listitem>
                </itemizedlist>
        
                <para>A direct invocation is <emphasis>resolveable</emphasis> if there is 
                exactly one method, callable parameter, or class declaration which:</para>
                
                <itemizedlist>
                    <listitem>
                        <para>has the specified name,</para>
                    </listitem>
                    <listitem>
                        <para>has the same number of parameters as specified argument expressions,</para>
                    </listitem>
                    <listitem>
                        <para>has a type parameter list to which the type argument list conforms, 
                        if type arguments were explicitly specified,</para>
                    </listitem>
                    <listitem>
                        <para>specifies generic type constraints which are satisfied by the type 
                        arguments, if type arguments were explicitly specified, and which</para>
                    </listitem>
                    <listitem>
                        <para>has an initial signature to which the given argument expression types 
                        are assignable.</para>
                    </listitem>
                </itemizedlist>
                
                <para>In the case of a method with multiple parameter lists, only the first
                parameter list is considered.</para>
                
                <para>If more than one overloaded declaration has an initial signature to which 
                the arguments are assignable, or if there is no declaration with an initial 
                signature to which the arguments are assignable, the invocation or instantiation 
                is illegal. (Note that Ceylon is stricter and simpler than Java with this rule.)</para>
                                
                <para>Finally, if type arguments were not explicitly specified, there must be a
                combination of type arguments that can be substituted for the type parameters of
                the method or type, respecting constraints upon the type parameters, that results
                in a method schema such that:</para>
                
                <itemizedlist>
                    <listitem>
                        <para>the given argument expression types are assignable to the method
                        parameter types after substitution of the type arguments, and</para>
                    </listitem>
                    <listitem>
                        <para>the expression type of the invocation or instantiation, after 
                        substitution of the type arguments, is assignable to the surrounding
                        context.</para>
                    </listitem>
                </itemizedlist>
                
                <comment><para>TODO: Figure out the details of the type inference implied by this 
                last bit!</para></comment>
                
                <para>If no such combination of type arguments exists, the invocation or 
                instantiation is illegal. (Note that Ceylon is less strict than Java with this 
                rule.)</para>
                
                <comment><para>TODO: We should be able to disambiguate <literal>X x(Y y)</literal>
                from <literal>X x(Y... ys)</literal> when called as <literal>x(y)</literal>.</para></comment>
                
                <comment><para>TODO: For type constraints with an initialization parameter 
                specification, the actual parameter type may not declare such signature, but
                one of its superclasses may. Is the compiler allowed to infer the superclass
                type in this situation? If so, what happens when both the class and its 
                superclass satisfy the constraint?</para></comment>
                
            </section>
            -->
    </section>
    
    <section id="evaluationandassignment">
        <title>Evaluation, invocation, and assignment</title>
        
        <para>Evaluation of an expression may result in:</para>
        
        <itemizedlist>
            <listitem><para>invocation of a method or instantiation of a class,</para></listitem>
            <listitem><para>evaluation of an attribute or local, or</para></listitem>
            <listitem><para>assignment to a <literal>variable</literal> attribute or local.</para></listitem>
        </itemizedlist>
        
        <!--
        <para>A reference object&mdash;any instance of <literal>Gettable</literal>&mdash;can 
        be <emphasis>evaluated</emphasis> to produce a value. Evaluation is the process of
        transforming a reference of type <literal>Gettable&lt;T&gt;</literal> into a value of
        type <literal>T</literal>.</para>
        
        <para>Evaluation occurs automatically wherever an expression of type 
        <literal>Gettable&lt;T&gt;</literal> appears where an expression of type 
        <literal>T</literal> is required, in particular, where 
        <literal>Gettable&lt;T&gt;</literal> occurs:</para>
        
        <itemizedlist>
            <listitem>
                <para>as the specified expression in a specification statement or declaration 
                of a member or local of type <literal>T</literal>,</para>
            </listitem>
            <listitem>
                <para>as the receiver expression of a callable reference or value 
                reference,</para>
            </listitem>
            <listitem>
                <para>as the argument of an invocation or operator expression that expects 
                a value of type <literal>T</literal>,</para>
            </listitem>
            <listitem>
                <para>in a <literal>return</literal> directive of a method with declared
                return type <literal>T</literal>,</para>
            </listitem>
            <listitem>
                <para>in a <literal>throw</literal> or <literal>break</literal> 
                directive,</para>
            </listitem>
            <listitem>
                <para>as a control structure condition, resource, or iteration expression, 
                or</para>
            </listitem>
            <listitem>
                <para>as an expression statement.</para>
            </listitem>
        </itemizedlist>
                
        <programlisting>Integer age = person.age;</programlisting>
        <programlisting>person.say("Hello!");</programlisting>
        <programlisting>Iterable&lt;String&gt; tokens = input.Tokens();</programlisting>
        <programlisting>return person.name;</programlisting>
        <programlisting>throw Exception();</programlisting>
        <programlisting>if (exists head = iter.head) { ... }</programlisting>
        
        <para>If a reference object is of type <literal>Settable</literal>, its value may also 
        be <emphasis>assigned</emphasis>. Assignment is performed using the <literal>:=</literal> 
        operator.</para>
         
        <programlisting>person.name := "Gavin";</programlisting>
        -->
        
    <section id="evaluation">
        <title>Evaluation</title>
        
        <para>Evaluation of an attribute reference or local reference produces the current value 
        of the attribute or local.</para> 
        
        <programlisting>String name = person.name;</programlisting>
        
        <!--
        <para>Sometimes we need to pass an attribute by reference:</para>
        
        <programlisting>Gettable&lt;String&gt; nameRef = person.name;
String name = nameRef;</programlisting>
        
        <para>Sometimes we need to transform an attribute reference into a method 
        reference. The toplevel method <literal>lang.get()</literal> is provided 
        for this purpose:</para>
        
        <programlisting>String getName() = get(person.name);
String name = getName();</programlisting>
        -->
        
        <para>When a local evaluation is executed, the current value of the local is 
        immediately obtained. The resulting value is the current value of the local.</para>
                
        <para>When an attribute evaluation is executed:</para>
        
        <itemizedlist>
            <listitem>
                <para>first, the reference expression is executed to obtain the reference 
                object, then</para>
            </listitem>
            <listitem>
                <para>the actual member to be invoked is determined by considering the 
                runtime type of the receiving instance, and then</para>
            </listitem>
            <listitem>
                <para>if the member is a simple attribute, the current value of the 
                simple attribute is retrieved from the recieving instance, or</para>
            </listitem>
            <listitem>
                <para>otherwise, execution of the calling context pauses while the body 
                of the attribute getter is executed by the receiving instance, then,</para>
            </listitem>
            <listitem>
                <para>finally, when execution of the getter ends without a thrown 
                exception, execution of the calling context resumes.</para>
            </listitem>
        </itemizedlist>
        
        <para>The resulting value is the current value of the simple attribute or the 
        return value of the attribute getter, as specified by the <literal>return</literal> 
        directive.</para>
        
        <!--
        <para>Note that the <literal>item()</literal> method of <literal>Correspondence</literal>
        is also defined to return a <literal>Gettable</literal>.</para>
        
        <programlisting>Person? person = people[index];</programlisting>
        
        <para>Therefore an element expression can be passed by reference:</para>
        
        <programlisting>Gettable&lt;Person?&gt; personRef = person[index];
Person? person = personRef;</programlisting>
        
        <para>And an element expression can be transformed into method reference:</para>
        
        <programlisting>Person? getPerson() = get(people[index]);
Person? person = getPerson();</programlisting>
        -->
        
    </section>
    
    <section id="invocation">
        <title>Invocation</title>
        
        <para>Evaluation of an invocation expression of a callable reference invokes the 
        underlying callable reference. This is called <emphasis>invocation</emphasis> in
        the case of a method reference, and <emphasis>instantiation</emphasis> in the case
        of an initializer reference.</para>
        
        <programlisting>log.info("Hello world!");</programlisting>
        <programlisting>Map&lt;String, Person&gt; map = HashMap&lt;String, Person&gt;(entries);</programlisting>
        
        <!--
        <para>Sometimes we need to perform an invocation lazily:</para>
        
        <programlisting>Gettable&lt;Void&gt; logInfoHello = log.info("Hello world!");
void invoke(Void v) {}
invoke(logInfoHello);</programlisting>

        <programlisting>Gettable&lt;Map&lt;String, Person&gt;&gt; createMapFromEntries = HashMap&lt;String, Person&gt;(entries);
Map&lt;String, Person&gt; map = createMapFromEntries;</programlisting>
        -->
        
        <para>When an evaluation of an invocation expression of a callable reference is 
        executed:</para>
        
        <itemizedlist>
            <listitem>
                <para>first, the invoked expression is executed to obtain the callable 
                object, then</para>
            </listitem>
            <listitem>
                <para>each argument is evaluated in turn in the calling context, then</para>
            </listitem>
            <listitem>
                <para>the actual member to be invoked is determined by considering the runtime
                type of the receiving instance and the static types of the arguments, and then</para>
            </listitem>
            <listitem>
                <para>execution of the calling context pauses while the body of the method or 
                initializer is executed by the receiving instance with the argument values, 
                then</para>
            </listitem>
            <listitem>
                <para>finally, when execution of the method or initializer ends without a thrown 
                exception, execution of the calling context resumes.</para>
            </listitem>
        </itemizedlist>
        
        <!--para>When an evaluation of any other invocation expression is executed, the 
        <literal>call()</literal> method of <literal>Callable</literal> is invoked.</para-->
        
        <para>A method invocation evaluates to the return value of the method, as specified 
        by the <literal>return</literal> directive. The argument values are passed to the 
        parameters of the method, and the body of the method is executed.</para>
        
        <para>The actual value that invocation of a <literal>void</literal> method returns
        is not specified here. The type system and the definition of the <literal>is</literal> 
        operator ensures that a value of type <literal>Void</literal> can never be narrowed
        to a more specific type.</para>
        
        <para>A class instantiation evaluates to a new instance of the class. The argument 
        values are passed to the initializer parameters of the class, and the initializer
        is executed.</para>
             
    </section>
    
    <section id="assignment">
        <title>Assignment</title>
            
        <para>The assignment operator <literal>:=</literal> assigns a new value to an 
        attribute reference for a <literal>variable</literal> attribute or local.</para>
        
        <programlisting>person.name := "Gavin";</programlisting>
        
        <!--
        <para>Sometimes we need to pass a <literal>variable</literal> attribute by 
        reference:</para>
        
        <programlisting>Settable&lt;String&gt; nameRef = person.name;
nameRef := "Gavin";</programlisting>

        <para>Sometimes we need to transform a <literal>variable</literal> attribute 
        reference into a method reference. The toplevel method <literal>lang.set()</literal> 
        is provided for this purpose:</para>
        
        <programlisting>String setName(String name) = set(person.name);
setName("Gavin");</programlisting>

        <para>Even the following are possible:</para>
        
        <programlisting>Settable&lt;String&gt; getName(Person p) { return p.name; }
getName(p) := "Gavin";</programlisting>

        <programlisting>setName(Settable&lt;String&gt; name, String arg) { name:=arg; }
setName(p.name, "Gavin");</programlisting>
        -->
        
        <para>When an attribute or local is assigned:</para>
        
        <itemizedlist>
            <listitem>
                <para>first, the reference expression is executed to obtain the reference 
                object, then</para>
            </listitem>
            <listitem>
                <para>the actual member to be invoked is determined by considering the 
                runtime type of the receiving instance, and then</para>
            </listitem>
            <listitem>
                <para>if the member is a simple attribute or local, the value of the 
                simple attribute of local is set to the new value,</para>
            </listitem>
            <listitem>
                <para>otherwise, execution of the calling context pauses while the body 
                of the attribute setter is executed by the receiving instance with the 
                new value, then,</para>
            </listitem>
            <listitem>
                <para>finally, when execution of the setter ends without a thrown 
                exception, execution of the calling context resumes.</para>
            </listitem>
        </itemizedlist>
        
        <!--
        <para>Note that the <literal>item()</literal> method of <literal>OpenCorrespondence</literal>
        is also defined to return an <literal>Settable</literal>.</para>
        
        <programlisting>people[index] := person;</programlisting>
        
        <para>Therefore an assignable element expression can be passed by reference:</para>
        
        <programlisting>Settable&lt;Person?&gt; personRef = people[index];
personRef := person;</programlisting>
        
        <para>And an assignable element expression can be transformed into method 
        reference:</para>
        
        <programlisting>Person? setPerson(Person? p) = set(people[index]);
setPerson(person);</programlisting>
        -->
        
    </section>
    
    </section>
    
    <section id="metamodelreferences">
        <title>Metamodel references</title>
        
        <para>The metamodel object representing a type or program element may be obtained
        using a completely typesafe syntax.</para>
        
        <programlisting>Meta: TypeMeta | MethodMeta | AttributeMeta | FunctionMeta | ValueMeta</programlisting>
        
        <para>Metamodel references are compile-time typesafe.</para>
        
        <programlisting>Type&lt;List&lt;String&gt;&gt; stringListType = List&lt;String&gt;;</programlisting>
        
        <programlisting>Class&lt;Person,Name&gt; personClass = Person;</programlisting>
        
        <programlisting>Method&lt;Log, Void, String&gt; infoMethod = Log.info;</programlisting>
        
        <programlisting>Method&lt;String, Boolean, String&gt; stringSmaller = Comparable&lt;String&gt;.smallerThan;</programlisting>
        
        <programlisting>Attribute&lt;Person, Name&gt; nameAttribute = Person.name;</programlisting>
        
        <para>A metamodel reference that refers to a generic declaration must specify type
        arguments.</para>
        
        <comment><para>Note: this restriction results from the lack of existential types. 
        The expression <literal>Entry</literal> would have the existential type 
        <literal>ClassConstructor&lt;Entry&lt;Key,Item&gt;,Key,Item&gt; given Key satisfies Object given Item satisfies Object</literal>.
        The expression <literal>Comparable.smallerThan</literal> would be of existential type 
        <literal>MethodConstructor&lt;Value,Boolean,Value&gt; given Value satisfies Comparable&lt;Value&gt;</literal>.</para></comment>
        
        <comment><para>TODO: Do we anyway need some kind of metamodel objects for type 
        constructors like <literal>Entry</literal> or even <literal>Comparable.smallerThan</literal>. 
        These would not support typesafe operations, but would at least allow runtime 
        reflection.</para></comment>
        
        <comment><para>TODO: Are there metamodel objects for block local declarations? This
        includes block local declarations inside a class body, and block local declarations
        inside a method or attribute body.</para></comment>
        
        <comment><para>TODO: Should we have typesafe metamodel reference expressions for 
        parameters? For example: <literal>Parameter&lt;String&gt; wordsParam = Person.say#words;</literal></para></comment>
        
        <!--
        <comment><para>TODO: Should we remodel member metamodel references as members of the 
        metatype? Then we can get rid of two of the following sections. The reason to not do 
        this is that member class metamodel references have the wrong case for an 
        attribute.</para></comment>
        -->
        
        <section id="interfaceandclassmetamodelreferences">
            <title>Interface and class metamodel references</title>
            
        <para>A <literal>Type</literal> object may be obtained by specifying the full
        type, including type arguments if the type is generic.</para>
        
        <programlisting>TypeMeta: Type</programlisting>
        
        <para>The metamodel expression, <literal>X</literal>, for a type, class or interface 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>of type <literal>Interface&lt;X&gt;</literal> where 
                <literal>X</literal> is the interface, or</para>
            </listitem>
            <listitem>
                <para>assignable to <literal>Class&lt;X,P...&gt;</literal> where 
                <literal>X</literal> is the toplevel <literal>abstract</literal> class and 
                <literal>P...</literal> are the types of the parameter list of the class, 
                <!--for every overloaded version of the class,--> or</para>
            </listitem>
            <listitem>
                <para>assignable to <literal>OpenConcreteClass&lt;X,P...&gt;</literal> where 
                <literal>X</literal> is the toplevel concrete class and <literal>P...</literal> 
                are the types of the parameter list of the class, <!--for every overloaded 
                version of the class,--> or</para>
            </listitem>
            <listitem>
                <para>assignable to <literal>OpenMemberClass&lt;X,Y,P...&gt;</literal> where 
                <literal>Y</literal> is the member class and <literal>P...</literal> 
                are the types of the parameter list of the class. <!--for every overloaded 
                version of the class.--></para>
            </listitem>
        </itemizedlist>
        
        <para>Note that for a toplevel class <literal>X</literal>, the expression <literal>X</literal>
        is both a metamodel reference and a callable reference. This is consistent, since
        <literal>Class&lt;X,P...&gt;</literal> is a subtype of <literal>Callable&lt;X,P...&gt;</literal>.</para>
        
        <para>Furthermore, the expression type is assignable to all metatypes of the 
        type&mdash;the types listed in the <literal>is</literal> clause of the type 
        definition. <emphasis>(Note that metatypes are a proposed feature for a future 
        version of the language.)</emphasis></para>
        
        </section>
        
        <section id="toplevelmethodmetamodelreferences">
            <title>Toplevel method metamodel references</title>
            
        <para>A <literal>Function</literal> object representing a toplevel method may be 
        obtained by specifying the method name, with type arguments if the toplevel method 
        is generic.</para>
        
        <programlisting>FunctionMeta: MemberName TypeArguments?</programlisting>
               
        <para>The metamodel expression, <literal>method</literal>, for a toplevel method 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>assignable to <literal>OpenFunction&lt;R,P...&gt;</literal> where 
                <literal>R</literal> is the callable type of a method produced by 
                removing the first parameter list of the method, and <literal>P...</literal> 
                are the types of the first parameter lists of the method. <!--for every 
                overloaded version of the method.--></para>
            </listitem>
        </itemizedlist>
        
        <para>Note that for a toplevel method <literal>x()</literal>, the expression 
        <literal>x</literal> is both a metamodel reference and a callable reference. This 
        is consistent, since <literal>Function&lt;X,P...&gt;</literal> is a subtype of 
        <literal>Callable&lt;X,P...&gt;</literal>.</para>
           
        </section>
        
        <section id="membermethodmetamodelreferences">
            <title>Member method metamodel references</title>
            
        <para>A <literal>Method</literal> object representing a member method may be 
        obtained by specifying the type (with type arguments) and member name, together 
        with type arguments if the method is generic.</para>
        
        <programlisting>MethodMeta: Type "." MemberName TypeArguments?</programlisting>
               
        <para>The metamodel expression, <literal>X.member</literal>, for a member method 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>assignable to <literal>OpenMethod&lt;X,R,P...&gt;</literal> where 
                <literal>X</literal> is the type that defines the method, and 
                <literal>R</literal> is the callable type of a method produced by 
                removing the first parameter list of the method, and 
                <literal>P...</literal> are the types of the first parameter list of 
                the method. <!--for every overloaded version of the method.--></para>
            </listitem>
        </itemizedlist>
         
        </section>
        
        <section id="toplevelattributemetamodelreferences">
            <title>Toplevel attribute metamodel references</title>
            
        <para>A <literal>Value</literal> object representing a toplevel attribute may be 
        obtained by specifying the attribute name, with type arguments if the toplevel method 
        is generic.</para>
        
        <programlisting>ValueMeta: MemberName TypeArguments?</programlisting>
               
        <para>The metamodel expression, <literal>attribute</literal>, for a toplevel attribute 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>of type <literal>OpenValue&lt;T&gt;</literal> where 
                <literal>T</literal> is the declared type of the attribute.<!-- ,
                unless the attribute is declared <literal>variable</literal>, or--></para>
            </listitem>
            <!-- 
            <listitem>
                <para>of type <literal>MutableValue&lt;T&gt;</literal> where 
                <literal>T</literal> is the declared type of the attribute,
                if the attribute is declared <literal>variable</literal>.</para>
            </listitem>
            -->
        </itemizedlist>
        
        <para>Note that for a toplevel attribute <literal>x</literal>, the expression <literal>x</literal>
        is both a metamodel reference and a value reference. This is consistent, since
        <literal>Value&lt;T&gt;</literal> is assignable to <literal>Gettable&lt;T&gt;</literal>.<!-- 
        and <literal>MutableValue&lt;T&gt;</literal> is assignable to <literal>Settable&lt;T&gt;</literal>.--></para>
           
        </section>
        
        <section id="attributemetamodelreferences">
            <title>Member attribute metamodel references</title>
            
        <para>An <literal>Attribute</literal> object representing a member attribute may 
        be obtained by specifying the type (with type arguments) and member name.</para>
        
        <programlisting>AttributeMeta: Type "." MemberName</programlisting>

        <para>The metamodel expression, <literal>X.member</literal>, for a member 
        attribute is:</para>
        
        <itemizedlist>
            <listitem>
                <para>of type <literal>OpenAttribute&lt;X,T&gt;</literal> where 
                <literal>X</literal> is the type that defines the attribute, 
                and <literal>T</literal> is the declared type of the attribute,
                unless the attribute is declared <literal>variable</literal>, or</para>
            </listitem>
            <listitem>
                <para>of type <literal>OpenMutableAttribute&lt;X,T&gt;</literal> where 
                <literal>X</literal> is the type that defines the attribute, 
                and <literal>T</literal> is the declared type of the attribute,
                if the attribute is declared <literal>variable</literal>.</para>
            </listitem>
        </itemizedlist>
         
        </section>
        
        <section id="usingthemetamodel">
            <title>Using the metamodel</title>
            
        <para>The metamodel object for a type allows its members to be iterated:</para>
        
        <programlisting><![CDATA[for (Attribute<Value,String> attribute 
            in Value.members(Attribute<Value,String>)) {
    log.info(attribute.declaringType.name + "." + attribute.name 
                + "=" + attribute(obj));
}]]></programlisting>
        
        <!--
        <programlisting><![CDATA[for (Attribute<obj.subtype,String> attribute 
            in obj.subtype.members(Attribute<obj.subtype,String>)) {
    log.info(attribute.declaringType.name + "." + attribute.name 
                + "=" + attribute(obj));
}]]></programlisting>
        -->
        
        <para>The metamodel object for a class, attribute or method satisfies 
        <literal>Callable</literal> and is therefore invokable.</para>
        
        <programlisting>Class&lt;ArrayList&lt;String&gt;,String[]&gt; arrayListClass = ArrayList&lt;String&gt;;
        
List list = arrayListClass("foo", "bar", "baz);</programlisting>
        
        <programlisting>Attribute&lt;Person, String&gt; nameAttribute = Person.name;
        
String personName = nameAttribute(person);</programlisting>
        
        <programlisting>Method&lt;Person, String&gt; sayMethod = Person.say;
        
String result = sayMethod(person)();</programlisting>

        <programlisting>MutableAttribute&lt;Counter, Integer&gt; countAttribute = Counter.count;

countAttribute(this)++;</programlisting>        

        <para>The metamodel object for a class, attribute or method supports registration 
        of a listener, which intercepts invocations.</para>
        
        <programlisting>OpenMutableAttribute&lt;Counter, Integer&gt; countAttribute = Counter.count;

countAttribute.intercept() 
    onGet (Counter c, Integer proceed()) {
        log.debug("getting");
        return proceed();
    };
    
countAttribute.intercept() 
    onSet (Counter c, void proceed(Integer n), Integer arg) {
        log.debug("setting");
        proceed(arg);
    };</programlisting>

        <programlisting>OpenMethod&lt;Order,Item,Product,Integer&gt; createItemMethod = Order.createItem;
        
createItemMethod.intercept()
    onInvoke (Order o, Item proceed(Product p, Integer n),  
              Product product, Integer quantity) {
        log.debug("invoking in transaction");
        try (Transaction()) {
            return proceed(product,quantity);
        }
    };</programlisting>
    
        </section>
    
        <comment><para>TODO: According to this, we can "curry" in type arguments of
        the type. We need this. But if so, why can't we curry type arguments of the 
        member? It's not a problem from the grammar point of view.</para></comment>
        
    </section>

    <section id="operators">
    <title>Operators</title>
    
    <para>Operators are syntactic shorthand for more complex expressions
    involving method invocation or attribute access. Each operator is defined 
    for a particular type. There is no support for user-defined operator 
    <emphasis>overloading</emphasis>. However, the semantics of an operator 
    may be customized by the implementation of the type that the operator
    applies to. This is called <emphasis>operator polymorphism</emphasis>.</para>
    
    <para>Some examples:</para>
    
    <programlisting>Float z = x * y + 1.0;</programlisting>
    
    <programlisting>even := n % 2 &equals; 0;</programlisting>
    
    <programlisting>++count;</programlisting>
    
    <programlisting>Integer j = i++;</programlisting>
    
    <programlisting>if ( x > 100 || x &lt; 0 ) { ... }</programlisting>
    
    <programlisting>User? gavin = users["Gavin"];</programlisting>
    
    <programlisting>List&lt;Item&gt; firstPage = list[0..20];</programlisting>
    
    <programlisting>for (Integer n in 1..10) { ... }</programlisting>
    
    <programlisting>if (char in `A`..`Z`) { ... }</programlisting>
    
    <programlisting>List&lt;Day&gt; nonworkDays = days[{0,7}];</programlisting>
    
    <programlisting>Integer lastIndex = getLastIndex() ? sequence.lastIndex;</programlisting>
    
    <programlisting>log.info("Hello " + $person + "!")</programlisting>
    
    <programlisting>List&lt;String&gt; names = {person1, person2, person3}[].name;</programlisting>
    
    <programlisting>String? name = person?.name;</programlisting>
    
    <programlisting>this.total += item.price;</programlisting>
        
    <programlisting>Float vol = length**3;</programlisting>
    
    <programlisting>map.define(person.name->person);</programlisting>
    
    <programlisting>order.lineItems[index] := LineItem { product = prod; quantity = 1; };</programlisting>
    
    <programlisting>if (!document.internal || user is Employee) { ... }</programlisting>
    
    <para>In all operator expressions, the arguments of the operator must be 
    evaluated from left to right when the expression is executed. In certain cases, 
    depending upon the definition of the operator, evaluation of the leftmost 
    argument expression results in a value that causes the final value of the 
    operator expression to be produced immediately without evaluation of the 
    remaining argument expressions. Optimizations performed by the Ceylon compiler 
    must not alter these behaviours.</para>
    
    <comment><para>TODO: Should we have operators for function composition, or 
    even partial application. Perhaps infix <literal>:</literal> could be 
    composition and postfix <literal>@</literal> could be partial application.</para></comment>
    
    <section id="operatorexpressions">
        <title>Operator expressions</title>
        
        <para>The type of an operator expression for an operator that is defined to
        produce the type <literal>T</literal> is:</para> 
                        
        <itemizedlist>
            <listitem>
                <para><literal>T</literal>, if <literal>T</literal> is assignable
                to <literal>Gettable&lt;Object&gt;</literal>, or, otherwise,</para>
            </listitem>
            <listitem>
                <para><literal>Gettable&lt;T&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
    </section>
    
    <section id="operatorprecedence">
        <title>Operator precedence</title>
        
        <para>There are 16 distinct operator precedence levels, but these levels
        are arranged into layers in order to make them easier to predict.</para>
        
        <itemizedlist>
            <listitem><para>Operators in layer 1 produce, transform, and combine
            values.</para></listitem>
            <listitem><para>Operators in layer 2 compare or predicate values, producing
            a <literal>Boolean</literal> result.</para></listitem>
            <listitem><para>Operators in layer 3 are logical operators that operate
            upon <literal>Boolean</literal> arguments to produce a <literal>Boolean</literal>
            value.</para></listitem>
            <listitem><para>Operators in layer 4 perform assignment and conditional
            evaluation.</para></listitem>
        </itemizedlist>
        
        <para>Within each layer, postfix operators have a higher precedence than 
        prefix operators, and prefix operators have a higher precedence than 
        binary operators.</para>
        
        <para>There is a single exception to this principal: the binary 
        exponentiation operator <literal>**</literal> has a higher precedence than 
        the prefix operators <literal>+</literal> and <literal>-</literal>. The 
        reason for this is that the following expressions should be equivalent:</para>
        
        <programlisting>-x**2       //means -(x**2)</programlisting>
        <programlisting>0 - x**2    //means 0 - (x**2)</programlisting>
        
        <para>It's important to be aware that in Ceylon, compared to other C-like 
        languages, the logical not operator <literal>!</literal> has a very low
        precedence. The following expressions are equivalent:</para>
        
        <programlisting>!x.y*2 &equals; 0.0  //means !(x.y*2 &equals; 0.0)</programlisting>
        <programlisting>x.y*2 != 0.0</programlisting>
        
        <para>This table defines the relative precedence of the various operators, 
        from highest to lowest, along with associativity rules:</para>
        
        <table>
        <tgroup cols="4">
            <colspec colnum="1" colwidth="2.5*" align="center" colname="first"/>
            <colspec colnum="2" colwidth="2.0*" align="center"/>
            <colspec colnum="3" colwidth="1.0*" align="center"/>
            <colspec colnum="4" colwidth="0.7*" align="center" colname="last"/>
        <thead>
            <row>
                <entry>Operations</entry>
                <entry>Operators</entry>
                <entry>Type</entry>
                <entry>Associativity</entry>
            </row>
        </thead>
        <tbody>
        
            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 1</emphasis></entry>
            </row>
    
            <row>
                <entry>Member invocation and selection, index, span,
                postfix increment, postfix decrement:</entry>
                <entry>
                <literal>.</literal>,
                <literal>[].</literal>, 
                <literal>?.</literal>, 
                <literal>()</literal>,
                <literal>{}</literal>,
                <literal>[]</literal>,
                <literal>?[]</literal>,
                <literal>[..]</literal>, 
                <literal>[...]</literal>,
                <literal>++</literal>, 
                <literal>--</literal></entry>
                <entry>Binary / ternary / N-ary / unary postfix</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Prefix increment, prefix decrement:</entry>
                <entry>
                <literal>++</literal>, 
                <literal>--</literal>
                </entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Exponentiation:</entry>
                <entry>
                <literal>**</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>            
            <row>
                <entry>Negation:</entry>
                <entry>
                <literal>+</literal>,
                <literal>-</literal>
                </entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Default:</entry> 
                <entry><literal>?</literal></entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <!--  
            <row>
                <entry>Exponentiation, shift:</entry>
                <entry>
                <literal>**</literal>,
                <literal>&lt;&lt;</literal>, 
                <literal>>></literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            -->
            <row>
                <entry>Multiplication, division, remainder,
                Set intersection:</entry> 
                <entry>
                <literal>*</literal>, 
                <literal>/</literal>, 
                <literal>%</literal>,
                <literal>&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Addition, subtraction, Set union,
                Set exclusive union, Set complement:</entry> 
                <entry>
                <literal>+</literal>, 
                <literal>-</literal>, 
                <literal>|</literal>, 
                <literal>^</literal>,
                <literal>~</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <!--row>
                <entry>Date/time composition:</entry> 
                <entry><literal>@</literal></entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row-->
            <row>
                <entry>Range<!--, interval--> and entry construction:</entry> 
                <entry><literal>..</literal>, <literal>-></literal></entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>

            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 2</emphasis></entry>
            </row>
    
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>exists</literal>, <literal>nonempty</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            <!--
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>?</literal>, <literal>??</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            -->
            <row>
                <entry>Comparison, <!--set comparison,--> containment,
                assignability, inheritance:</entry> 
                <entry>
                <literal>&lt;=&gt;</literal>,
                <literal>&lt;</literal>, 
                <literal>&gt;</literal>, 
                <literal>&lt;=</literal>, 
                <literal>&gt;=</literal>,
                <!--<literal>~></literal>,
                <literal>!~></literal>,
                <literal>*~></literal>-->
                <literal>in</literal>,
                <literal>is</literal>,
                <!--<literal>extends</literal>,-->
                <literal>satisfies</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Equality, identity:</entry>
                <entry>
                <literal>&equals;</literal>, 
                <literal>!=</literal>, 
                <literal>&identical;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
        
            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 3</emphasis></entry>
            </row>
    
            <row>
                <entry>Logical not:</entry>
                <entry><literal>!</literal></entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Logical and:</entry> 
                <entry>
                <literal>&amp;&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Logical or:</entry>
                <entry>
                <literal>||</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            
            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 4</emphasis></entry>
            </row>
            
            <row>
                <entry>Conditionals:</entry>
                <entry><literal>then</literal>, 
                <literal>else</literal></entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
    
            <row>
                <entry>Assignment:</entry> 
                <entry>
                <literal>:=</literal>, 
                <literal>.=</literal>,
                <literal>+=</literal>, 
                <literal>-=</literal>, 
                <literal>*=</literal>, 
                <literal>/=</literal>, 
                <literal>%=</literal>, 
                <literal>&amp;=</literal>, 
                <literal>|=</literal>, 
                <literal>^=</literal>, 
                <literal>~=</literal>, 
                <literal>&amp;&amp;=</literal>, 
                <literal>||=</literal>
                <!--literal>?=</literal-->
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            
        </tbody>
        </tgroup>
        </table>

    <!-- 
    <comment><para>TODO: should <literal>^</literal> have a higher precedence than
    <literal>|</literal> like in C and Java? No, cos no-one will ever remember which
    comes first.</para></comment>
    -->
    <!--
    <comment><para>TODO: should <literal>^,|,&amp;</literal> have a lower precedence
    than <literal>+,-,*,/</literal> like in Ruby? No point, cos numbers are not bit 
    strings and bit strings are not numbers in Ceylon.</para></comment>
    -->
    
        <comment><para>Note: if we decide to add <literal>&lt;&lt;</literal> and 
        <literal>&gt;&gt;</literal> later, we could give them the same precedence
        as <literal>**</literal>.</para></comment>
    
    </section>
    
    <section id="operatordefinition">
        <title>Operator definition</title>
        
    <para>The following tables define the semantics of the Ceylon operators. 
    There are four basic operators which do not have a definition in terms of 
    other operators or invocations:</para>
    
    <itemizedlist>
        <listitem>
            <para>the <emphasis>member selection</emphasis> operator
            <literal>.</literal> separates the receiver expression and member 
            name in a callable reference expression or attribute reference 
            expression,</para>
        </listitem>
        <listitem>
            <para>the <emphasis>argument specification</emphasis> operators
            <literal>()</literal> and <literal>{}</literal> specify the 
            argument list of an invocation,</para>
        </listitem>
        <listitem>
            <para>the <emphasis>assignment</emphasis> operator
            <literal>:=</literal> assigns a new value to an instance of
            <literal>Settable</literal> and returns the new value after 
            assignment,</para>
        </listitem>
        <!-- 
        <listitem>
            <para>the <emphasis>identity</emphasis> operator
            <literal>&identical;</literal> evaluates to <literal>true</literal> 
            if its argument expressions evaluate to references to the same 
            object, and <literal>false</literal> otherwise, and</para>
        </listitem>
        -->
        <listitem>
            <para>the <emphasis>assignability</emphasis> operator
            <literal>is</literal> evaluates to <literal>true</literal> if 
            its argument expression evaluates to an instance of a class
            assignable to the specified type, and <literal>false</literal> 
            otherwise.</para>
        </listitem>
        <!-- 
        <listitem>
            <para>the <emphasis>existence</emphasis> operator
            <literal>exists</literal> evaluates to <literal>true</literal> if 
            its argument expression evaluates to an instance of 
            <literal>Object</literal>, and <literal>false</literal> 
            otherwise.</para>
        </listitem>
        -->
    </itemizedlist>
        
    <para>All other operators are defined in terms of other operators and/or
    invocations.</para>
    
    <para>In the tables, the following pseudo-code is used, which is not legal
    Ceylon syntax:</para>
    
    <para>First,</para>
    
    <programlisting>if (b) then x else y   //pseudocode</programlisting>
    
    <para>means the value of <literal>result</literal> after execution of the
    following:</para>
    
    <programlisting>X result; if (b) { result=x; } else { result=y; }</programlisting>
    
    <para>Second,</para>
    
    <programlisting>let t=x in y   //pseudocode</programlisting>
    
    <para>means the value of <literal>result</literal> after execution of the
    following:</para>
    
    <programlisting>X t = x; Y result=y;</programlisting>
    
    <para>The tables define semantics only. The compiler is permitted to emit equivalent 
    bytecode that produces the same value as the pseudo-code that defines the operator, 
    without actually executing any invocation, for the following operators:</para>
    
    <itemizedlist>
        <listitem>
            <para>all arithmetic operators,</para>
        </listitem>
        <listitem>
            <para>all Set operators,</para>
        </listitem>
        <listitem>
            <para>the comparison and equality operators <literal>&equals;</literal>,
            <literal>!=</literal>, <literal>&lt;=&gt;</literal>, <literal>&lt;</literal>,
            <literal>&gt;</literal>, <literal>&lt;=</literal>, <literal>&gt;=</literal>
            when the argument expression types are built-in numeric types,</para>
        </listitem>
        <listitem>
            <para>the <literal>Range</literal> and <literal>Entry</literal> construction 
            operators <literal>..</literal> and <literal>-></literal>,</para>
        </listitem>
        <listitem>
            <para>the sequence concatenation operator <literal>+</literal>,</para>
        </listitem>
        <listitem>
            <para>the identity equality operator <literal>&identical;</literal>, and</para>
        </listitem>
        <listitem>
            <para>all assignment and compound assignment operators.</para>
        </listitem>
    </itemizedlist>
    
    <para>Therefore, listeners registered for the method invocations and class 
    instantiations that define these operators may not be called when the operator 
    expressions are executed.</para>
    
    </section>
    
    <section id="basic">
    <title>Basic invocation and assignment operators</title>
    
        <para>These operators support method invocation and attribute evaluation and
        assignment.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs.member</literal></entry>
            <entry>member</entry>
            <entry></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Member &lt;X,T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs{a=x;b=y;}</literal></entry>
            <entry>invoke</entry>
            <entry></entry>
            <entry><literal>Callable &lt;T,P...&gt;</literal></entry>
            <entry><literal>P...</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
                
        <row><entry namest="first" nameend="last"><emphasis>Assignment</emphasis></entry></row>
    
        <row>
            <entry><literal>lhs := rhs</literal></entry>
            <entry>assign</entry>
            <entry><literal></literal></entry>
            <entry><literal>Settable&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Format</emphasis></entry></row>
        
        <row>
            <entry><literal>$rhs</literal></entry>
            <entry>format</entry>
            <entry><literal>rhs.formatted</literal></entry>
            <entry></entry>
            <entry><literal>Format</literal></entry>
            <entry><literal>String</literal></entry>
        </row>
        -->
    
        <row><entry namest="first" nameend="last"><emphasis>Compound invocation assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs.=member</literal></entry>
            <entry>follow</entry>
            <entry><literal>lhs:=lhs.member</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Attribute &lt;X,X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>

        <row>
            <entry><literal>lhs.=member(x,y,z)</literal></entry>
            <entry>apply</entry>
            <entry><literal>lhs:=lhs.member(x,y,z)</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Method &lt;X,X,P..&gt;</literal>,
            together with arguments <literal>P...</literal></entry>
            <entry><literal>X</literal></entry>
        </row>

     </tbody>
    </tgroup>
    </table>
        
        <comment><para>TODO: are we really going to add the <literal>.=</literal> operator?</para></comment>
        
        <!--
        <para>Member specification uses one of three different member specification operators:
        <literal>.</literal>, <literal>.?</literal> or <literal>.*</literal>.</para>
        
        <para>The member specification operator depends upon the type of the receiver expression. 
        If <literal>X</literal> is the type that declares the member, the invocation operator must 
        be:</para>
            
        <itemizedlist>
            <listitem>
                <para><literal>.</literal> if the expression is of type <literal>X</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>.?</literal> if the expression is of type <literal>X?</literal>,
                or</para>
            </listitem>
            <listitem>
                <para><literal>.*</literal> if the expression is of type <literal>Iterable&lt;X&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
                
        <para>The type of an invocation (argument specification) expression depends upon the type of 
        the receiver expression:</para>
            
        <itemizedlist>
            <listitem>
                <para><literal>T</literal> if the receiver expression is of type 
                <literal>Callable&lt;T&gt;</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>T?</literal> if the expression is of type 
                <literal>Callable&lt;T&gt;?</literal>,
                or</para>
            </listitem>
            <listitem>
                <para><literal>Sequence&lt;T&gt;</literal> if the expression is of type 
                <literal>Iterable&lt;Callable&lt;T&gt;&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>The arguments specified in the argument specification must be assignable to the
        parameters of the method reference.</para>
        -->
        
    </section>
        
    <section id="equalitycomparison">
    <title>Equality and comparison operators</title>
    
        <para>These operators compare values for equality, order, magnitude, or membership,
        producing boolean values.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Equality and identity</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs &identical; rhs</literal></entry>
            <entry>identical</entry>
            <entry><literal>identical(lhs,rhs)</literal></entry>
            <entry><literal>IdentifiableObject</literal></entry>
            <entry><literal>IdentifiableObject</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &equals; rhs</literal></entry>
            <entry>equal</entry>
            <entry><literal>lhs.equals(rhs)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs != rhs</literal></entry>
            <entry>not equal</entry>
            <entry><literal>!lhs.equals(rhs)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Comparison</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs &lt;=&gt; rhs</literal></entry>
            <entry>compare</entry>
            <entry><literal>lhs.compare(rhs)</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Comparison</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &lt; rhs</literal></entry>
            <entry>smaller</entry>
            <entry><literal>lhs.compare(rhs)==smaller</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &gt; rhs</literal></entry>
            <entry>larger</entry>
            <entry><literal>lhs.compare(rhs)==larger</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &lt;= rhs</literal></entry>
            <entry>small as</entry>
            <entry><literal>lhs.compare(rhs)!=larger</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &gt;= rhs</literal></entry>
            <entry>large as</entry>
            <entry><literal>lhs.compare(rhs)!=smaller</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Containment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs in rhs</literal></entry>
            <entry>in</entry>
            <entry><literal>let x=lhs in rhs.contains(x)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Category</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Assignability</emphasis></entry></row>
        
        <row>
            <entry><literal>is Type rhs</literal></entry>
            <entry>is</entry>
            <entry></entry>
            <entry>any literal type <literal>T</literal></entry>
            <entry>any type which is not a subtype of 
            <literal>T</literal>, whose intersection with 
            <literal>T</literal> is not <literal>Bottom</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Inheritance</emphasis></entry></row>
        
        <!--
        <row>
            <entry><literal>lhs extends rhs</literal></entry>
            <entry>extends</entry>
            <entry></entry>
            <entry><literal>Type&lt;Void&gt;</literal></entry>
            <entry><literal>Class &lt;Void&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        -->
        
        <row>
            <entry><literal>satisfies Type rhs</literal></entry>
            <entry>satisfies</entry>
            <entry></entry>
            <entry>literal <literal>Type&lt;Void&gt;</literal></entry>
            <entry><literal>Type&lt;Void&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
        <comment><para>TODO: Should we have allow the operators <literal>&lt;=</literal> 
        and <literal>&gt;=</literal> to handle partial orders? A particular usecase is
        <literal>Set</literal> comparison.</para></comment>
        
    </section>
                
    <section id="logical">
    <title>Logical operators</title>
    
        <para>These are the usual logical operations for boolean values.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Logical operators</emphasis></entry></row>
        
        <row>
            <entry><literal>!rhs</literal></entry>
            <entry>not</entry>
            <entry><literal>if (rhs) false else true</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs || rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else rhs</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &amp;&amp; rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) rhs else false</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Logical assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs ||= rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else lhs:=rhs</literal></entry>
            <entry><literal>Settable &lt;Boolean&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row>
            <entry><literal>lhs &amp;&amp;= rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) lhs:=rhs else false</literal></entry>
            <entry><literal>Settable &lt;Boolean&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="nullvalues">
    <title>Operators for handling null values</title>
    
        <para>These operators make it easy to work with optional expressions.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Existence</emphasis></entry></row>
        
        <row>
            <entry><!--<<literal>lhs?</literal> or --><literal>exists lhs</literal></entry>
            <entry>exists</entry>
            <entry><literal>if (exists lhs) true else false</literal></entry>
            <entry>any type to which <literal>null</literal> is
            assignable, whose intersection with <literal>Object</literal>
            is not <literal>Bottom</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal><!--??-->nonempty lhs</literal></entry>
            <entry>nonempty</entry>
            <entry><literal>if (nonempty lhs) true else false</literal></entry>
            <entry>any subtype of <literal>Nothing|FixedSized&lt;Void&gt;</literal>
            whose intersection with <literal>None&lt;Bottom&gt;</literal> 
            is not <literal>Bottom</literal>, and whose intersection with 
            <literal>Some&lt;Bottom&gt;</literal> is not 
            <literal>Bottom</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Default</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs ? rhs</literal></entry>
            <entry>default</entry>
            <entry><literal>if (exists lhs) lhs else rhs</literal></entry>
            <entry><literal>U</literal> such that <literal>null is U</literal></entry>
            <entry><literal>V</literal></entry>
            <entry><literal>U&amp;Object|V</literal></entry>
        </row>
       
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Default assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs ?= rhs</literal></entry>
            <entry>default assignment</entry>
            <entry><literal>if (exists lhs) lhs else lhs:=rhs</literal></entry>
            <entry><literal>Settable&lt;T?&gt;</literal></entry>
            <entry><literal>T</literal> or <literal>T?</literal></entry>
            <entry><literal>T</literal> or <literal>T?</literal></entry>
        </row>
        -->
        
        <row><entry namest="first" nameend="last"><emphasis>Nullsafe invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs?.member</literal></entry>
            <entry>nullsafe attribute</entry>
            <entry><literal>if (exists lhs) lhs.member else null</literal></entry>
            <entry><literal>X?</literal></entry>
            <entry><literal>Attribute &lt;X,T&gt;</literal></entry>
            <entry><literal>T?</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs?.member</literal></entry>
            <entry>nullsafe method</entry>
            <entry></entry>
            <entry><literal>X?</literal></entry>
            <entry><literal>Method &lt;X,T,P...&gt;</literal></entry>
            <entry><literal>Callable &lt;T?,P...&gt;</literal></entry>
        </row>
        
        <!--row>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs{a=x;b=y;}</literal></entry>
            <entry>nullsafe invoke</entry>
            <entry><literal>if (exists lhs) lhs(x,y,z) else null</literal></entry>
            <entry><literal>Callable &lt;T,P...&gt;?</literal></entry>
            <entry><literal>P...</literal></entry>
            <entry><literal>T?</literal></entry>
        </row-->
        
    </tbody>
    </tgroup>
    </table>
    
    </section>

    <section id="listmap">
    <title>Correspondence and sequence operators</title>
    
        <para>These operators provide a simplified syntax for accessing values 
        of a <literal>Correspondence</literal>, and for joining and obtaining
        subranges of <literal>Sequence</literal>s.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Keyed item access</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs[index]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.item(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Gettable &lt;Y?&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[index]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.item(index)</literal></entry>
            <entry><literal>OpenCorrespondence &lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Settable &lt;Y?&gt;</literal></entry>
        </row>
        <!--
        <row>
            <entry><literal>lhs[index]</literal></entry>
            <entry>bounded lookup</entry>
            <entry><literal>lhs.item(index)</literal></entry>
            <entry><literal>Y[n]</literal></entry>
            <entry><literal>Bound&lt;#n&gt;</literal></entry>
            <entry><literal>Gettable &lt;Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[index]</literal></entry>
            <entry>bounded lookup</entry>
            <entry><literal>lhs.item(index)</literal></entry>
            <entry><literal>OpenBoundedSequence &lt;Y,n&gt;</literal></entry>
            <entry><literal>Bound&lt;#n&gt;</literal></entry>
            <entry><literal>Settable &lt;Y&gt;</literal></entry>
        </row>
        -->
        <row>
            <entry><literal>lhs?[index]</literal></entry>
            <entry>nullsafe lookup</entry>
            <entry><literal>if (exists lhs) lhs[index] else null</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;?</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Y?</literal></entry>
        </row>
        
        <!--
        <row>
            <entry><literal>lhs[indices]</literal></entry>
            <entry>sequenced lookup</entry>
            <entry><literal>lhs.items(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>Y[]</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[indices]</literal></entry>
            <entry>iterated lookup</entry>
            <entry><literal>lhs.items(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>Iterable &lt;X&gt;</literal></entry>
            <entry><literal>Iterable &lt;Y&gt;</literal></entry>
        </row>
        -->
        
        <row><entry namest="first" nameend="last"><emphasis>Spans</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs[from..to]</literal></entry>
            <entry>span</entry>
            <entry><literal>lhs.span(from,to)</literal></entry>
            <entry><literal>Ranged&lt;X,Y&gt;</literal></entry>
            <entry>Two <literal>X</literal> values</entry>
            <entry><literal>Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[from...]</literal></entry>
            <entry>upper span</entry>
            <entry><literal>lhs.span(from)</literal></entry>
            <entry><literal>Ranged&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Y</literal></entry>
        </row>
        <!--
        <row>
            <entry><literal>lhs[...y]</literal></entry>
            <entry>lower range</entry>
            <entry><literal>lhs.range(0,y)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        -->
        
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Sequence concatenation</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>join</entry>
            <entry><literal>join(lhs, rhs)</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>X[]</literal></entry>
        </row>
        -->
        
        <row><entry namest="first" nameend="last"><emphasis>Spread invocation</emphasis></entry></row>

        <row>
            <entry><literal>lhs[].member</literal></entry>
            <entry>spread attribute</entry>
            <entry><literal>{ for (X x in lhs) x.member }</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>Attribute&lt;X,T&gt;</literal></entry>
            <entry><literal>T[]</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs[].member</literal></entry>
            <entry>spread method</entry>
            <entry></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>Method &lt;X,T,P...&gt;</literal></entry>
            <entry><literal>Callable &lt;T[],P...&gt;</literal></entry>
        </row>
        
        <!--row>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs{a=x;b=y;}</literal></entry>
            <entry>spread invoke</entry>
            <entry><literal>{ for (C c in lhs) c(x,y,z) }</literal></entry>
            <entry><literal>Callable &lt;T,P...&gt;[]</literal></entry>
            <entry><literal>P...</literal></entry>
            <entry><literal>T[]</literal></entry>
        </row-->
        <!--  
        
        <row><entry namest="first" nameend="last"><emphasis>Shift</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs &lt;&lt; rhs</literal></entry>
            <entry>left shift</entry>
            <entry><literal>lhs.shiftLeft(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs >> rhs</literal></entry>
            <entry>right shift</entry>
            <entry><literal>lhs.shiftRight(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        
        -->
        
        <!--
        <row>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>cartesian product</entry>
            <entry><literal>lhs.product(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;Pair&lt;X,Y&gt;&gt;</literal></entry>
        </row>
        -->
        
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: Should <literal>x[i..j]</literal> return the elements
    from <literal>i</literal> to <literal>j-1</literal>, like in most other
    languages?</para></comment>
    
    <comment><para>TODO: I'm increasingly warming to the idea of a non-destructive 
    add ("with") operator <literal>@</literal> and <literal>@=</literal>. This is
    an operation that is very efficient for some kinds of data structures (linked lists, 
    etc).</para></comment>
    
    </section>
    
    <section id="constructors">
    <title>Operators for creating objects</title>
    
        <para>These operators simplify the syntax for creating certain commonly 
        used built-in types.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Range and entry constructors</emphasis></entry></row>

        <row>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>range</entry>
            <entry><literal>Range(lhs, rhs)</literal></entry>
            <entry><literal>T given T satisfies Ordinal &amp; Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Range&lt;T&gt;</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs -> rhs</literal></entry>
            <entry>entry</entry>
            <entry><literal>Entry(lhs, rhs)</literal></entry>
            <entry><literal>U given U satisfies Object</literal></entry>
            <entry><literal>V given V satisfies Object</literal></entry>
            <entry><literal>Entry&lt;U,V&gt;</literal></entry>
        </row>
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Datetime and interval constructors</emphasis></entry></row>

        <row>
            <entry><literal>lhs @ rhs</literal></entry>
            <entry>datetime</entry>
            <entry><literal>Datetime(lhs, rhs)</literal></entry>
            <entry><literal>Date</literal></entry>
            <entry><literal>Time</literal></entry>
            <entry><literal>Datetime</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>interval</entry>
            <entry><literal>Interval(lhs, rhs)</literal></entry>
            <entry><literal>T given T satisfies Instant</literal></entry>
            <entry><literal>Instant&lt;T&gt;</literal></entry>
            <entry><literal>Interval&lt;T&gt;</literal></entry>
        </row>
        
        -->
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="conditionals">
    <title>Conditional operators</title>
    
        <para>Two special operators allow emulation of the famous ternary
        operator of C-like languages.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Conditionals</emphasis></entry></row>

        <row>
            <entry><literal>lhs then rhs</literal></entry>
            <entry>then</entry>
            <entry><literal>if (lhs) then rhs else null</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>T given T satisfies Object</literal></entry>
            <entry><literal>T?</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs else rhs</literal></entry>
            <entry>else</entry>
            <entry><literal>if (exists lhs) then lhs else rhs</literal></entry>
            <entry><literal>U</literal> such that <literal>null is U</literal></entry>
            <entry><literal>V</literal></entry>
            <entry><literal>U&amp;Object|V</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="arithmetic">
    <title>Arithmetic operators</title>
    
        <para>These are the usual mathematical operations for all kinds of
        numeric values.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Increment, decrement</emphasis></entry></row>
        
        <!-- Prefix increment, decrement -->
        
        <row>
            <entry><literal>++rhs</literal></entry>
            <entry>successor</entry>
            <entry><literal>rhs:=rhs.successor</literal></entry>
            <entry></entry>
            <entry><literal>Settable &lt;Ordinal&lt;T&gt;&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>--rhs</literal></entry>
            <entry>predecessor</entry>
            <entry><literal>rhs:=rhs.predecessor</literal></entry>
            <entry></entry>
            <entry><literal>Settable &lt;Ordinal&lt;T&gt;&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <!-- Postfix increment, decrement -->
        
        <row>
            <entry><literal>lhs++</literal></entry>
            <entry>increment</entry>
            <entry><literal>(++lhs).predecessor</literal></entry>
            <entry><literal>Settable &lt;Ordinal&lt;T&gt;&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>lhs--</literal></entry>
            <entry>decrement</entry>
            <entry><literal>(--lhs).successor</literal></entry>
            <entry><literal>Settable &lt;Ordinal&lt;T&gt;&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric operators</emphasis></entry></row>
        
        <!-- Unary positive and negative -->
        
        <row>
            <entry><literal>+rhs</literal></entry>
            <entry></entry>
            <entry><literal>rhs.positiveValue</literal></entry>
            <entry></entry>
            <entry><literal>Invertable &lt;I&gt;</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        
        <row>
            <entry><literal>-rhs</literal></entry>
            <entry>negation</entry>
            <entry><literal>rhs.negativeValue</literal></entry>
            <entry></entry>
            <entry><literal>Invertable &lt;I&gt;</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        
        <!-- Numeric -->
        
        <row>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>sum</entry>
            <entry><literal>lhs.castTo&lt;N&gt;() .plus(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>X satisfies Castable&lt;N&gt; &amp; Summable&lt;X&gt;</literal></entry>
            <entry><literal>Y satisfies Castable&lt;N&gt; &amp; Summable&lt;Y&gt;</literal></entry>
            <entry><literal>N of X|Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>difference</entry>
            <entry><literal>lhs.castTo&lt;N&gt;() .minus(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>X satisfies Castable&lt;N&gt; &amp; Subtractable&lt;X,I&gt;</literal></entry>
            <entry><literal>Y satisfies Castable&lt;N&gt; &amp; Subtractable&lt;Y,J&gt;</literal></entry>
            <entry><literal>N of I|J</literal></entry>
        </row>
        <row>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>product</entry>
            <entry><literal>lhs.castTo&lt;N&gt;() .times(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>X satisfies Castable&lt;N&gt; &amp; Numeric&lt;X&gt;</literal></entry>
            <entry><literal>Y satisfies Castable&lt;N&gt; &amp; Numeric&lt;Y&gt;</literal></entry>
            <entry><literal>N of X|Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>quotient</entry>
            <entry><literal>lhs.castTo&lt;N&gt;() .divided(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>X satisfies Castable&lt;N&gt; &amp; Numeric&lt;X&gt;</literal></entry>
            <entry><literal>Y satisfies Castable&lt;N&gt; &amp; Numeric&lt;Y&gt;</literal></entry>
            <entry><literal>N of X|Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs % rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs.castTo&lt;N&gt;() .remainder(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>X satisfies Castable&lt;N&gt; &amp; Integral&lt;X&gt;</literal></entry>
            <entry><literal>Y satisfies Castable&lt;N&gt; &amp; Integral&lt;Y&gt;</literal></entry>
            <entry><literal>N of X|Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ** rhs</literal></entry>
            <entry>power</entry>
            <entry><literal>lhs .power(rhs.castTo&lt;Y&gt;())</literal></entry>
            <entry><literal>Exponentiable&lt;X,Y&gt;</literal></entry>
            <entry><literal>Castable&lt;Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs += rhs</literal></entry>
            <entry>add</entry>
            <entry><literal>lhs:=lhs .plus(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>Settable &lt;Summable&lt;N&gt;&gt;</literal></entry>
            <entry><literal>Castable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs -= rhs</literal></entry>
            <entry>subtract</entry>
            <entry><literal>lhs:=lhs .minus(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>Settable &lt;Subtractable&lt;N,N&gt;&gt;</literal></entry>
            <entry><literal>Castable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs *= rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>lhs:=lhs .times(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>Settable &lt;Numeric&lt;N&gt;&gt;</literal></entry>
            <entry><literal>Castable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs /= rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>lhs:=lhs .divided(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>Settable &lt;Numeric&lt;N&gt;&gt;</literal></entry>
            <entry><literal>Castable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs %= rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs:=lhs .remainder(rhs.castTo&lt;N&gt;())</literal></entry>
            <entry><literal>Settable &lt;Integral&lt;N&gt;&gt;</literal></entry>
            <entry><literal>Castable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Duration arithmetic</emphasis></entry></row>
                
        <row>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>extend</entry>
            <entry><literal>lhs.extend(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>curtail</entry>
            <entry><literal>lhs.curtail(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>lhs.times(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>lhs.divide(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        -->
                
    </tbody>
    </tgroup>
    </table>
    
        <!--
        <para>Built-in converters allow for type promotion of numeric values used in 
        expressions. Converters exist for the following numeric types:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>Integer</literal> to <literal>Integer</literal>,
                <literal>Float</literal>, <literal>Whole</literal> and 
                <literal>Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>Integer</literal> to <literal>Float</literal>,
                <literal>Whole</literal> and <literal>Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>Float</literal> to <literal>Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>Whole</literal> to <literal>Decimal</literal></para>
            </listitem>
        </itemizedlist>
        
        <para>This means that <literal>x + y</literal> is defined for any combination 
        of numeric types <literal>X</literal> and <literal>Y</literal>, except for 
        the combination <literal>Float</literal> and <literal>Whole</literal>, and that
        <literal>x + y</literal> always produces the same value, with the same type, as
        <literal>y + x</literal>.</para>
        -->
        
        <para>Ceylon's numeric type system is designed to accommodate the following
        considerations:</para>
        
        <itemizedlist>
            <listitem>
                <para>The system is extensible and new numeric types may be defined
                by libraries. Numeric types defined by libraries should work the 
                same as built-in numeric types.</para>
            </listitem>
            <listitem>
                <para>Two values of different numeric types should be combinable
                using operators without the need for explicit type conversions, 
                but</para>
            </listitem>
            <listitem>
                <para>implicit type conversions should never lose information
                and</para>
            </listitem>
            <listitem>
                <para>binary operators must be symmetric.</para>
            </listitem>
            <listitem>
                <para>Furthermore, there should be no special cases in the language 
                definition or type checker to accommodate numeric types.</para>
            </listitem>
            <listitem>
                <para>However, it must be possible for the compiler to optimize 
                certain of the built-in numeric types to take advantage of the VM's 
                native support for numeric types.</para>
            </listitem>
            <listitem>
                <para>It is not necessary to encode information about the limits
                of the machine's representation of a numeric value into the type
                system. A single <literal>Integer</literal> class is sufficient
                to represent 32, 64, or 128 bit integer values. A single 
                <literal>Float</literal> class is sufficient to represent single
                and double precision floating point values. It is simply not
                possible for the compiler to detect numeric overflow or loss of
                significant precision.</para>
            </listitem>
        </itemizedlist>
        
    </section>
    
    <section id="sets">
    <title>Set operators</title>
    
        <!--
        <para>The C-style bitwise operators are generalized to apply to other types that 
        are formed from boolean-valued "slots". The interface <literal>Slots</literal> 
        defines the necessary abstraction.</para>
        
        <itemizedlist>
            <listitem>
                <para>The class <literal>Byte</literal> represents a fixed length bit string. 
                In this case, the operators are the standard bitwise operators from other 
                C-like languages.</para>
            </listitem>
            <listitem>
                <para>A <literal>Boolean</literal> can be seen as a bit string of length 
                one, so these operators also apply to <literal>Boolean</literal> values.</para>
            </listitem>
            <listitem>
                <para>A <literal>Set&lt;T&gt;</literal>, together with the <literal>in</literal> 
                operator, may also be viewed in terms of slots, so the operators apply to 
                <literal>Set</literal>s, where <literal>|</literal>, <literal>&amp;</literal>
                and binary <literal>~</literal> are interpreted as set union, intersection 
                and complement operators.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that in Ceylon these operators have a higher precedence than they have 
        in C or Java. Note also that the built-in numeric types are not bit strings, so 
        explicit conversion to <literal>Bits&lt;#n&gt;</literal> is required before these 
        operators may be applied to a numeric value.</para>
        -->
    
    <para>These operators provide traditional mathematical operations for sets.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Set operators</emphasis></entry></row>
        
        <!--
        <row>
            <entry><literal>~rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>rhs.complement</literal></entry>
            <entry></entry>
            <entry><literal>FixedSlots&lt;B&gt;</literal></entry>
            <entry><literal>B</literal></entry>
        </row>
        -->
        <row>
            <entry><literal>lhs | rhs</literal></entry>
            <entry>union</entry>
            <entry><literal>lhs.union(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;X|Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &amp; rhs</literal></entry>
            <entry>intersection</entry>
            <entry><literal>lhs.intersection(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;X&amp;Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ^ rhs</literal></entry>
            <entry>exclusive union</entry>
            <entry><literal>lhs.exclusiveUnion(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;X|Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ~ rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>lhs.complement(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Object&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>

        
        <row><entry namest="first" nameend="last"><emphasis>Set assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs |= rhs</literal></entry>
            <entry>union</entry>
            <entry><literal>lhs:=lhs|rhs</literal></entry>
            <entry><literal>Settable &lt;Set&lt;X&gt;&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &amp;= rhs</literal></entry>
            <entry>intersection</entry>
            <entry><literal>lhs:=lhs&amp;rhs</literal></entry>
            <entry><literal>Settable &lt;Set&lt;X&gt;&gt;</literal></entry>
            <entry><literal>Set&lt;Object&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ^= rhs</literal></entry>
            <entry>exclusive union</entry>
            <entry><literal>lhs:=lhs^rhs</literal></entry>
            <entry><literal>Settable &lt;Set&lt;X&gt;&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ~= rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>lhs:=lhs~rhs</literal></entry>
            <entry><literal>Settable &lt;Set&lt;X&gt;&gt;</literal></entry>
            <entry><literal>Set&lt;Object&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
        <comment><para>TODO: how can we support the traditional C-style bitwise operators? 
        Abstracting over sets and binary strings is difficult without type constructor 
        parameterization.</para></comment>
    
    </section>
    
    </section>
    
</chapter>
