<chapter id="expressions">
    <title>Expressions</title>
    
    <para>Ceylon expressions are significantly more flexible than Java, allowing a 
    more declarative style of programming.</para>
    
    <para>Expressions are formed from:</para>
    
    <itemizedlist>
        <listitem>
            <para>literal values, special values, and metamodel references,</para>
        </listitem>
        <!--
        <listitem>
            <para>enumerated instance references,</para>
        </listitem>
        -->
        <listitem>
            <para>callable references,</para>
        </listitem>
        <listitem>
            <para>invocation of methods and instantiation of classes,</para> 
        </listitem>
        <listitem>
            <para>evaluation and assignment of attributes, and</para>
        </listitem>
        <!--listitem>
            <para>enumeration of sequences, and</para>
        </listitem-->
        <listitem>
            <para>operators.</para>
        </listitem>
    </itemizedlist>
    
    <para>Ceylon expressions are validated for typesafety at compile time. To 
    determine whether an expression is assignable to a program element such as 
    an attribute, local, or parameter, Ceylon considers the 
    <emphasis>type</emphasis> of the expression (the type of the objects that 
    are produced when the expression is evaluated). An expression is assignable 
    to a program element if the type of the expression is assignable to the 
    declared type of the program element.</para>
    
    <comment><para>TODO: Do we need a definition of "constant expression"? 
    We might use it for:</para>
    <itemizedlist>
    <listitem><literal>case</literal> expressions (when are these evaluated?),</listitem>
    <listitem>annotations available at compile time,</listitem>
    <listitem>default parameter values (when are these evaluated?), and</listitem>
    <listitem>initializer/specifier expressions in second part of class body.</listitem>
    </itemizedlist>
    <para>For example, a constant expression might be anything formed from
    literals, metamodel references, the <literal>..</literal> and 
    <literal>-></literal> operators.</para>
    </comment>
    
    <comment><para>TODO: Or, if not, we at least need to properly define the scope
    in which the above things are actually evaluated.</para></comment>
    
    <section id="objectinstancesidentity">
        <title>Object instances, identity, and reference passing</title>
        
        <para>An <emphasis>object</emphasis> is a unique identifier, together with a 
        reference to a class, and a value for each simple attribute of the class 
        (including inherited simple attributes). The object is said to be an 
        <emphasis>instance</emphasis> of the class.</para>
        
        <para>A <emphasis>value</emphasis> is a reference to an object (a copy of its 
        unique identifier). At a particular point in the execution of the program, 
        every attribute of every object that exists, and every initialized local of 
        every method or initializer that is currently executing has a value. 
        Furthermore, every time an expression is executed, it produces a value.</para>
        
        <para>Two values are said to be <emphasis>identical</emphasis> if they are
        references to the same object&mdash;if they hold the same unique identifier. The 
        program may determine if two values of type <literal>IdentifiableObject</literal> 
        are identical using the <literal>&identical;</literal> operator. It may not 
        directly obtain the unique identifier (which is a purely abstract construct). The 
        program has no way of determining the identity of a value which is not of type 
        <literal>IdentifiableObject</literal>.</para>
        
        <para>Invocation of a method or class initializer results in execution of the 
        method with parameter values that are copies of the value produced by executing 
        the argument expressions of the invocation, and a reference to the receiving 
        instance that is a copy of the value produced by executing the receiver expression. 
        The value produced by the invocation expression is a copy of the value produced by 
        execution of the <literal>return</literal> directive expression.</para>
        
        <programlisting>Person myself(Person me) { return me; }
Person p = ...;
assert() that (myself(p)&identical;p); //assertion never fails</programlisting>

        <programlisting>Semaphore s = Semaphore();
this.semaphore = s;
assert() that (semaphore&identical;s); //assertion never fails</programlisting>
        
        <para>A new object is produced by execution of a class instantiation expression.
        The Ceylon compiler guarantees that if execution of a class initializer terminates
        with no uncaught exception, then every simple attribute of the object has been
        initialized. The value of an non-<literal>variable</literal> simple attribute or 
        local is initialized for the first time by execution of a specifier. Every class 
        instantiation expression results in an object with a new unique identifier shared 
        by no other existing object. The object exists from the point at which execution 
        of its initializer terminates. <emphasis>Conceptually</emphasis>, the object exists 
        until execution of the program terminates.</para>
        
        <para>In practice, the object exists at least until the point at which it is not 
        reachable by recursively following references from a local in a method or
        initializer currently being executed, or from an expression in a statement 
        currently being executed. At this point, its simple attribute values are no 
        longer accessible to expressions which subsequently execute and the object may 
        be destroyed by the virtual machine. There is no way for the program to determine
        that an object has been destroyed by the virtual machine (unlike Java, Ceylon
        does not provide object finalizers).</para>
        
        <para>A a special exception to the rules defined above:</para>
        
        <itemizedlist>
        <listitem>
            <para>The compiler is permitted to emit bytecode that unexpectedly creates or
            avoids creating an actual instance of <literal>Gettable</literal> or 
            <literal>Settable</literal>, when an expression is evaluated, as long as this 
            does not affect the observable behavior of the program.</para>
        </listitem>
        <listitem>
            <para>The compiler is permitted to emit bytecode that produces a new instance of 
            certain types in the module <literal>ceylon.language</literal> without execution of 
            the initializer of the class, whenever any expression is evaluated. These types are:
            any of the the built-in numeric types, <!-- of <literal>Bits&lt;#n&gt;</literal>,
            <literal>Bounded&lt;#n&gt;</literal>,--> <literal>Character</literal>, 
            <literal>Range</literal>, <literal>Entry</literal>, and <literal>String</literal>. 
            Furthermore, it is permitted to use such a newly-produced instance as the value of 
            the expression, as long as the newly-produced instance is equal to the value expected 
            according to the rules above, as determined using the <literal>==</literal> operator.</para>
        </listitem>
        </itemizedlist>
        
        <para>Therefore, the types listed above directly extend <literal>Object</literal> or
        <literal>Void</literal> instead of <literal>IdentifiableObject</literal>.</para>
                
        <para>The execution of a Ceylon program complies with the rules laid out by the Java 
        programming language's execution model (Chapter 17 of the Java Language Specification).
        Ceylon attributes and locals are considered <emphasis>variables</emphasis> in the 
        sense of the JLS. Evaluation is considered a <emphasis>use</emphasis> operation, 
        and assignment is considered an <emphasis>assign</emphasis> operation, again in 
        terms of the JLS.</para>
        
    </section>
    
    <section id="lazyevaluation">
        <title>Lazy evaluation</title>
        
        <comment><para>NOTE: Lazy evaluation of expressions is a proposed feature for 
        a future version of the language.</para></comment>
        
        <para>Ceylon supports <emphasis>lazy evaluation</emphasis> of expressions.
        Conceptually, what triggers evaluation of an expression is not execution
        of the expression itself, but use of the expression in a context where its 
        value is required.</para>
        
        <para>The first statement of this code fragment causes immediate evaluation 
        of the expression <literal>calculatePi()</literal>:</para>
        
        <programlisting>Float pi = calculatePi();
Float area = pi * radius**2;</programlisting>
        
        <para>But in the following code, <literal>calculatePi()</literal> is not
        evaluated until the second statement:</para>
        
        <programlisting>Gettable&lt;Float&gt; pi = calculatePi();
Float area = pi * radius**2;</programlisting>
    
        <para>The type <literal>Gettable&lt;T&gt;</literal> represents a reference
        to a value of type <literal>T</literal> that can be computed if and when
        required.</para>
        
        <para>One application of lazy evaluation is <emphasis>pass by 
        reference</emphasis>. Even <literal>variable</literal> attributes may be 
        passed by reference, as in the following code:</para>
        
        <programlisting>void setGreeting(Settable&lt;String&gt; ref) {
    ref:="Que honda!";
}

shared variable String greeting := "'sup!";
setGreeting(greeting);</programlisting>
        
        <comment><para>TODO: Do we need to say the following:
        A <literal>Gettable</literal> object representing an expression that 
        contains a reference to a <literal>variable</literal> local may not be assigned 
        to an attribute, passed as a method argument, passed to a control directive, 
        or referred to by a nested method or class. It may be assigned to a local, or 
        invoked directly inside the block that obtained it.</para></comment>
    
    </section>
    
    <section id="literalvalues">
        <title>Literal values</title>
    
    <para>Ceylon supports literal values of the following types:</para>
    
    <itemizedlist>
        <listitem>
            <para><literal>Natural</literal> and <literal>Float</literal>,</para>
        </listitem>
        <listitem>
            <para><literal>Character</literal>, and</para>
        </listitem>
        <listitem>
            <para><literal>String</literal>, along with</para>
        </listitem>
        <listitem>
            <para>single quoted literals.</para>
        </listitem>
    </itemizedlist>
    
    <para>The types <literal>Natural</literal>, <literal>Float</literal>, 
    <literal>Character</literal>, and <literal>String</literal> are defined in the 
    module <literal>ceylon.language</literal>.</para>
    
    <para>Ceylon does not need a special syntax for <literal>Boolean</literal> literal 
    values, since <literal>Boolean</literal> is just a class with the cases 
    <literal>true</literal> and <literal>false</literal>. Likewise, <literal>null</literal> 
    is just the singleton value of an anonymous class.</para>
    
    <programlisting>Literal: NaturalLiteral | FloatLiteral | CharacterLiteral | StringLiteral | QuotedLiteral</programlisting>
    
    <para>All literal values are instances of immutable types. The value of a literal 
    expression is an instance of the type. How this instance is produced is not specified 
    here.</para>
    
    <!--section id="datetime">
        <title><literal>Date</literal> and <literal>Time</literal> literals</title>
        
        <para>A <literal>Date</literal> literal has the form:</para>
        
        <programlisting>DateLiteral: 
"'" 
Digit{1,2} "/" Digit{1,2} "/" Digit{4} 
"'"</programlisting>
        
        <para>A <literal>Time</literal> literal has the form:</para>
        
        <programlisting>TimeLiteral: 
"'" 
Digit{1,2} ":" Digit{2} ( ":" Digit{2} ( ":" Digit{3} )? )? 
(" " "AM"|"PM")? 
(" " Character{3,4})? 
"'"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Date date = '25/03/2005';</programlisting>
        <programlisting>Time time = '12:00 AM PST';</programlisting>
        
        <para>A <literal>Datetime</literal> may be composed from a <literal>Date</literal> and 
        a <literal>Time</literal> using the <literal>@</literal> operator.</para>
        
        <programlisting>Datetime datetime = '25/03/2005' @ '12:00 AM PST';</programlisting>
        
        <comment><para>TODO: alternatively, we could follow RFC3339-style datetimes, for example:
        <literal>1996-12-19T16:39:57-08:00</literal>.</para></comment>
        
        <comment><para>TODO: should we allow wildcards and ranges, to get cron-style expressions 
        like <literal>'1/*/*' @ '00:00 GMT'</literal>?</para></comment>
        
        <para>The <literal>..</literal> operator lets us construct intervals:</para>
        
        <programlisting>Interval&lt;Date&gt; timeRange = '0:0:00' .. '12:59:59 PM';</programlisting>
        <programlisting>Interval&lt;Date&gt; dateRange = '1/1/2008' .. '31/12/2007';</programlisting>
        <programlisting>Interval&lt;Datetime&gt; datetimeRange = '1/1/2008' @ '0:0:00' .. '31/12/2007' @ '12:59:59 PM';</programlisting>
        
    </section-->
    
        <!--
        
        <para>The attributes <literal>hours</literal>, <literal>minutes</literal>, <literal>seconds</literal>,
        <literal>years</literal>, <literal>months</literal>, <literal>days</literal>, <literal>weeks</literal>
        of the <literal>Natural</literal> class let us construct durations.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 12.hours + 34.minutes;</programlisting>
        <programlisting>Duration&lt;Date&gt; duration = 1.year + 2.months + 3.days;</programlisting>
        
        <para>Durations may be composed using the arithmetic operators <literal>+</literal>, 
        <literal>-</literal>, <literal>*</literal> and <literal>/</literal>.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 1.seconds / 10 - 1.seconds / 1000;</programlisting> 
        
        <para>The methods <literal>before()</literal> and <literal>after()</literal> let us add and
        subtract durations to and from datetimes.</para>
        
        <programlisting>Time time = 10.seconds.before('12:00 AM');</programlisting>
        <programlisting>Date date = 1.week.after('2/9/1974');</programlisting>
        
        -->
        
    <section id="naturalnumber">
        <title>Natural number literals</title>
        
        <para>A natural number literal <literal>n</literal> is an 
        expression of type <literal>Natural</literal>.</para>
        
        <programlisting>Natural five = 5;</programlisting>
                
        <para><literal>Integer</literal> values can be produced 
        using the unary prefix <literal>+</literal> and 
        <literal>-</literal> operators:</para>
        
        <programlisting>Integer zero = +0;</programlisting>
        <programlisting>Integer i = -1;</programlisting>
        
    </section>
    
    <section id="floatnumber">
        <title>Floating point number literals</title>
        
        <para>A floating point number literal is an expression of 
        type <literal>Float</literal>.</para>
        
        <programlisting>shared Float pi = 3.14159;</programlisting>
        
        <comment><para>TODO: Actually, this is not the best definition,
        since if we assign the literal to <literal>Decimal</literal>,
        we don't want it to go through an intermediate conversion to
        floating point representation.</para></comment>
        
    </section>
    
    <section id="character">
        <title>Character literals</title>
        
        <para>A single character literal is an expression of type 
        <literal>Character</literal>.</para>
                
        <programlisting>if ( string[i] &equals; `+` ) { ... }</programlisting>
        
        <comment><para>TODO: do we really need character literals?</para></comment>
        
    </section>
    
    <section id="string">
        <title>Character string literals</title>
        
        <para>A character string literal is an expression of type
        <literal>String</literal>.</para>
        
        <programlisting>person.name := "Gavin King";</programlisting>
        
        <programlisting>String multiline = "Strings may
span multiple lines
if you prefer.";</programlisting>

        <programlisting>display("Melbourne\tVic\tAustralia\nAtlanta\tGA\tUSA\nGuanajuato\tGto\tMexico\n");</programlisting>
                
    </section>
    
    <section id="quoted">
        <title>Single quoted literals</title>
        
        <para>Single-quoted strings are used to express literal values for dates, 
        times, regexes and hexadecimal numbers, and even for more domain-specific 
        things like names, cron expressions, internet addresses, and phone numbers.
        This is an important facility since Ceylon is a language for expressing 
        structured data.</para>
        
        <!--
        <para>A single quoted literal must be combined with an explicit type 
        annotation to form an expression.</para>
        
        <programlisting>TypedQuotedLiteral: TypeName QuotedLiteral</programlisting>
        
        <para>The type of the expression is the specified type.</para>
                
        <programlisting>Date date = Date '25/03/2005';</programlisting>
        <programlisting>Time time = Time '12:00 AM PST';</programlisting>
        <programlisting>Boolean isEmail = Regex '^\w+@((\w+)\.)+$'.matches(email);</programlisting>
        <programlisting>Cron schedule = Cron '0 0 23 ? * MON-FRI';</programlisting>
        <programlisting>Color color = Color 'FF3B66';</programlisting>
        <programlisting>Url url = Url 'http://jboss.org/ceylon';</programlisting>
        <programlisting>mail.to := Email 'gavin@hibernate.org';</programlisting>
        <programlisting>Phone ph = Phone '+1 (404) 129 3456';</programlisting>
        <programlisting>Duration duration = Duration '1h 30m';</programlisting>
        -->
        
        <programlisting>Regex regex = '^\w+@((\w+)\.)+$';</programlisting>
        <programlisting>ph = '+1 (404) 129 3456';</programlisting>
        <programlisting>Duration duration = '1h 30m';</programlisting>
        <programlisting>Datetime dt = Datetime('25/03/2005', '12:00 AM PST');</programlisting>
        <programlisting>Timer { schedule = '0 0 23 ? * MON-FRI'; onTimeout=purge; }.start();</programlisting>
        <programlisting>Text { color = 'FF3B66'; "Hello World!" }</programlisting>
        <programlisting>Link { url = 'http://jboss.org/ceylon'; "Powered by Ceylon" }</programlisting>
        <programlisting>Email { to = 'gavin@hibernate.org'; subject="Ceylon"; text = "Need some help with the compiler?"; }</programlisting>
        
        <para>A single quoted literal may only appear in the following positions:</para>
        
        <itemizedlist>
            <listitem>
                <para>as the right hand side of a specifier for a local or
                attribute with an explicitly declared type, or</para>
            </listitem>
            <listitem>
                <para>as an argument of an invocation or instantiation.</para>
            </listitem>
        </itemizedlist>
        
        <para>In either case:</para>
        
        <itemizedlist>
            <listitem>
                <para>the declared type of the local, attribute, or parameter 
                must be a class or interface annotated <literal>literal</literal>,
                and</para>
            </listitem>
            <listitem>
                <para>the single quoted literal must match the pattern specified
                by the <literal>format</literal> argument of the 
                <literal>literal</literal> annotation.</para>
            </listitem>
        </itemizedlist>
        
        <para>The type of the literal expression is the declared type of the
        local, attribute, or parameter. At runtime, an instance of this type
        is produced by calling the method specified by the <literal>parser</literal>
        argument of the <literal>literal</literal> annotation.</para>
        
        <programlisting>Color parseColor(String literal) { ... }

literal { 
    format = '[0-9A-F]{6}|red|blue|green|yellow|black|white'; 
    parser = parseColor;
}
shared interface Color { ... }</programlisting>
        
        <comment><para>TODO: Single quoted operator literals should come built-in.
        For example: <literal>'+'</literal> and <literal>'&lt;='</literal>.</para></comment>
        
        <comment><para>TODO: we should try to support interpolated expressions, 
        just like we do for string literals.</para></comment>
        
    </section>

    </section>

    <section id="stringtemplates">
        <title>String templates</title>
        
        <para>A character string <emphasis>template</emphasis> contains interpolated 
        expressions, surrounded by character string fragments.</para>
        
        <programlisting>StringTemplate: StringLiteral (Expression StringLiteral)+</programlisting>
        
        <para>Each interpolated expression contained in the string template must be 
        have a type assignable to the interface <literal>Format</literal> defined in 
        <literal>ceylon.language</literal>.</para>
        
        <para>The entire character string template is an expression of type 
        <literal>Gettable&lt;String&gt;</literal>.</para>
        
        <programlisting>log.info("Hello, " person.firstName " " person.lastName ", the time is " Time() ".");</programlisting>
        
        <programlisting>log.info("1 + 1 = " 1 + 1 "");</programlisting>
        
        <para>An interpolated expression in a string template may invoke or evaluate:</para>
        
        <itemizedlist>
            <listitem>
                <para>any class member that is visible to the containing scope in 
                which the literal appears, and</para>
            </listitem>
            <listitem>
                <para>any non-<literal>variable</literal> local, block local attribute 
                getter or block local method declared earlier within the containing 
                scope.</para>
            </listitem>
        </itemizedlist>
        
        <para>Interpolated expressions are evaluated when the 
        <literal>Gettable&lt;String&gt;</literal> is evaluated to produce a constant 
        character string.</para>

        <comment><para>TODO: Is there a good reason to add the following limitation: 
        an interpolated expression in a string template may not refer to 
        <literal>variable</literal> locals from the containing scope.</para></comment>
        
    </section>
    
    <section id="selfreferences">
        <title>Self references</title>
        
        <para>The type of the following special values depends upon the context 
        in which they appear.</para>
        
        <programlisting>SelfReference: "this" | "super" | "outer"</programlisting>
        
        <section>
            <title><literal>super</literal></title>
            
        <para>The keyword <literal>super</literal> refers to the current instance 
        (the instance that is being invoked), and has the same members as the 
        immediate superclass of the class, except for <literal>definite</literal> 
        members. Any invocation of this reference is processed by the method or 
        attribute defined or inherited by this superclass, bypassing any method 
        declaration that refines the method on the current class or any subclass 
        of the current class. Invocation of <literal>definite</literal> members upon 
        <literal>super</literal> is not allowed. The <literal>super</literal> 
        reference is not assignable to any type. There is no <literal>super</literal>
        reference in an interface member body. <emphasis>(Note that 
        <literal>definite</literal> is a proposed feature for a future version of the 
        language.)</emphasis></para>
        
        <comment><para>TODO: <literal>super</literal> doesn't let you call a refined
        member belonging to an interface. A solution would be to let you rename 
        the refined member in an <literal>import</literal> statement. Another
        possibility would be to introduce a specialized syntax, for example something
        like <literal>super(Writer).write(string)</literal>.</para></comment>
        
        </section>
        
        <section>
            <title><literal>this</literal></title>
            
        <para>The keyword <literal>this</literal> refers to the current instance, 
        and is assignable to both the type of the current class or interface (the 
        class or interface in which the expression appears), and to the special 
        type <literal>subtype</literal>, which represents the concrete type of the 
        current instance.</para>
        
        </section>
        
        <section>
            <title><literal>outer</literal></title>
            
        <para>The keyword <literal>outer</literal> refers to the current instance
        of the class or interface which immediately contains the current class or 
        interface and is assignable to the type of this containing class or 
        interface.</para>
        
        </section>
                
    </section>
    
    <section id="compoundexpressions">
        <title>Compound expressions</title>

        <para>An <emphasis>atom</emphasis> is a literal or self reference, an 
        enumeration expression, or a parenthesized expression.</para>
    
        <programlisting>Atom: Literal | StringTemplate | SelfReference | ParExpression</programlisting>
    
        <para>A <emphasis>primary</emphasis> is formed by recursively invoking or 
        evaluating members of an atom, toplevel method, toplevel attribute, or
        class.</para>
    
        <programlisting>Primary: Atom | Meta | MemberReference | Invocation</programlisting>

        <programlisting>MemberReference: CallableReference | ValueReference</programlisting>
    
        <para>More complex expressions are formed by combining expressions using 
        operators, including assignment operators.</para>    
    
        <programlisting>Expression: Primary | OperatorExpression</programlisting>
    
        <para>Parentheses are used for grouping:</para>
    
        <programlisting>ParExpression: "(" Expression ")"</programlisting>
    
    <section id="receiverexpressions">
        <title>Receiver expressions</title>
        
        <para>A callable reference or value reference may specify a <emphasis>receiver 
        expression</emphasis>. The receiver expression produces the instance upon which 
        a member is invoked or evaluated. The type of the receiver expression must have 
        a member with the specified name.</para>
        
        <programlisting>Receiver: Primary</programlisting>
        
        <para>A receiver expression must be explicitly specified, unless:</para>
        
        <itemizedlist>
            <listitem>
                <para>the reference is to a toplevel method, toplevel attribute, 
                or class,</para>
            </listitem>
            <listitem>
                <para>the reference is to a local or parameter, or</para>
            </listitem>
            <listitem>
                <para>the current instance of a containing class is the receiver.</para>
            </listitem>
        </itemizedlist>
        
        <para>When a callable reference with a receiver expression is executed, the 
        receiver expresson is evaluated and a reference to the resulting value is 
        held as part of the callable reference. When a value reference with a 
        receiver expression is executed, the receiver expression is evaluated and a 
        reference to the resulting value is held as part of the value reference.</para>
        
        <!--
        <para>An outer instance reference may also specify a receiver expression. The
        receiver expression must be explicitly specified unless the current instance
        of the current class is the receiver.</para>
        -->
        
    </section>
        
    </section>
    
    <!--
    <section id="outerinstancereferences">
        <title>Outer instance references</title>
        
        <para>For a nested class, the containing instance may be obtained using
        the keyword <literal>outer</literal>.</para>
        
        <programlisting>OuterReference: (Receiver ".")? "outer"</programlisting>
        
        <para>The type of the outer instance reference is the type that contains 
        the declaration of the receiver expression type (which must be a nested 
        class). If no receiver expression is specified, the type of the outer 
        instance reference is the type that contains the declaration of the 
        current class (the class in which the expression appears, which must be 
        a nested class).</para>
        
        <programlisting>Node node = tree.Node().Node();
assert() that (tree &equals; node.outer.outer);</programlisting>

        <programlisting>class Catalog() {
    class Schema() {
        Catalog catalog { return outer; }
        class Table() {
            Schema schema { return outer; }
            Catalog catalog { return outer.outer; }
        }
    }
}</programlisting>
        
    </section>
    -->
    
    <section id="valuereferences">
        <title>Value references</title>
                
        <para>A <emphasis>value reference</emphasis> is a reference to 
        something&mdash;for example, an attribute, a local, or an invocation 
        expression&mdash;that can be <emphasis>evaluated</emphasis>.</para>

        <para>A value reference may be transparently converted to the actual current 
        value of the attribute or local, or to the return value of the invocation, or 
        it may be passed, as a reference, to other code, which may use the reference to 
        <emphasis>evaluate</emphasis> the current value of the attribute or local, or
        to perform the invocation. A reference to a <literal>variable</literal> attribute 
        or local may be used to <emphasis>assign</emphasis> a new value to the attribute 
        or local.</para>
        
        <para>A value reference expression is assignable to <literal>Gettable&lt;T&gt;</literal> 
        or <literal>Settable&lt;T&gt;</literal> where <literal>T</literal> is the type of 
        the attribute or local, or the return type of the invocation expression.</para>
        
        <section id="attributeandlocalreferences">
            <title>Attribute and local references</title>
        
        <para>An <emphasis>attribute reference</emphasis> is a reference to an attribute
        of some object. A <emphasis>local reference</emphasis> is a reference to a 
        local or parameter. An attribute reference specifies the name of the attribute. 
        A local reference specifies the name of the local or parameter.</para>
        
        <programlisting>ValueReference: (Receiver ".")? MemberName</programlisting>
        
        <para>The type of an attribute reference or local reference expression for an 
        attribute, local, or parameter of declared type <literal>X</literal> is:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>X</literal>, if <literal>X</literal> is assignable
                to <literal>Gettable&lt;Object&gt;</literal>, or, otherwise,</para>
            </listitem>
            <listitem>
                <para><literal>Gettable&lt;X&gt;</literal>, if the attribute, local, 
                or parameter is not <literal>variable</literal>, or if the setter is 
                not visible to the block containing the attribute or local reference, 
                or</para>
            </listitem>
            <listitem>
                <para><literal>Settable&lt;X&gt;</literal>, if the attribute, local, 
                or parameter is <literal>variable</literal> and the setter, if any, 
                is visible to the block containing the attribute or local 
                reference.</para>
            </listitem>
        </itemizedlist>
        
        </section>
        
        <section id="passbyreference">
            <title>Pass by reference</title>
            
            <comment><para>NOTE: Lazy evaluation and pass by reference is a proposed feature for 
            a future version of the language.</para></comment>
        
            <para>An expression of type <literal>Gettable</literal> or <literal>Settable</literal> 
            may be assigned to an attribute or local, passed as an argument to a method or initializer, 
            or returned by a method. If the attribute, local, or parameter to which the expression is 
            assigned is of declared type <literal>Gettable</literal> or <literal>Settable</literal>, 
            or if the method which returns the expression is of declared type <literal>Gettable</literal> 
            or <literal>Settable</literal>, this is called <emphasis>pass by reference</emphasis>, 
            since it does not result in immediate evaluation of the referenced value. Instead, the 
            attribute, local, or parameter holds a <emphasis>reference</emphasis> to the value of some 
            other attribute, local, or parameter.</para>
            
            <para>This local holds a reference:</para>
            
            <programlisting>Gettable&lt;String&gt; nameRef = person.name;</programlisting>
            
            <para>This method returns a reference:</para>
            
            <programlisting>Settable&lt;String&gt; getName(Person p) { return p.name; }</programlisting>
            
            <para>This class has an initialization parameter which accepts a reference:</para>
            
            <programlisting>class Input(Settable&lt;String&gt; model) { ... }</programlisting>
            
            <para>This attribute holds a reference to an invocation expression:</para>
            
            <programlisting>shared Gettable&lt;Decimal&gt; total = order.calculateTotal();</programlisting>
            
            <para>An attribute or local of type <literal>Gettable</literal> or <literal>Settable</literal> 
            may not be declared <literal>variable</literal>.</para>
            
        </section>
        
    </section>

    <section id="callablereferences">
        <title>Callable references</title>
        
        <para>A <emphasis>callable reference</emphasis> is a reference to 
        something&mdash;a method, callable parameter, or class&mdash;that can be 
        <emphasis>invoked</emphasis> by specifying a list of arguments.</para>
        
        <programlisting>CallableReference: MethodReference | InitializerReference</programlisting>
        
        <para>A callable reference may be invoked immediately, or it may be passed 
        to other code which may invoke the reference. A callable reference captures 
        the return type and parameter lists of the method, callable parameter, or 
        class it refers to, allowing compile-time validation of argument types when 
        the callable reference is invoked.</para>
        
        <para>A callable reference expression is assignable to 
        <literal>Callable&lt;T,P...&gt;</literal> where <literal>T</literal> and 
        <literal>P...</literal> depend upon the schema of the method or class.</para>
        
        <comment><para>TODO: we can support LINQ to SQL-like queries by making 
        <literal>Callable</literal> provide an AST of the statements contained
        in the method declaration, allowing translation to SQL.</para></comment>
                
        <section id="typearguments">
            <title>Type arguments</title>
            
            <para>If a callable reference expression refers to a generic declaration, 
            either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>it must be immediately followed by an argument list, 
                    allowing the compiler to infer the type arguments, or</para>
                </listitem>
                <listitem>
                    <para>it must specify an explicit type argument list.</para>
                </listitem>
            </itemizedlist>
            
        </section>
        
        <section id="methodreferences">
            <title>Method references</title>
        
        <para>If a callable reference specifies a method name (or callable parameter 
        name), it is called a <emphasis>method reference</emphasis>.</para>

        <programlisting>MethodReference: (Receiver ".")? MemberName TypeArguments?</programlisting>        

        <para>The type of a method reference expression is assignable to the callable 
        type of <!--every overloaded version of--> the method. Calling the method 
        reference results in execution of the method.</para>
        
        </section>

        <section id="initializerreferences">
            <title>Initializer references</title>
        
        <para>If a callable reference specifies a class name, it is called an 
        <emphasis>initializer reference</emphasis>.</para>
        
        <programlisting>InitializerReference: (Receiver ".")? TypeName TypeArguments?</programlisting>
        
        <para>The type of an initializer reference expression is assignable to the 
        callable type of <!-- every overloaded version of--> the class. Calling the 
        initializer reference results in instantiation of the class.</para>
        
        </section>
        
        <!--
        <section>
            <title>Method reference typing</title>
        
        <para>Method references do not, strictly speaking, have types. However, the schema
        of a method reference determines if it can appear to the right of the <literal>=</literal>
        specifier in a method declaration, or as an argument to a functional parameter. In this
        case we say the method reference <emphasis>conforms</emphasis> to the schema of the
        method or functional parameter.</para>

        <para>A method reference schema <emphasis>conforms</emphasis> to a method or functional 
        parameter schema if:</para>
        
        <itemizedlist>
            <listitem>
                <para>the return type of the method reference is assignable to the declared
                return type of the method or functional parameter, and</para>
            </listitem>
            <listitem>
                <para> the method reference has exactly the same number of parameters, 
                with the same types, as the method or functional parameter.</para>
            </listitem>
        </itemizedlist>
        
        <para>Thus, method schemas are covariant in return type, and invariant in parameter 
        types.</para>
        
        <para>The schema also restricts the the argument list that can be specified when the
        method reference is invoked.</para>
        
        <para>Additionally, method references are assignable to <literal>Callable&lt;X&gt;</literal>
        where <literal>X</literal> is the return type. Note that <literal>Callable</literal>
        does not capture parameter types, and so references of type 
        <literal>Callable&lt;X&gt;</literal> are therefore not method references.</para>
        
        <comment><para>TODO: could we make method references contravariant in the parameter
        types? If so, we should use the same rule for refining.</para></comment>
        
        <comment><para>TODO: does a method schema with a defaulted parameter conform to a method 
        schema without that parameter?</para></comment>
        
        </section>
         -->
         
        <section id="callableobjectsasmethodimplementations">
            <title>Callable objects as method implementations</title>
            
        <para>An expression of type <literal>Callable</literal> may be used to define a 
        method using <literal>=</literal>. The expression type must be assignable to the 
        callable type of the method being defined.</para>
        
        <programlisting>Comparison order&lt;Value&gt;(Value x, Value y) = reverse;</programlisting>
        
        <programlisting>void display(String message) = log.info;</programlisting>
        
        <programlisting>String newString(Character... chars) = String;</programlisting>
        
        <programlisting>String name(Person p) = Person.name;</programlisting>
        
        <programlisting>void print&lt;Value&gt;(Value value) given Value of String | Integer | Float = printer.print;</programlisting>
        <programlisting>void printStr(String string) = printer.print&lt;String&gt;;</programlisting>
        
        </section>
        
        <section id="callableobjectsascallableparameterarguments">
            <title>Callable objects as callable parameter arguments</title>
            
        <para>An expression of type <literal>Callable</literal> may appear as an argument 
        to a callable parameter, either as a positional argument, or as an argument 
        specified using <literal>=</literal> in a named argument invocation. The expression 
        type must be assignable to the callable type of the callable parameter.</para>
        
        <para>This method has a callable parameter:</para>
        
        <programlisting>void sort(List&lt;String&gt; list, Comparison by(String x, String y)) { ... }</programlisting>

        <para>This code passes a reference to a local method to the method.</para>
        
        <programlisting>Comparison reverseAlpha(String x, String y) { return y&lt;=&gt;x; }
sort(names, reverseAlpha);</programlisting>
        
        <para>This class has two callable parameters:</para>
        
        <programlisting>shared class TextInput(Natural size=30, String onInit(), String onUpdate(String s)) { ... }</programlisting>
 
        <para>This code instantiates the class, passing references to methods which set and
        get the attribute <literal>person.name</literal>:</para>
        
        <programlisting>TextInput input { 
    size=15; 
    onInit = set(person.name);
    onUpdate = get(person.name);
}</programlisting>
        
        </section>
        
        <section id="callableobjectsasmethodreturnvalues">
            <title>Callable objects as method return values</title>
            
        <para>An expression of type <literal>Callable</literal> may be returned by a method 
        with multiple parameter lists. The expression must be assignable to the callable 
        type of a method formed by eliminating the first parameter list of the method.</para>
        
        <programlisting>Comparison getOrder(Boolean reverse=false)(Natural x, Natural y) {
    if (reverse) {
        Comparison reverse(Natural x, Natural y) { return y&lt;=&gt;x; }
        return reverse;
    }
    else {
        Comparison natural(Natural x, Natural y) { return x&lt;=&gt;y; }
        return natural;
    }
}</programlisting>

        <para>This is slightly simpler using type inference:</para>

        <programlisting>Comparison getOrder(Boolean reverse=false)(Natural x, Natural y) {
    if (reverse) {
        local reverse(Natural x, Natural y) { return y&lt;=&gt;x; }
        return reverse;
    }
    else {
        local natural(Natural x, Natural y) { return x&lt;=&gt;y; }
        return natural;
    }
}</programlisting>

        <para>Calling a method with multiple parameter lists is similar to the operation 
        of "currying" in a functional programming language.</para>
        
        <programlisting>Comparison order(Natural x, Natural y) = getOrder();
Comparison comp = order(1,-1);</programlisting>

        <para>This is even simpler using type inference:</para>

        <programlisting>local order(Natural x, Natural y) = getOrder();
local comp = order(1,-1);</programlisting>

        <para>Or, if we don't need parameter names, we don't even need to explicitly declare the 
        parameter list:</para>

        <programlisting>local order = getOrder();
local comp = order(1,-1);</programlisting>

        <para>In this case, <literal>order</literal> is actually not a method at all&mdash;it's
        just a local of type <literal>Callable&lt;Comparison,Natural,Natural&gt;</literal>.</para>

        <para>Of course, more than one argument list may be specified in a single expression:</para>
        
        <programlisting>Comparison comp = getOrder(true)(10, 100);</programlisting>
        
        </section>
        
    </section>
    
    <section id="invocationexpressions">
        <title>Invocation expressions</title>
        
        <para>A callable object&mdash;any instance of <literal>Callable</literal>&mdash;is 
        <emphasis>invokable</emphasis>. An <emphasis>invocation</emphasis> consists of an 
        <emphasis>invoked expression</emphasis> of type <literal>Callable&lt;T,P...&gt;</literal>, 
        together with an argument list and, optionally, an explicit type argument list.</para>
        
        <programlisting>Invocation: Primary Arguments | SequenceInstantiation</programlisting>
            
        <para>Any invocation expression where the invoked expression is a callable reference 
        expression is called a <emphasis>direct invocation expression</emphasis> of the 
        method, callable parameter, or class. In the case of a direct invocation expression, 
        the compiler has additional information about the schema of the method or class that 
        is not reified by the <literal>Callable</literal> interface. The compiler is aware of:</para>
        
        <itemizedlist>
            <!--
            <listitem>
                <para>all the overloaded versions of the method or class (the various
                <literal>Callable</literal> types to which the callable reference
                expression is assignable),</para>
            </listitem>
            -->
            <listitem>
                <para>the names of the parameters of the method or class,</para>
            </listitem>
            <listitem>
                <para>which parameters are defaulted, and their default values, and</para>
            </listitem>
            <listitem>
                <para>whether the last parameter in the list is a sequenced parameter.</para>
            </listitem>
        </itemizedlist>
        
        <para>(Furthermore, in the case of a direct invocation expression, type argument 
        inference is possible, since the compiler is aware of the type parameters and 
        constraints of the method or class.)</para>
                
        <para>An invocation expression must specify arguments for parameters of the callable 
        object, either by listing parameter values in order or, in the case of a direct 
        invocation, listing named parameter values.</para>
        
        <programlisting>Arguments: PositionalArguments FunctionalArguments? | NamedArguments</programlisting>
        
        <para>Arguments to required parameters must be specified.</para>
        
        <itemizedlist>
            <listitem>
                <para>If the invocation expression is a direct invocation expression, 
                arguments to defaulted parameters may optionally be specified, and one or 
                more arguments to a sequenced parameter may optionally be specified.</para>
            </listitem>
            <listitem>
                <para>Otherwise, an argument must be specified for each defaulted parameter, 
                and a single argument must be specified for the sequenced parameter.</para>
            </listitem>
        </itemizedlist>
        
        <para>For a required or defaulted parameter of type <literal>T</literal>, the type 
        of the corresponding argument expression must be assignable to <literal>T</literal>.</para>
        
        <para>For a tuple parameter of psuedo-type <literal>P...</literal>, the type of the 
        corresponding argument expression must be <literal>P...</literal>. (That is, it
        must be a tuple parameter of declared type <literal>P...</literal>.)</para>
        
        <para>For a sequenced parameter of type <literal>T...</literal>, there may 
        either:</para>
        
        <itemizedlist>
            <listitem>
                <para>be a single argument expression of type assignable to 
                <literal>T[]</literal>, or</para>
            </listitem>
            <listitem>
                <para>in the case of a direct invocation expression, an arbitrary number of 
                argument expressions of type assignable to <literal>T</literal>.</para>
            </listitem>
        </itemizedlist>
         
        <para>In the second case, the argument expressions are evaluated and collected into 
        an instance of <literal>T[]</literal> when the invocation is executed.</para>
        
        <para>The type of an invocation expression is:</para> 
                        
        <itemizedlist>
            <listitem>
                <para><literal>R</literal>, if <literal>R</literal> is assignable
                to <literal>Gettable&lt;Object&gt;</literal>, or, otherwise,</para>
            </listitem>
            <listitem>
                <para><literal>Gettable&lt;R&gt;</literal></para>
            </listitem>
        </itemizedlist>
        
        <para>where <literal>R</literal> is the type argument to the first type parameter 
        of the expression type <literal>Callable</literal> (the return type).</para>
        
        <section id="typeargumentinference">
            <title>Type argument inference</title>
        
        <para>When a direct invocation expression for a generic method or a direct 
        instantiation expression for a generic class does not explicitly specify type 
        arguments, the type arguments are inferred from the argument expression types. 
        The types of the argument expressions and the declared types of the 
        corresponding parameters determine a <emphasis>constraint set</emphasis> for 
        an inferred type parameter.</para>
        
        <para>If a list of argument expressions has types <literal>A1,A2,...</literal> 
        and the corresponding list of parameters has declared types <literal>P1,P2,...</literal>, 
        the constraint set for a type parameter <literal>T</literal> of the generic
        declaration is the union of all constraint sets <literal>Ai</literal> on 
        <literal>Pi</literal> for <literal>T</literal>.</para>
        
        <para>Given types <literal>A</literal> and <literal>P</literal>, we determine 
        the constraint set <literal>A</literal> on <literal>P</literal> for <literal>T</literal> 
        according to the nature of <literal>P</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>If <literal>P</literal> is a produced type <literal>Q&lt;P1,P2,...&gt;</literal> 
                of a parameterized type <literal>Q</literal>, and <literal>A</literal> 
                is a subtype of a produced type <literal>Q&lt;A1,A2,..&gt;</literal>, 
                the constraint set <literal>A</literal> on <literal>P</literal> for 
                <literal>T</literal> is the union of all constraint sets <literal>Ai</literal> 
                on <literal>Pi</literal> for <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>P</literal> is exactly <literal>T</literal>, the 
                constraint set <literal>A</literal> on <literal>P</literal> for 
                <literal>T</literal> contains the single constraint that 
                <literal>T abstracts A</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>P</literal> is a union type <literal>Q|R</literal>, 
                and <literal>Q</literal> is neither a produced type nor exactly 
                <literal>T</literal>, and <literal>A</literal> is not assignable 
                to <literal>Q</literal>, the constraint set <literal>A</literal> on 
                <literal>P</literal> for <literal>T</literal> is the constraint set 
                <literal>A</literal> on <literal>R</literal> for <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>If <literal>P</literal> is a union type <literal>Q|R</literal>, 
                and <literal>Q</literal> is neither a produced type nor exactly 
                <literal>T</literal>, and <literal>A</literal> is a union type 
                <literal>B|C</literal>, and <literal>B</literal> is assignable to 
                <literal>Q</literal>, the constraint set <literal>A</literal> on 
                <literal>P</literal> for <literal>T</literal> is the constraint set 
                <literal>C</literal> on <literal>R</literal> for <literal>T</literal>.</para>
            </listitem>
            <listitem>
                <para>Otherwise, if <literal>P</literal> is neither a produced type 
                nor exactly <literal>T</literal>, the constraint set <literal>A</literal> 
                on <literal>P</literal> for <literal>T</literal> is empty.</para>
            </listitem>
        </itemizedlist>
        
        <para>The <emphasis>full constraint set for a type parameter</emphasis> 
        <literal>T</literal> of the generic declaration is the constraint set for
        <literal>T</literal>, together with a constraint <literal>T abstracts X</literal> 
        for every lower bound <literal>X</literal> on <literal>T</literal> in the 
        generic type constraints on <literal>T</literal> (after substitution of 
        type arguments into <literal>X</literal>).</para>
        
        <para>The inferred type argument to a type parameter <literal>T</literal> 
        of the generic declaration is:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>Bottom</literal>, if the full constraint set for 
                <literal>T</literal> is empty, or, otherwise,</para>
            </listitem>
            <listitem>
                <para>the union type of all types <literal>A</literal> where a 
                constraint of form <literal>T abstracts A</literal> belongs to 
                the full constraint set for <literal>T</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>If the inferred type argument does not satisfy the generic type 
        constraints on <literal>T</literal>, a compilation error results.</para>
        
        <para>Consider the following invocation:</para>
        
        <programlisting>Element[] prepend&lt;T&gt;(Element head, Element[] sequence) { ... }
local result = prepend(null, {"hello", "world"});</programlisting>

        <para>The constraint set for <literal>Element</literal> comprises two 
        constraints:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>Element abstracts Nothing</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>Element abstracts String</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Therefore, the inferred type of <literal>Element</literal> is the 
        union type <literal>Element?</literal>.</para>
        
        <para>Now consider:</para>
        
        <programlisting>class Bag&lt;out Element&gt;(Element... elements) {
    shared Bag&lt;ExtraElement&gt; with(ExtraElement... elements) 
            given ExtraElement abstracts Element { ... }
}
Bag&lt;String&gt; bag = Bag("hello", "world");
local biggerBag = bag.with(1, 2, 5.0);
</programlisting>
        
        <para>The constraint set for <literal>ExtraElement</literal> comprises 
        three constraints:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>ExtraElement abstracts Natural</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>ExtraElement abstracts Float</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>ExtraElement abstracts String</literal> (formed by
                substituting <literal>String</literal> for <literal>Element</literal>
                in the schema of <literal>Bag</literal>).</para>
            </listitem>
        </itemizedlist>
        
        <para>Therefore, the inferred type of <literal>ExtraElement</literal> is the 
        union type <literal>Natural|Float|String</literal>.</para>
        
        <comment><para>TODO: What about lower bounds in which the type  
        parameter itself appears (the infamous self-type problem with
        <literal>Comparable</literal> and <literal>Numeric</literal>) 
        or in which another type parameter appears?</para></comment>
        
        <comment><para>TODO: This algorithm works fine for type parameters that 
        appear covariantly in the parameter types, and even okay for type
        parameters that appear nonvariantly. It doesn't really work very well 
        for type parameters that appear contravariantly, where the constraints
        are really of form <literal>A satisfies T</literal>, and they should be
        combined using intersection, not union, and where the default should be
        <literal>Object</literal> not <literal>Bottom</literal>. Unfortunately
        we don't currently support intersection types in the spec, or have the 
        machinery to reason about them in the compiler.</para>
        <para>Note also that there is something a bit conceptually funny about 
        a type parameter that appears covariantly in a parameter type, and 
        contravariantly in the return type (or vice-versa), so we probably don't 
        really need to bother about the case where a type parameter appears both 
        covariantly <emphasis>and</emphasis> contravariantly.</para></comment>
                
        </section>
        
        <section id="methodinvocation">
            <title>Method invocation</title>
            
            <para>For a method invocation, the invocation expression is of type
            <literal>Gettable&lt;R&gt;</literal> where <literal>R</literal> is the return 
            type of the method. The type of a <literal>void</literal> method invocation 
            expression is <literal>Gettable&lt;Void&gt;</literal>.</para>
            
            <programlisting>log.info("Hello world!")</programlisting>
            <programlisting>log.info { message = "Hello world!"; }</programlisting>
            <programlisting>printer.print { join = ", "; "Gavin", "Emmanuel", "Max", "Steve" }</programlisting>
            <programlisting>printer.print { "Names: ", from (Person p in people) select (p.name) }</programlisting>
            <programlisting>set(person.name)("Gavin")</programlisting>
            <programlisting>get(process.args)()</programlisting>
            
            <programlisting>amounts.sort() by (Float x, Float y) (x&lt;=&gt;y)</programlisting>
            <programlisting>people.each() perform (Person p) { log.info(p.name); }</programlisting>
            <programlisting>map.filter() by (String key->String value) (value nonempty)</programlisting>
            
            <programlisting>hash(default, firstName, initial, lastName)</programlisting>
            <programlisting>hash { algorithm=default; firstName, initial, lastName }</programlisting>
            
            <programlisting>from (people) where (Person p) (p.age>18) select (Person p) (p.name)</programlisting>
            <programlisting>iterate (map) 
    perform (String name->Object value) { 
        log.info("Entry: " name "->" value ""); 
    };</programlisting>
    
            <programlisting>performAs (subject) privilegedAction {
    exec("java Hello");
}</programlisting>

            <programlisting>check {
    FilePermission {
        path = "/usr/bin";
        action = read | execute;
    }
}</programlisting>
            
        </section>
        
        <section id="classinstantiation">
            <title>Class instantiation</title>
            
            <para>Invocation of an initializer reference is called <emphasis>instantiation</emphasis> 
            of the class. For a class instantation, the invocation expression is of type
            <literal>Gettable&lt;T&gt;</literal> where <literal>T</literal> is the 
            class.</para>
            
            <programlisting>HashMap&lt;String, Person&gt;(entries)</programlisting>
            <programlisting>Point { x=1.1; y=-2.3; }</programlisting>
            <programlisting>ArrayList&lt;String&gt; { capacity=10; "gavin", "max", "emmanuel", "steve", "christian" }</programlisting>
            <programlisting>input.Tokens()</programlisting>
            
        </section>
        
        <section id="sequenceinstantiation">
            <title>Sequence instantiation</title>
            
            <para>An instantiation expression for the type <literal>Sequence</literal> may
            be written in an abbreviated form where the type name is eliminated.</para>
        
            <programlisting>SequenceInstantiation = "{" SequencedArguments? "}"</programlisting>
            
            <para>The following expression:</para>
            
            <programlisting>{ "hello", "world" }</programlisting>
            
            <para>Is equivalent to:</para>
            
            <programlisting>Sequence { "hello", "world" }</programlisting>
            
            <para>The type of a sequence instantiation expression is:</para>
            
            <itemizedlist>
                <listitem>
                    <literal>Empty</literal> if there are no argument expressions, or
                </listitem>
                <listitem>
                    <literal>Sequence&lt;X|Y|Z...&gt;</literal> where <literal>X</literal>,
                    <literal>Y</literal>, <literal>Z</literal> are the types of the argument 
                    expressions, otherwise.
                </listitem>
            </itemizedlist>
            
            <comment><para>TODO: alternatively, we could support a Java-style syntax of form
            <literal>String[] { "hello", "world" }</literal>.</para></comment>
        
        </section>
        
        <section id="positionalarguments">
            <title>Positional arguments</title>
        
        <para>When arguments are listed, the arguments list is enclosed in parentheses.</para>
            
        <programlisting>PositionalArguments: "(" ( Expression ("," Expression)* )? ")"</programlisting>
        
        <para>Positional arguments must be listed in the same order as the corresponding
        parameters.</para>
        
        <itemizedlist>
            <listitem>
                <para>First, an argument of each required parameters must be specified, in the 
                order in which the required parameters were declared. There must be at least as 
                many arguments as required parameters.</para>
            </listitem>
            <listitem>
                <para>Next, arguments of the first arbitrary number of defaulted parameters may 
                be specified, in the order in which the defaulted parameters were declared. If 
                there are fewer arguments than defaulted parameters, the remaining defaulted 
                parameters are assigned their default values.</para>
            </listitem>
            <listitem>
                <para>Finally, if arguments to all defaulted parameters have been specified,
                and if the method declares a sequenced parameter, an arbitrary number of arguments 
                to the sequenced parameter may be specified. 
                </para>
            </listitem>
        </itemizedlist>
        
        <para>For example:</para>
        
        <programlisting>(getProduct(id), 1)</programlisting>
                
        </section>
        
        <section id="namedarguments">
            <title>Named arguments</title>
            
        <para>When arguments are named, the argument list is enclosed in braces.</para>
        
        <programlisting>NamedArguments: "{" NamedArgument* SequencedArguments? "}"</programlisting>
        
        <para>Named arguments may be listed in a different order to the corresponding
        parameters.</para>

        <para>Required and defaulted parameter arguments are specified by name. Arguments to
        a sequenced parameter are specified by listing them, without specifying a name, at the 
        end of the argument list.</para>

        <para>A named argument is either:</para> 
        
        <itemizedlist>
            <listitem>
                <para>a specification statement where the name of the value being specified is
                the parameter name&mdash;it specifies its value using <literal>=</literal>, 
                followed by an expression, and is terminated by a semicolon, or</para>
            </listitem>
            <listitem>
                <para>a local declaration with a getter or named argument list where the name 
                of the local is the parameter name&mdash;it specifies the type of the attribute 
                or <literal>local</literal>, and a block or code or named argument list used to 
                instantiate the return type, or</para>
            </listitem>
            <listitem>
                <para>a local anonymous class declaration where the name of the local is the
                parameter name&mdash;an <literal>object</literal> declaration, or</para>
            </listitem>
            <listitem>
                <para>only for callable parameters, a local method declaration with a block or
                named parameter list where the name of the method is the parameter 
                name&mdash;it specifies the return type or <literal>local</literal>, a 
                parameter list and a block of code or named argument list used to instantiate 
                the return type.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>NamedArgument: SpecifiedNamedArgument | LocalNamedArgument | FunctionalNamedArgument | Object</programlisting>
        
        <programlisting>SpecifiedNamedArgument: MemberName Specifier ";"</programlisting>
        
        <programlisting>LocalNamedArgument: InferableType MemberName (Block | NamedArguments)</programlisting>
        
        <programlisting>FunctionalNamedArgument: (InferableType | "void") MemberName Params+ (Block | NamedArguments)</programlisting>
        
        <para>For example:</para>
        
        <programlisting>{ 
    product = getProduct(id); 
    quantity = 1; 
}</programlisting>
        
        <programlisting>{
    description = "Total";
    Float amount { 
        variable Float total := 0.0;
        for (Item item in items) {
            sum += item.amount;
        }
        return total;
    }
}</programlisting>
        
        <programlisting>{
    Head head { title="Hello"; }
    Body body {
        Div { "Hello " name "!" }
    }
}</programlisting>

        <programlisting>{
    object iterator satisfies Iterator&lt;Order&gt; {
        head = order;
        shared actual object tail satisfies Iterator&lt;Order&gt; {
            head = null;
            tail = this;
        }
    }   
}</programlisting>

        <programlisting>{ 
    label = "Say Hello"; 
    void onClick() { 
        say("Hello"); 
    } 
}</programlisting>
        
        <programlisting>{ 
    Comparison by(Value x, Value y) { return x&lt;=&gt;y; } 
}</programlisting>

        <para>This is simpler using type inference:</para>

        <programlisting>{ 
    local by(Value x, Value y) { return x&lt;=&gt;y; } 
}</programlisting>

        <comment><para>TODO: should the named argument list be allowed to contain arbitrary 
        statements? This is more regular, since you can do it in the body of a class, and 
        attribute/method refinement is the model that we are following here. And it could be 
        very useful when defining structured data.</para></comment>
        
        <comment><para>TODO: Should we let you define a getter/setter pair for parameters of 
        type <literal>Settable</literal>?</para></comment>
        
        </section>

        <section id="sequencedarguments">
            <title>Sequenced arguments</title>
            
        <para>Arguments to a sequenced parameter are seperated by commas.</para>

        <programlisting>SequencedArguments: Expression ("," Expression)*</programlisting>

        <para>For example:</para>
        
        <programlisting>(1, 1, 2, 3, 5, 8)</programlisting>
        
        <para>Alternatively, the argument to a sequenced parameter may be a <literal>Sequence</literal> 
        of the parameter type.</para>
        
        <programlisting>({1, 1, 2, 3, 5, 8})</programlisting>
        
        <comment><para>TODO: Should we allow an argument to a sequenced parameter in a named
        argument list to be a local declaration, thus allowing the object to be referred to
        later?</para>
            <programlisting>Panel {
    label = "Hello";
    Input i = Input(),
    Button {
        label = "Hello";
        action() {
            log.info(i.value);
        }
    }
}</programlisting>            
        </comment>
        
        <!--
        <comment><para>TODO: actually, upon reflection, I think it might be better and more
        regular to use semicolons to separate sequenced arguments in a named argument 
        invocation.</para></comment>
        -->
        
        </section>
        
        <section id="defaultarguments">
            <title>Default arguments</title>
        
        <para>When no argument is assigned to a defaulted parameter by the caller, the 
        default argument defined by the parameter declaration is used. The default argument 
        expression is evaluated every time the method is invoked with no argument specified 
        for the defaulted parameter.</para>
        
        <para>This class:</para>
        
        <programlisting>shared class Counter(Natural initialCount=0) {
    
    variable Natural count := initialCount;
    
    ...
    
}</programlisting>
        
        <!--
        <para>Is equivalent to a class with three Java constructor declarations and an inner class:</para>
        
        <programlisting>public class Counter {
        
    public Counter() {
        Counter(0);
    }
    
    public Counter(Natural initialCount) {
        ...;
    }
    
    public Counter(CounterParameters namedParameters) {
        Counter( namedParameters.initialCount );
    }

    public static class CounterParameters {
        private Natural initialCount=0;
        CounterParameters initialCount(Natural initialCount) { 
            this.initialCount = initialCount;
            return this;
        }
    }
    
}</programlisting>
        -->
        
        <para>May be instantiated using any of the following:</para>
        
        <programlisting>Counter()</programlisting>
        <programlisting>Counter(1)</programlisting>
        <programlisting>Counter {}</programlisting>
        <programlisting>Counter { initialCount=10; }</programlisting>
        
        <!--
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>new Counter ( new CounterParameters().initialCount(10) );</programlisting>
        -->
        
            <para>This method:</para>
        
            <programlisting>shared class Counter() {
    
    variable Natural count := 0;
    
    shared void init(Natural initialCount=0) {
        count:=initialCount;
    }
    
    ...

}</programlisting>
            <!--
            <para>Is equivalent to three Java method declarations and an inner class:</para>
        
        <programlisting>public class Counter {
        
    void init() {
        init(0);
    }
    
    void init(Natural initialCount) {
        count=initialCount;
    }
    
    void init(CounterInitParameters namedParameters) {
        init( namedParameters.initialCount );
    }

    static class CounterInitParameters {
        private Natural initialCount=0;
        CounterInitParameters initialCount(Natural initialCount) { 
            this.initialCount = initialCount;
            return this;
        }
    }
    
}</programlisting>
            -->
            
            <para>May be invoked using any of the following:</para>
        
            <programlisting>counter.init()</programlisting>
            <programlisting>counter.init(1)</programlisting>
            <programlisting>counter.init {}</programlisting>
            <programlisting>counter.init { initialCount=10; }</programlisting>
            
            <!--
            <para>Is equivalent to this Java code:</para>
        
            <programlisting>counter.init ( new CounterInitParameters().initialCount(10) );</programlisting>
            -->
 
        </section>
        
        <section id="callablearguments">
            <title>Inline callable arguments</title>
            
        <para>After a positional argument list, arguments to callable parameters 
        may be specified with certain punctuation eliminated:</para>
        
        <itemizedlist>
            <listitem>
                <para>the return type is not declared,</para>
            </listitem>
            <listitem>
                <para>if the callable parameter has an empty parameter list, the 
                empty parentheses may be eliminated, and</para>
            </listitem>
            <listitem>
                <para>if the body of the method implementation consists of a single
                <literal>return</literal> directive followed by a parenthesized
                expression, the braces and <literal>return</literal> keyword may be 
                eliminated.</para>
            </listitem>
            <!--listitem>
                <para>parameter declarations may omit the explicit type, 
                forcing the compiler to infer it, by specifying the keyword 
                <literal>local</literal> where the type usually appears.</para>
            </listitem-->
        </itemizedlist>
        
        <para>These arguments are called an <emphasis>inline callable arguments</emphasis> 
        of a positional argument invocation. (This is what Ceylon provides instead of
        lambda expressions.)</para>
                
        <programlisting>FunctionalArguments: (MemberName FunctionalBody)+</programlisting>
        
        <programlisting>FunctionalBody: Parameters? ( Block | "(" Expression ")" )</programlisting>
        
        <!--
                
        <programlisting>InferableFormalParameters: "(" (InferableFormalParam ("," InferableFormalParam))? ")"</programlisting>
        
        <programlisting>InferableFormalParam: InferableParam | InferableEntryParamPair | InferableRangeParamPair</programlisting>
        
        <programlisting>InferableParam: Annotation* (InferableType|"void") MemberName Params*</programlisting>
        
        <programlisting>InferableEntryParamPair: Annotation* InferableType MemberName "->" Type MemberName</programlisting>
        
        <programlisting>InferableRangeParamPair: Annotation* InferableType MemberName ".." MemberName</programlisting>
        
        -->
        
        <para>For example:</para>
        
        <programlisting>where (Person p) (p.age>18)</programlisting>
        
        <programlisting>by (Float x, Float y) (x&lt;=&gt;y)</programlisting>
        
        <programlisting>ifTrue (x+1)</programlisting>
        
        <programlisting>perform { count+=1; }</programlisting>
        
        <programlisting>perform (Person p) { log.info(p.name); }</programlisting>
        
        <programlisting>by (String key->String value) (value nonempty)</programlisting>
        
        <para>Inline callable arguments are listed without any additional punctuation:</para>
        
        <programlisting>ifTrue (x+1) ifFalse (x-1)</programlisting>
        
        <programlisting>select (Person p) (p.name) where (Person p) (p.age>18)</programlisting>
        
        <para>Arguments must be listed in the same order as the parameters are declared by the 
        method declaration.</para>
        
        <comment><para>TODO: Should we provide "true" anonymous function support, according to
        the same syntax:</para>
        <programlisting>void logName(Person p) = (Person p) { log.info(p.name); };</programlisting>
        <programlisting>Boolean adult(Person p) = (Person p) (p.age>18);</programlisting>
        <para>Perhaps readability would be enhanced by a keyword:</para>
        <programlisting>void logName(Person p) = void (Person p) { log.info(p.name); };</programlisting>
        <programlisting>Boolean adult(Person p) = local (Person p) (p.age>18);</programlisting>
        </comment>
        
        <comment><para>TODO: Should we introduce the ability to declare functional parameters
        outside the parentheses in method and class definitions, in order to better respect the 
        intended invocation syntax? For example:</para>
        <programlisting>shared void assert(Gettable&lt;String&gt; message) Boolean that { ... }</programlisting>
        <programlisting>shared Value when&lt;Value&gt;(Boolean condition) Value then Value otherwise { ... }</programlisting>
        <programlisting>shared void repeat(Natural repetitions) void times(Natural i) { ... }</programlisting>
        </comment>
        
        <comment><para>TODO: Since this is our solution for "anonymous methods" (lambda 
        expressions), we could reuse exactly the same syntax for something like Java's 
        anonymous classes. Essentially this would be an inline anonymous class declaration
        where you are allowed to omit the <literal>object</literal> keyword. So you would 
        be left with the parameter name, the <literal>extends</literal> and/or 
        <literal>satisfies</literal> clauses, and the class body. For example:</para>
        <programlisting>File file = ... ;
using() resource satisfies Usable {
    shared actual void begin() {
        file.create();
    }
    shared actual void end() { 
        file.close();
    }
    shared actual void end(Exception e) { 
        file.delete();
    }
}</programlisting>
        <para>Perhaps the <literal>extends</literal> or <literal>satisfies</literal> 
        clause could be inferred from the parameter type in some cases.</para></comment>
        
        <comment><para>TODO: Should we support type inference for the parameters?
        For example:</para>
        <programlisting>by (local x, y) (x&lt;=&gt;y)</programlisting>
        <programlisting>where (local p) (p.age>18)</programlisting></comment>

        </section>
        
        <section id="iteration">
            <title>Iteration</title>
            
            <comment><para>NOTE: The following syntax extension is a proposed feature for 
            a future version of the language.</para></comment>
        
        <para>A specialized invocation syntax is provided for toplevel methods which iterate 
        collections. (This is Ceylon's much more flexible version of C#'s LINQ.) If the first 
        parameter of the method is of type <literal>Iterable&lt;X&gt;</literal>, annotated 
        <literal>iterated</literal>, and all remaining parameters are callable parameters, 
        then the method may be invoked according to the following protocol:</para>
        
        <programlisting>Primary "(" ForIterator ")" FunctionalArguments</programlisting>
        
        <para>And then if a callable parameter has a parameter of type <literal>X</literal> 
        annotated <literal>coordinated</literal>, that parameter need not be declared by its 
        argument. Instead, the parameter is declared by the iterator.</para>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>shared List&lt;Result&gt; from&lt;Element,Result&gt;(iterated Iterable&lt;Element&gt; elements, 
                                         Boolean where(coordinated Element x),
                                         Result select(coordinated Element x));</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>List&lt;String&gt; names = from (Person p in people) where (p.age>18) select (p.name);</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>List&lt;String&gt; names = from (people) where (Person p) (p.age>18) select (Person p) (p.name);</programlisting>
        
        <para>Or, we may invoke the method as follows:</para>
                  
        <programlisting>List&lt;String&gt; labels = from (Key key -> Value value in namedValues)
                      where (user.authorized(key)) 
                      select ($key + ": " + $value);</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>List&lt;String&gt; labels = from (namedValues)
                      where (Key key -> Value value) (user.authorized(key)) 
                      select (Key key -> Value value) ($key + ": " + $value);</programlisting>
        
        <para>Type inference simplifies this further:</para>
        
        <programlisting>local names = from (local p in people) where (p.age>18) select (p.name);</programlisting>
        
        <comment><para>TODO: would a declaration which more closely reflects the invocation 
        syntax be easier to understand, something like this, for example:</para>
        <programlisting>shared List&lt;Result&gt; from&lt;Element,Result&gt;(Element x in Iterable&lt;Element&gt; elements)
                                         Boolean where(coordinated Element x)
                                         Result select(coordinated Element x);</programlisting></comment>
                
        </section>
        
        <section id="localdefinition">
            <title>Variable definition</title>
            
            <comment><para>NOTE: The following syntax extension is a proposed feature for 
            a future version of the language.</para></comment>
        
        <para>A specialized invocation syntax is also provided for toplevel methods which 
        define a variable. If the first parameter of the method is of type <literal>X</literal>,
        annotated <literal>specified</literal>, and all remaining parameters are callable
        parameters, then the method may be invoked according to the following protocol:</para>
        
        <programlisting>Primary "(" InferableVariable Specifier ")" FunctionalArguments</programlisting>
        
        <para>And then if a callable parameter has a parameter of type <literal>X</literal> 
        annotated <literal>coordinated</literal>, that parameter need not be declared by its 
        argument. Instead, the parameter is declared by the variable specifier.</para>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>
shared Result with&lt;Value,Result&gt;(specified Value? value, 
                                 Result then(coordinated Value x), 
                                 Result otherwise());</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>Decimal amount = with (Payment p = order.payment) then (p.amount) otherwise (0.0);</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>Decimal amount = with (order.payment) then (Payment p) (p.amount) otherwise (0.0);</programlisting>
        
        <para>And for the following method declaration:</para>
        
        <programlisting>shared Result using&lt;Resource,Result&gt;(specified Resource resource, 
                                     Result seek(coordinated Resource x))
        given Resource satisfies Usable;</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>Order order = using (Session s = Session()) seek (s.get(Order, oid));</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>Order order = using (Session()) seek (Session s) (s.get(Order, oid));</programlisting>
        
        <para>Type inference simplifies this further:</para>
        
        <programlisting>local amount = with (local p = order.payment) then (p.amount) otherwise (0.0);</programlisting>
        <programlisting>local order = using (local s = Session()) seek (s.get(Order, oid));</programlisting>
        
        <comment><para>TODO: would a declaration which more closely reflects the invocation 
        syntax be easier to understand, something like this, for example:</para>
        <programlisting>shared Result with&lt;Resource,Result&gt;(Resource x = Resource? value) 
                                    Result then(coordinated Resource x)
                                    Result otherwise;</programlisting></comment>
                
        </section>
        
        <!--section id="caseslist">
            <title>Lists of cases</title>
        
        <para>Finally, a specialized invocation syntax is provided for methods which define 
        a list of cases. If the method has a parameter of type 
        <literal>Iterable&lt;Entry&lt;Case&lt;X&gt;, functor Y()&gt;&gt;</literal> annotated 
        <literal>cases</literal>, the parameter may be specified according to:</para>
        
        <programlisting>(case "(" Case ")" SimpleBlockExpression)+</programlisting>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>shared
Y select&lt;X, Y&gt;(X selector,
              cases Entry&lt;Case&lt;X&gt;, functor Y()&gt;... cases);</programlisting>
                  
        <para>We may invoke the method as follows:</para>
        
        <programlisting>return select (payment.type) 
    case (check) payByCheck(payment)
    case (card) payByCard(payment);
</programlisting>
        
        </section-->
        <!--  
        <para>Or, If the method has a parameter of type 
        <literal>Enumeration&lt;functor Y(X x)&gt;</literal> annotated <literal>cases</literal>,
        the parameter value may be specified according to:</para>
        
        <programlisting>(LIdentifier BlockExpression)+</programlisting>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>shared
X attempt&lt;X&gt;(functor X() seek, 
             cases functor X(E e) given E satisfies Exception... except);</programlisting>
                  
        <para>We may invoke the method as follows:</para>
        
        <programlisting>attempt() 
seek { 
    produce doSomething(); 
} 
except (SomethingWrong sw) {
    log.info(sw);
    produce -1;
}
except (SomethingElseWrong sew) {
    log.warn(sew);
    produce -2;
}</programlisting>
        -->
            
            <!--
            <section id="resolvingoverloadedmethodsandtypes">
                <title>Resolving direct invocations of overloaded methods and classes</title>
                
                <para>A direct invocation is resolved to a specific toplevel declaration or 
                member of the receiving type at compile time, even if the method or class it 
                refers to is overloaded.</para>
                
                <para>The <emphasis>initial signature</emphasis> of a method or class in a direct
                invocation is formed by:</para>
        
                <itemizedlist>
                    <listitem>
                        <para>taking the signature of the parameter list of the class, or of the 
                        first parameter list of the method, and</para>
                    </listitem>
            --><!--listitem>
                <para>replacing each occurrence of any type alias in the signature with the
                aliased type, and</para>
            </listitem--><!--
                    <listitem>
                        <para>replacing each occurrence of any type parameter of the receiving type
                        in the signature with the type argument of that parameter in the callable 
                        object expression type, and</para>
                    </listitem>
                    <listitem>
                        <para>replacing each occurrence of any type parameter of the method or class 
                        in the signature with the explicitly specified type argument, if type 
                        arguments were specified, or with the first declared upper bound of the type 
                        parameter, or <literal>ceylon.language.Void</literal> if the type parameter 
                        has no declared upper bound.</para>
                    </listitem>
                </itemizedlist>
        
                <para>A direct invocation is <emphasis>resolveable</emphasis> if there is 
                exactly one method, callable parameter, or class declaration which:</para>
                
                <itemizedlist>
                    <listitem>
                        <para>has the specified name,</para>
                    </listitem>
                    <listitem>
                        <para>has the same number of parameters as specified argument expressions,</para>
                    </listitem>
                    <listitem>
                        <para>has a type parameter list to which the type argument list conforms, 
                        if type arguments were explicitly specified,</para>
                    </listitem>
                    <listitem>
                        <para>specifies generic type constraints which are satisfied by the type 
                        arguments, if type arguments were explicitly specified, and which</para>
                    </listitem>
                    <listitem>
                        <para>has an initial signature to which the given argument expression types 
                        are assignable.</para>
                    </listitem>
                </itemizedlist>
                
                <para>In the case of a method with multiple parameter lists, only the first
                parameter list is considered.</para>
                
                <para>If more than one overloaded declaration has an initial signature to which 
                the arguments are assignable, or if there is no declaration with an initial 
                signature to which the arguments are assignable, the invocation or instantiation 
                is illegal. (Note that Ceylon is stricter and simpler than Java with this rule.)</para>
                                
                <para>Finally, if type arguments were not explicitly specified, there must be a
                combination of type arguments that can be substituted for the type parameters of
                the method or type, respecting constraints upon the type parameters, that results
                in a method schema such that:</para>
                
                <itemizedlist>
                    <listitem>
                        <para>the given argument expression types are assignable to the method
                        parameter types after substitution of the type arguments, and</para>
                    </listitem>
                    <listitem>
                        <para>the expression type of the invocation or instantiation, after 
                        substitution of the type arguments, is assignable to the surrounding
                        context.</para>
                    </listitem>
                </itemizedlist>
                
                <comment><para>TODO: Figure out the details of the type inference implied by this 
                last bit!</para></comment>
                
                <para>If no such combination of type arguments exists, the invocation or 
                instantiation is illegal. (Note that Ceylon is less strict than Java with this 
                rule.)</para>
                
                <comment><para>TODO: We should be able to disambiguate <literal>X x(Y y)</literal>
                from <literal>X x(Y... ys)</literal> when called as <literal>x(y)</literal>.</para></comment>
                
                <comment><para>TODO: For type constraints with an initialization parameter 
                specification, the actual parameter type may not declare such signature, but
                one of its superclasses may. Is the compiler allowed to infer the superclass
                type in this situation? If so, what happens when both the class and its 
                superclass satisfy the constraint?</para></comment>
                
            </section>
            -->

                <!--
                <comment><para>TODO: What about the case of an "unbound" type parameter which does
                not appear in the parameter list? Is it an error, or should the compiler 
                search through all imported types (in the calling scope) looking for a type that 
                satisfies the constraints? This would work out a bit like Scala implicit parameters. 
                For example:</para>
                <programlisting><![CDATA[Producer<T> producer<T,P>()
        given P() satisfies Producer<T> {
    return P();
}]]></programlisting>
                <programlisting><![CDATA[T sum<T,M>(T[] ts) 
        given M() satisfies Monoid<T> {
    Monoid<T> monoid = M();
    variable T result := monoid.zero;
    for (T t in ts) {
        result := monoid.sum(result,t);
    }
    return t;
}]]></programlisting>
                <para>Note that the difference is that a constraint (or expected return type) poses 
                an upper bound, whereas an argument poses a lower bound.</para></comment>
                -->                

        </section>
        
        <!--  
        <section>
            <title>Attribute initialization</title>
            
            <para>Attribute initialization follows the following schema.</para>
            
            <programlisting>AttributeInitialization: Instantiation "{" Initialization* "}"</programlisting>
            
            <para>For example:</para>
            
            <programlisting>Person me = Person() { firstName="Gavin"; initial='A'; lastName="King"; }</programlisting>
            
            <para>The value of an attribute initialization is the instance being initialized.
            The named argument values are assigned to uninitialized attributes of the instance.</para>
                                   
        </section>
        -->
        
    <!--section id="inlineclassesliteralobjectsenumerations">
        <title>Literal objects, inline classes, and enumerations</title>
    
        <para>Three additional kinds of expressions exist for inline instantiation of an object.</para>
        
        <itemizedlist>
            <listitem>
                <para>Literal objects allow instantiation and initialization of a class without 
                execution of the constructor.</para>
            </listitem>
            <listitem>
                <para>Inline classes allow inline instantiation of an anonymous subclass of a
                certain class.</para>
            </listitem>
            <listitem>
                <para>Enumerations allow instantiation of a collection via a simplified syntax.</para>
            </listitem>
        </itemizedlist>
        
        <para>A literal object or inline class specification may bypass the constructor of the 
        class or superclass. In this case, the literal object or inline class specification takes 
        on responsibility for initialization of simple attributes of the class or superclass. This 
        means that a literal object or inline class specification which bypasses the constructor 
        must exist in a scope in which all attributes of the class or superclass are visible. Use 
        of this feature does not bypass language level accessibility checks.</para>
    
    <section id="literalobjects">
        <title>Literal objects</title>
        
        <para>A literal object is specified according to:</para>
        
        <programlisting>LiteralObject: "new" Type PositionalArguments? "{" (Assignment | Specification)* "}"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Calculator calc = new Calculator() { currentValue := 1.0; };</programlisting>
        
        <programlisting>Person gavin = new Person { 
    firstName = "Gavin";
    initial = 'A';
    lastName = "King";
    address := new Address { ... };
    birthdate = new Date { day = 25; month = MARCH; year = ... };
    employer := jboss;
};</programlisting>

        <para>A literal object must be of a concrete class and must either:</para>
        
        <itemizedlist>
            <listitem>
                <para>specify initialization parameters, and then an arbitrary list of
                mutable attribute assignments, or</para>
            </listitem>
            <listitem>
                <para>specify no initialization parameters, and specify values for each 
                simple attribute of the class, including private attributes, except 
                attributes annotated <literal>transient</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Literal objects which specify no initialization parameters are created without 
        execution of the body of the class to which they belong. Literal objects may refer to 
        immutable locals and members of the containing class in the attribute initializer 
        expressions. They may not refer to mutable locals.</para>
        
        <para>The value of a literal object expression is a new instance of the class.</para>
            
        <comment><para>TODO: are you allowed to have arbitrary code inside a literal object 
        specification?</para></comment>

        <comment><para>TODO: is there some kind of solution for getting around access 
        restrictions if you want to use a literal object specification for a class that
        extends a superclass in another package/module?</para></comment>

        <para>The classes <literal>Serializer</literal> and <literal>Deserializer</literal>
        provide the ability to serialize and deserialize any object to its 
        <emphasis>canonical literal form</emphasis>.</para>
        
        <programlisting>Person person = ...;
Serializer&lt;Person&gt; srlz = Serializer(person);
String serializedPerson = srlz; //using built-in converter
Deserializer&lt;Person&gt; dsrlz = Deserializer&lt;Person&gt;(serializedPerson);
Person deserialized = dsrlz; //using built-in converter</programlisting>

    </section>
    
        <section id="inlineclasses">
            <title>Inline classes</title>
            
            <para>Inline classes may be specified according to:</para>
            
            <programlisting>InlineClass: "new" Annotation* Type PositionalArguments? Interfaces "{" Statement* "}"</programlisting>

            <para>For example:</para>
            
            <programlisting>Task task = new Task() {
    timeout := 1000;
    shared actual void run() { ... }
    shared actual void abort(Exception e) { ... }
};</programlisting>

            <programlisting>return new transactional Database 
        satisfies Resource {
    url = "jdbc:hsqldb:.";
    username = "gavin";
    password = "foobar";
    shared actual void create() { open(); }
    shared actual void destroy() { close(); }
};</programlisting>
            
            <para>An inline class is a literal object expression which may additionally:</para>
            
            <itemizedlist>
                <listitem>
                    <para>include arbitrary code to be executed when the inline class is
                    evaluated,</para>
                </listitem>
                <listitem>
                    <para>declare and refine members, and</para>
                </listitem>
                <listitem>
                    <para>declare annotations.</para>
                </listitem>
            </itemizedlist>
            
            <para>The superclass of an inline class may be an abstract class. The inline
            class itself must be concrete.</para>
            
            <para>The value of an inline class expression is a new instance of the inline 
            class.</para>
            
        </section>
        
    </section-->
    
    <section id="evaluationandassignment">
        <title>Evaluation, invocation, and assignment</title>
        
        <para>A reference object&mdash;any instance of <literal>Gettable</literal>&mdash;can 
        be <emphasis>evaluated</emphasis> to produce a value. Evaluation is the process of
        transforming a reference of type <literal>Gettable&lt;T&gt;</literal> into a value of
        type <literal>T</literal>.</para>
        
        <para>Evaluation occurs automatically wherever an expression of type 
        <literal>Gettable&lt;T&gt;</literal> appears where an expression of type 
        <literal>T</literal> is required, in particular, where 
        <literal>Gettable&lt;T&gt;</literal> occurs:</para>
        
        <itemizedlist>
            <listitem>
                <para>as the specified expression in a specification statement or declaration 
                of a member or local of type <literal>T</literal>,</para>
            </listitem>
            <listitem>
                <para>as the receiver expression of a callable reference or value 
                reference,</para>
            </listitem>
            <listitem>
                <para>as the argument of an invocation or operator expression that expects 
                a value of type <literal>T</literal>,</para>
            </listitem>
            <listitem>
                <para>in a <literal>return</literal> directive of a method with declared
                return type <literal>T</literal>,</para>
            </listitem>
            <listitem>
                <para>in a <literal>throw</literal> or <literal>break</literal> 
                directive,</para>
            </listitem>
            <listitem>
                <para>as a control structure condition, resource, or iteration expression, 
                or</para>
            </listitem>
            <listitem>
                <para>as an expression statement.</para>
            </listitem>
        </itemizedlist>
                
        <programlisting>Natural age = person.age;</programlisting>
        <programlisting>person.say("Hello!");</programlisting>
        <programlisting>Iterable&lt;String&gt; tokens = input.Tokens();</programlisting>
        <programlisting>return person.name;</programlisting>
        <programlisting>throw Exception();</programlisting>
        <programlisting>if (exists local head = iter.head) { ... }</programlisting>
        
        <para>If a reference object is of type <literal>Settable</literal>, its value may also 
        be <emphasis>assigned</emphasis>. Assignment is performed using the <literal>:=</literal> 
        operator.</para>
         
        <programlisting>person.name := "Gavin";</programlisting>
                
    <section id="evaluation">
        <title>Evaluation</title>
        
        <para>Evaluation of an attribute reference or local reference produces the current value 
        of the attribute or local.</para> 
        
        <programlisting>String name = person.name;</programlisting>
        
        <para>Sometimes we need to pass an attribute by reference:</para>
        
        <programlisting>Gettable&lt;String&gt; nameRef = person.name;
String name = nameRef;</programlisting>
        
        <para>Sometimes we need to transform an attribute reference into a method 
        reference. The toplevel method <literal>lang.get()</literal> is provided 
        for this purpose:</para>
        
        <programlisting>String getName() = get(person.name);
String name = getName();</programlisting>
                        
        <para>When a local evaluation is executed, the current value of the local is 
        immediately obtained. The resulting value is the current value of the local.</para>
                
        <para>When an attribute evaluation is executed:</para>
        
        <itemizedlist>
            <listitem>
                <para>first, the reference expression is executed to obtain the reference 
                object, then</para>
            </listitem>
            <listitem>
                <para>the actual member to be invoked is determined by considering the 
                runtime type of the receiving instance, and then</para>
            </listitem>
            <listitem>
                <para>if the member is a simple attribute, the current value of the 
                simple attribute is retrieved from the recieving instance, or</para>
            </listitem>
            <listitem>
                <para>otherwise, execution of the calling context pauses while the body 
                of the attribute getter is executed by the receiving instance, then,</para>
            </listitem>
            <listitem>
                <para>finally, when execution of the getter ends without a thrown 
                exception, execution of the calling context resumes.</para>
            </listitem>
        </itemizedlist>
        
        <para>The resulting value is the current value of the simple attribute or the 
        return value of the attribute getter, as specified by the <literal>return</literal> 
        directive.</para>

        <para>Note that the <literal>value()</literal> method of <literal>Correspondence</literal>
        is also defined to return a <literal>Gettable</literal>.</para>
        
        <programlisting>Person? person = people[index];</programlisting>
        
        <para>Therefore an element expression can be passed by reference:</para>
        
        <programlisting>Gettable&lt;Person?&gt; personRef = person[index];
Person? person = personRef;</programlisting>
        
        <para>And an element expression can be transformed into method reference:</para>
        
        <programlisting>Person? getPerson() = get(people[index]);
Person? person = getPerson();</programlisting>
        
    </section>
    
    <section id="invocation">
        <title>Invocation</title>
        
        <para>Evaluation of an invocation expression of a callable reference invokes the 
        underlying callable reference. This is called <emphasis>invocation</emphasis> in
        the case of a method reference, and <emphasis>instantiation</emphasis> in the case
        of an initializer reference.</para>
        
        <programlisting>log.info("Hello world!");</programlisting>
        <programlisting>Map&lt;String, Person&gt; map = HashMap&lt;String, Person&gt;(entries);</programlisting>
        
        <para>Sometimes we need to perform an invocation lazily:</para>
        
        <programlisting>Gettable&lt;Void&gt; logInfoHello = log.info("Hello world!");
void invoke(Void v) {}
invoke(logInfoHello);</programlisting>

        <programlisting>Gettable&lt;Map&lt;String, Person&gt;&gt; createMapFromEntries = HashMap&lt;String, Person&gt;(entries);
Map&lt;String, Person&gt; map = createMapFromEntries;</programlisting>
        
        <para>When an evaluation of an invocation expression of a callable reference is 
        executed:</para>
        
        <itemizedlist>
            <listitem>
                <para>first, the invoked expression is executed to obtain the callable 
                object, then</para>
            </listitem>
            <listitem>
                <para>each argument is evaluated in turn in the calling context, then</para>
            </listitem>
            <listitem>
                <para>the actual member to be invoked is determined by considering the runtime
                type of the receiving instance and the static types of the arguments, and then</para>
            </listitem>
            <listitem>
                <para>execution of the calling context pauses while the body of the method or 
                initializer is executed by the receiving instance with the argument values, 
                then</para>
            </listitem>
            <listitem>
                <para>finally, when execution of the method or initializer ends without a thrown 
                exception, execution of the calling context resumes.</para>
            </listitem>
        </itemizedlist>
        
        <para>When an evaluation of any other invocation expression is executed, the 
        <literal>call()</literal> method of <literal>Callable</literal> is invoked.</para>
        
        <para>A method invocation evaluates to the return value of the method, as specified 
        by the <literal>return</literal> directive. The argument values are passed to the 
        parameters of the method, and the body of the method is executed.</para>
            
        <para>The actual value that invocation of a <literal>void</literal> method returns
        is not specified here. The type system and the definition of the <literal>is</literal> 
        operator ensures that a value of type <literal>Void</literal> can never be narrowed
        to a more specific type.</para>
            
        <para>A class instantiation evaluates to a new instance of the class. The argument 
        values are passed to the initializer parameters of the class, and the initializer
        is executed.</para>
             
    </section>
    
    <section id="assignment">
        <title>Assignment</title>
            
        <para>The assignment operator <literal>:=</literal> assigns a new value to an 
        attribute reference for a <literal>variable</literal> attribute or local.</para>
        
        <programlisting>person.name := "Gavin";</programlisting>
        
        <para>Sometimes we need to pass a <literal>variable</literal> attribute by 
        reference:</para>
        
        <programlisting>Settable&lt;String&gt; nameRef = person.name;
nameRef := "Gavin";</programlisting>

        <para>Sometimes we need to transform a <literal>variable</literal> attribute 
        reference into a method reference. The toplevel method <literal>lang.set()</literal> 
        is provided for this purpose:</para>
        
        <programlisting>String setName(String name) = set(person.name);
setName("Gavin");</programlisting>

        <para>Even the following are possible:</para>
        
        <programlisting>Settable&lt;String&gt; getName(Person p) { return p.name; }
getName(p) := "Gavin";</programlisting>

        <programlisting>setName(Settable&lt;String&gt; name, String value) { name:=value; }
setName(p.name, "Gavin");</programlisting>
        
        <para>When an attribute or local is assigned:</para>
        
        <itemizedlist>
            <listitem>
                <para>first, the reference expression is executed to obtain the reference 
                object, then</para>
            </listitem>
            <listitem>
                <para>the actual member to be invoked is determined by considering the 
                runtime type of the receiving instance, and then</para>
            </listitem>
            <listitem>
                <para>if the member is a simple attribute or local, the value of the 
                simple attribute of local is set to the new value,</para>
            </listitem>
            <listitem>
                <para>otherwise, execution of the calling context pauses while the body 
                of the attribute setter is executed by the receiving instance with the 
                new value, then,</para>
            </listitem>
            <listitem>
                <para>finally, when execution of the setter ends without a thrown 
                exception, execution of the calling context resumes.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that the <literal>value()</literal> method of <literal>OpenCorrespondence</literal>
        is also defined to return an <literal>Settable</literal>.</para>
        
        <programlisting>people[index] := person;</programlisting>
        
        <para>Therefore an assignable element expression can be passed by reference:</para>
        
        <programlisting>Settable&lt;Person?&gt; personRef = people[index];
personRef := person;</programlisting>
        
        <para>And an assignable element expression can be transformed into method 
        reference:</para>
        
        <programlisting>Person? setPerson(Person? p) = set(people[index]);
setPerson(person);</programlisting>
        
    </section>
    
    </section>
    
    <section id="metamodelreferences">
        <title>Metamodel references</title>
        
        <para>The metamodel object representing a type or program element may be obtained
        using a completely typesafe syntax.</para>
        
        <programlisting>Meta: TypeMeta | MethodMeta | AttributeMeta | FunctionMeta | ValueMeta</programlisting>
        
        <para>Metamodel references are compile-time typesafe.</para>
        
        <programlisting>Type&lt;List&lt;String&gt;&gt; stringListType = List&lt;String&gt;;</programlisting>
        
        <programlisting>Class&lt;Person,Name&gt; personClass = Person;</programlisting>
        
        <programlisting>Method&lt;Log, Void, String&gt; infoMethod = Log.info;</programlisting>
        
        <programlisting>Method&lt;String, Boolean, String&gt; stringSmaller = Comparable&lt;String&gt;.smallerThan;</programlisting>
        
        <programlisting>Attribute&lt;Person, Name&gt; nameAttribute = Person.name;</programlisting>
        
        <para>A metamodel reference that refers to a generic declaration must specify type
        arguments.</para>
        
        <comment><para>Note: this restriction results from the lack of existential types. 
        The expression <literal>Entry</literal> would have the existential type 
        <literal>ClassConstructor&lt;Entry&lt;Key,Value&gt;,Key,Value&gt; given Key satisfies Equality given Value satisfies Equality</literal>.
        The expression <literal>Comparable.smallerThan</literal> would be of existential type 
        <literal>MethodConstructor&lt;Value,Boolean,Value&gt; given Value satisfies Comparable&lt;Value&gt;</literal>.</para></comment>
        
        <comment><para>TODO: Do we anyway need some kind of metamodel objects for type 
        constructors like <literal>Entry</literal> or even <literal>Comparable.smallerThan</literal>. 
        These would not support typesafe operations, but would at least allow runtime 
        reflection.</para></comment>
        
        <comment><para>TODO: Are there metamodel objects for block local declarations? This
        includes block local declarations inside a class body, and block local declarations
        inside a method or attribute body.</para></comment>
        
        <comment><para>TODO: Should we have typesafe metamodel reference expressions for 
        parameters? For example: <literal>Parameter&lt;String&gt; wordsParam = Person.say#words;</literal></para></comment>
        
        <!--
        <comment><para>TODO: Should we remodel member metamodel references as members of the 
        metatype? Then we can get rid of two of the following sections. The reason to not do 
        this is that member class metamodel references have the wrong case for an 
        attribute.</para></comment>
        -->
        
        <section id="interfaceandclassmetamodelreferences">
            <title>Interface and class metamodel references</title>
            
        <para>A <literal>Type</literal> object may be obtained by specifying the full
        type, including type arguments if the type is generic.</para>
        
        <programlisting>TypeMeta: Type</programlisting>
        
        <para>The metamodel expression, <literal>X</literal>, for a type, class or interface 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>of type <literal>Interface&lt;X&gt;</literal> where 
                <literal>X</literal> is the interface, or</para>
            </listitem>
            <listitem>
                <para>assignable to <literal>Class&lt;X,P...&gt;</literal> where 
                <literal>X</literal> is the toplevel <literal>abstract</literal> class and 
                <literal>P...</literal> are the types of the parameter list of the class, 
                <!--for every overloaded version of the class,--> or</para>
            </listitem>
            <listitem>
                <para>assignable to <literal>OpenConcreteClass&lt;X,P...&gt;</literal> where 
                <literal>X</literal> is the toplevel concrete class and <literal>P...</literal> 
                are the types of the parameter list of the class, <!--for every overloaded 
                version of the class,--> or</para>
            </listitem>
            <listitem>
                <para>assignable to <literal>OpenMemberClass&lt;X,Y,P...&gt;</literal> where 
                <literal>Y</literal> is the member class and <literal>P...</literal> 
                are the types of the parameter list of the class. <!--for every overloaded 
                version of the class.--></para>
            </listitem>
        </itemizedlist>
        
        <para>Note that for a toplevel class <literal>X</literal>, the expression <literal>X</literal>
        is both a metamodel reference and a callable reference. This is consistent, since
        <literal>Class&lt;X,P...&gt;</literal> is a subtype of <literal>Callable&lt;X,P...&gt;</literal>.</para>
        
        <para>Furthermore, the expression type is assignable to all metatypes of the 
        type&mdash;the types listed in the <literal>is</literal> clause of the type 
        definition. <emphasis>(Note that metatypes are a proposed feature for a 
        future version of the language.)</emphasis></para>
        
        </section>
        
        <section id="toplevelmethodmetamodelreferences">
            <title>Toplevel method metamodel references</title>
            
        <para>A <literal>Function</literal> object representing a toplevel method may be 
        obtained by specifying the method name, with type arguments if the toplevel method 
        is generic.</para>
        
        <programlisting>FunctionMeta: MemberName TypeArguments?</programlisting>
               
        <para>The metamodel expression, <literal>method</literal>, for a toplevel method 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>assignable to <literal>OpenFunction&lt;R,P...&gt;</literal> where 
                <literal>R</literal> is the callable type of a method produced by 
                removing the first parameter list of the method, and <literal>P...</literal> 
                are the types of the first parameter lists of the method. <!--for every 
                overloaded version of the method.--></para>
            </listitem>
        </itemizedlist>
        
        <para>Note that for a toplevel method <literal>x()</literal>, the expression 
        <literal>x</literal> is both a metamodel reference and a callable reference. This 
        is consistent, since <literal>Function&lt;X,P...&gt;</literal> is a subtype of 
        <literal>Callable&lt;X,P...&gt;</literal>.</para>
           
        </section>
        
        <section id="membermethodmetamodelreferences">
            <title>Member method metamodel references</title>
            
        <para>A <literal>Method</literal> object representing a member method may be 
        obtained by specifying the type (with type arguments) and member name, together 
        with type arguments if the method is generic.</para>
        
        <programlisting>MethodMeta: Type "." MemberName TypeArguments?</programlisting>
               
        <para>The metamodel expression, <literal>X.member</literal>, for a member method 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>assignable to <literal>OpenMethod&lt;X,R,P...&gt;</literal> where 
                <literal>X</literal> is the type that defines the method, and 
                <literal>R</literal> is the callable type of a method produced by 
                removing the first parameter list of the method, and 
                <literal>P...</literal> are the types of the first parameter list of 
                the method. <!--for every overloaded version of the method.--></para>
            </listitem>
        </itemizedlist>
         
        </section>
        
        <section id="toplevelattributemetamodelreferences">
            <title>Toplevel attribute metamodel references</title>
            
        <para>A <literal>Value</literal> object representing a toplevel attribute may be 
        obtained by specifying the attribute name, with type arguments if the toplevel method 
        is generic.</para>
        
        <programlisting>ValueMeta: MemberName TypeArguments?</programlisting>
               
        <para>The metamodel expression, <literal>attribute</literal>, for a toplevel attribute 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>of type <literal>OpenValue&lt;T&gt;</literal> where 
                <literal>T</literal> is the declared type of the attribute.<!-- ,
                unless the attribute is declared <literal>variable</literal>, or--></para>
            </listitem>
            <!-- 
            <listitem>
                <para>of type <literal>MutableValue&lt;T&gt;</literal> where 
                <literal>T</literal> is the declared type of the attribute,
                if the attribute is declared <literal>variable</literal>.</para>
            </listitem>
            -->
        </itemizedlist>
        
        <para>Note that for a toplevel attribute <literal>x</literal>, the expression <literal>x</literal>
        is both a metamodel reference and a value reference. This is consistent, since
        <literal>Value&lt;T&gt;</literal> is assignable to <literal>Gettable&lt;T&gt;</literal>.<!-- 
        and <literal>MutableValue&lt;T&gt;</literal> is assignable to <literal>Settable&lt;T&gt;</literal>.--></para>
           
        </section>
        
        <section id="attributemetamodelreferences">
            <title>Member attribute metamodel references</title>
            
        <para>An <literal>Attribute</literal> object representing a member attribute may 
        be obtained by specifying the type (with type arguments) and member name.</para>
        
        <programlisting>AttributeMeta: Type "." MemberName</programlisting>

        <para>The metamodel expression, <literal>X.member</literal>, for a member 
        attribute is:</para>
        
        <itemizedlist>
            <listitem>
                <para>of type <literal>OpenAttribute&lt;X,T&gt;</literal> where 
                <literal>X</literal> is the type that defines the attribute, 
                and <literal>T</literal> is the declared type of the attribute,
                unless the attribute is declared <literal>variable</literal>, or</para>
            </listitem>
            <listitem>
                <para>of type <literal>OpenMutableAttribute&lt;X,T&gt;</literal> where 
                <literal>X</literal> is the type that defines the attribute, 
                and <literal>T</literal> is the declared type of the attribute,
                if the attribute is declared <literal>variable</literal>.</para>
            </listitem>
        </itemizedlist>
         
        </section>
        
        <section id="usingthemetamodel">
            <title>Using the metamodel</title>
            
        <para>The metamodel object for a type allows its members to be iterated:</para>
        
        <programlisting><![CDATA[for (Attribute<obj.subtype,String> attribute 
            in obj.subtype.members(Attribute<obj.subtype,String>)) {
    log.info(attribute.declaringType.name + "." + attribute.name 
                + "=" + attribute(obj));
}]]></programlisting>
        
        <para>The metamodel object for a class, attribute or method satisfies 
        <literal>Callable</literal> and is therefore invokable.</para>
        
        <programlisting>Class&lt;ArrayList&lt;String&gt;,String[]&gt; arrayListClass = ArrayList&lt;String&gt;;
        
List list = arrayListClass("foo", "bar", "baz);</programlisting>
        
        <programlisting>Attribute&lt;Person, String&gt; nameAttribute = Person.name;
        
String personName = nameAttribute(person);</programlisting>
        
        <programlisting>Method&lt;Person, String&gt; sayMethod = Person.say;
        
String result = sayMethod(person)();</programlisting>

        <programlisting>MutableAttribute&lt;Counter, Natural&gt; countAttribute = Counter.count;

countAttribute(this)++;</programlisting>        

        <para>The metamodel object for a class, attribute or method supports registration 
        of a listener, which intercepts invocations.</para>
        
        <programlisting>OpenMutableAttribute&lt;Counter, Natural&gt; countAttribute = Counter.count;

countAttribute.intercept() 
    onGet (Counter c, Natural proceed()) {
        log.debug("getting");
        return proceed();
    };
    
countAttribute.intercept() 
    onSet (Counter c, void proceed(Natural n), Natural value) {
        log.debug("setting");
        proceed(value);
    };</programlisting>

        <programlisting>OpenMethod&lt;Order,Item,Product,Natural&gt; createItemMethod = Order.createItem;
        
createItemMethod.intercept()
    onInvoke (Order o, Item proceed(Product p, Natural n),  
              Product product, Natural quantity) {
        log.debug("invoking in transaction");
        try (Transaction()) {
            return proceed(product,quantity);
        }
    };</programlisting>
    
        </section>
    
        <comment><para>TODO: According to this, we can "curry" in type arguments of
        the type. We need this. But if so, why can't we curry type arguments of the 
        member? It's not a problem from the grammar point of view.</para></comment>
        
    </section>

    <section id="operators">
    <title>Operators</title>
    
    <para>Operators are syntactic shorthand for more complex expressions
    involving method invocation or attribute access. Each operator is defined 
    for a particular type. There is no support for user-defined operator 
    <emphasis>overloading</emphasis>. However, the semantics of an operator 
    may be customized by the implementation of the type that the operator
    applies to. This is called <emphasis>operator polymorphism</emphasis>.</para>
    
    <para>Some examples:</para>
    
    <programlisting>Float z = x * y + 1.0;</programlisting>
    
    <programlisting>even := n % 2 &equals; 0;</programlisting>
    
    <programlisting>++count;</programlisting>
    
    <programlisting>Integer j = i++;</programlisting>
    
    <programlisting>if ( x > 100 || x &lt; 0 ) { ... }</programlisting>
    
    <programlisting>User? gavin = users["Gavin"];</programlisting>
    
    <programlisting>List&lt;Item&gt; firstPage = list[0..20];</programlisting>
    
    <programlisting>for (Natural n in 1..10) { ... }</programlisting>
    
    <programlisting>if (char in `A`..`Z`) { ... }</programlisting>
    
    <programlisting>List&lt;Day&gt; nonworkDays = days[{0,7}];</programlisting>
    
    <programlisting>Natural lastIndex = getLastIndex() ? sequence.lastIndex;</programlisting>
    
    <programlisting>log.info("Hello " + $person + "!")</programlisting>
    
    <programlisting>List&lt;String&gt; names = {person1, person2, person3}[].name;</programlisting>
    
    <programlisting>String? name = person?.name;</programlisting>
    
    <programlisting>this.total += item.price;</programlisting>
        
    <programlisting>Float vol = length**3;</programlisting>
    
    <programlisting>map.define(person.name->person);</programlisting>
    
    <programlisting>order.lineItems[index] := LineItem { product = prod; quantity = 1; };</programlisting>
    
    <programlisting>if (!document.internal || user is Employee) { ... }</programlisting>
    
    <para>In all operator expressions, the arguments of the operator must be 
    evaluated from left to right when the expression is executed. In certain cases, 
    depending upon the definition of the operator, evaluation of the leftmost 
    argument expression results in a value that causes the final value of the 
    operator expression to be produced immediately without evaluation of the 
    remaining argument expressions. Optimizations performed by the Ceylon compiler 
    must not alter these behaviours.</para>
    
    <comment><para>TODO: Should we have operators for function composition, or 
    even partial application. Perhaps infix <literal>:</literal> could be 
    composition and postfix <literal>@</literal> could be partial application.</para></comment>
    
    <section id="operatorexpressions">
        <title>Operator expressions</title>
        
        <para>The type of an operator expression for an operator that is defined to
        produce the type <literal>T</literal> is:</para> 
                        
        <itemizedlist>
            <listitem>
                <para><literal>T</literal>, if <literal>T</literal> is assignable
                to <literal>Gettable&lt;Object&gt;</literal>, or, otherwise,</para>
            </listitem>
            <listitem>
                <para><literal>Gettable&lt;T&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
    </section>
    
    <section id="operatorprecedence">
        <title>Operator precedence</title>
        
        <para>There are 15 distinct operator precedence levels, but these levels
        are arranged into layers in order to make them easier to predict.</para>
        
        <itemizedlist>
            <listitem><para>Operators in layer 1 produce, transform, and combine
            values.</para></listitem>
            <listitem>Operators in layer 2 compare or predicate values, producing
            a <literal>Boolean</literal> result.</listitem>
            <listitem>Operators in layer 3 are logical operators that operate
            upon <literal>Boolean</literal> arguments to produce a <literal>Boolean</literal>
            value.</listitem>
            <listitem>Operators in layer 4 perform assignment.</listitem>
        </itemizedlist>
        
        <para>Within each layer, postfix operators have a higher precedence than 
        prefix operators, and prefix operators have a higher precedence than 
        binary operators.</para>
        
        <para>There is a single exception to this principal: the binary 
        exponentiation operator <literal>**</literal> has a higher precedence than 
        the prefix operators <literal>+</literal> and <literal>-</literal>. The 
        reason for this is that the following expressions should be equivalent:</para>
        
        <programlisting>-x**2       //means -(x**2)</programlisting>
        <programlisting>0 - x**2    //means 0 - (x**2)</programlisting>
        
        <para>It's important to be aware that in Ceylon, compared to other C-like 
        languages, the logical not operator <literal>!</literal> has a very low
        precedence. The following expressions are equivalent:</para>
        
        <programlisting>!x.y*2 &equals; 0.0  //means !(x.y*2 &equals; 0.0)</programlisting>
        <programlisting>x.y*2 != 0.0</programlisting>
        
        <para>This table defines the relative precedence of the various operators, 
        from highest to lowest, along with associativity rules:</para>
        
        <table>
        <tgroup cols="4">
            <colspec colnum="1" colwidth="2.5*" align="center" colname="first"/>
            <colspec colnum="2" colwidth="2.0*" align="center"/>
            <colspec colnum="3" colwidth="1.0*" align="center"/>
            <colspec colnum="4" colwidth="0.7*" align="center" colname="last"/>
        <thead>
            <row>
                <entry>Operations</entry>
                <entry>Operators</entry>
                <entry>Type</entry>
                <entry>Associativity</entry>
            </row>
        </thead>
        <tbody>
        
            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 1</emphasis></entry>
            </row>
    
            <row>
                <entry>Member invocation and lookup, subrange,
                postfix increment, postfix decrement:</entry>
                <entry>
                <literal>.</literal>,
                <literal>[].</literal>, 
                <literal>?.</literal>, 
                <literal>()</literal>,
                <literal>{}</literal>,
                <literal>[]</literal>,
                <literal>?[]</literal>,
                <literal>[..]</literal>, 
                <literal>[...]</literal>,
                <literal>++</literal>, 
                <literal>--</literal></entry>
                <entry>Binary / ternary / N-ary / unary postfix</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Prefix increment, prefix decrement:</entry>
                <entry>
                <literal>++</literal>, 
                <literal>--</literal>
                </entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Exponentiation:</entry>
                <entry>
                <literal>**</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>            
            <row>
                <entry>Negation, slotwise complement, format:</entry>
                <entry>
                <literal>+</literal>,
                <literal>-</literal>, 
                <literal>~</literal>,
                <literal>$</literal> 
                </entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <!--  
            <row>
                <entry>Exponentiation, shift:</entry>
                <entry>
                <literal>**</literal>,
                <literal>&lt;&lt;</literal>, 
                <literal>>></literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            -->
            <row>
                <entry>Multiplication, division, remainder,
                slotwise and:</entry> 
                <entry>
                <literal>*</literal>, 
                <literal>/</literal>, 
                <literal>%</literal>,
                <literal>&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Addition, subtraction, slotwise or,
                slotwise xor, slotwise complement in, list 
                concatenation:</entry> 
                <entry>
                <literal>+</literal>, 
                <literal>-</literal>, 
                <literal>|</literal>, 
                <literal>^</literal>,
                <literal>~</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <!--row>
                <entry>Date/time composition:</entry> 
                <entry><literal>@</literal></entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row-->
            <row>
                <entry>Range<!--, interval--> and entry construction:</entry> 
                <entry><literal>..</literal>, <literal>-></literal></entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Default:</entry> 
                <entry><literal>?</literal></entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>

            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 2</emphasis></entry>
            </row>
    
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>exists</literal>, <literal>nonempty</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            <!--
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>?</literal>, <literal>??</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            -->
            <row>
                <entry>Comparison, <!--set comparison,--> containment,
                assignability, inheritance:</entry> 
                <entry>
                <literal>&lt;=&gt;</literal>,
                <literal>&lt;</literal>, 
                <literal>&gt;</literal>, 
                <literal>&lt;=</literal>, 
                <literal>&gt;=</literal>,
                <!--<literal>~></literal>,
                <literal>!~></literal>,
                <literal>*~></literal>-->
                <literal>in</literal>,
                <literal>is</literal>,
                <literal>extends</literal>,
                <literal>satisfies</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Equality, identity:</entry>
                <entry>
                <literal>&equals;</literal>, 
                <literal>!=</literal>, 
                <literal>&identical;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
        
            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 3</emphasis></entry>
            </row>
    
            <row>
                <entry>Logical not:</entry>
                <entry><literal>!</literal></entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Logical and:</entry> 
                <entry>
                <literal>&amp;&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Logical or:</entry>
                <entry>
                <literal>||</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            
            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 4</emphasis></entry>
            </row>
    
            <row>
                <entry>Assignment:</entry> 
                <entry>
                <literal>:=</literal>, 
                <literal>.=</literal>,
                <literal>+=</literal>, 
                <literal>-=</literal>, 
                <literal>*=</literal>, 
                <literal>/=</literal>, 
                <literal>%=</literal>, 
                <literal>&amp;=</literal>, 
                <literal>|=</literal>, 
                <literal>^=</literal>, 
                <literal>~=</literal>, 
                <literal>&amp;&amp;=</literal>, 
                <literal>||=</literal>,
                <literal>?=</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            
        </tbody>
        </tgroup>
        </table>

    <!-- 
    <comment><para>TODO: should <literal>^</literal> have a higher precedence than
    <literal>|</literal> like in C and Java? No, cos no-one will ever remember which
    comes first.</para></comment>
    -->
    <!--
    <comment><para>TODO: should <literal>^,|,&amp;</literal> have a lower precedence
    than <literal>+,-,*,/</literal> like in Ruby? No point, cos numbers are not bit 
    strings and bit strings are not numbers in Ceylon.</para></comment>
    -->
    
        <comment><para>Note: if we decide to add <literal>&lt;&lt;</literal> and 
        <literal>&gt;&gt;</literal> later, we could give them the same precedence
        as <literal>**</literal>.</para></comment>
    
    </section>
    
    <section id="operatordefinition">
        <title>Operator definition</title>
        
    <para>The following tables define the semantics of the Ceylon operators. 
    There are four basic operators which do not have a definition in terms of 
    other operators or invocations:</para>
    
    <itemizedlist>
        <listitem>
            <para>the <emphasis>member selection</emphasis> operator
            <literal>.</literal> separates the receiver expression and member 
            name in a callable reference expression or attribute reference 
            expression,</para>
        </listitem>
        <listitem>
            <para>the <emphasis>argument specification</emphasis> operators
            <literal>()</literal> and <literal>{}</literal> specify the 
            argument list of an invocation,</para>
        </listitem>
        <listitem>
            <para>the <emphasis>assignment</emphasis> operator
            <literal>:=</literal> assigns a new value to an instance of
            <literal>Settable</literal> and returns the new value after 
            assignment,</para>
        </listitem>
        <!-- 
        <listitem>
            <para>the <emphasis>identity</emphasis> operator
            <literal>&identical;</literal> evaluates to <literal>true</literal> 
            if its argument expressions evaluate to references to the same 
            object, and <literal>false</literal> otherwise, and</para>
        </listitem>
        -->
        <listitem>
            <para>the <emphasis>assignability</emphasis> operator
            <literal>is</literal> evaluates to <literal>true</literal> if 
            its argument expression evaluates to an instance of a class
            assignable to the specified type, and <literal>false</literal> 
            otherwise.</para>
        </listitem>
        <!-- 
        <listitem>
            <para>the <emphasis>existence</emphasis> operator
            <literal>exists</literal> evaluates to <literal>true</literal> if 
            its argument expression evaluates to an instance of 
            <literal>Object</literal>, and <literal>false</literal> 
            otherwise.</para>
        </listitem>
        -->
    </itemizedlist>
        
    <para>All other operators are defined in terms of other operators and/or
    invocations.</para>
    
    <para>In the tables, the following pseudo-code is used, which is not legal
    Ceylon syntax:</para>
    
    <para>First,</para>
    
    <programlisting>if (b) then x else y   //pseudocode</programlisting>
    
    <!--
    <para>means the value of <literal>result</literal> after execution of the
    following:</para>
    
    <programlisting>X result; if (b) { result=x } else { result=y }</programlisting>
    -->
    
    <para>means the same value produced by the Ceylon library method 
    <literal>when()</literal>:</para>
    
    <programlisting>when (b) then (x) else (y)</programlisting>
    
    <para>Second,</para>
    
    <programlisting>if (exists o) then x else y   //pseudocode</programlisting>
    
    <para>means the same value produced by the Ceylon library method 
    <literal>with()</literal>:</para>
    
    <programlisting>with (o) then (x) else (y)</programlisting>
    
    <para>Third,</para>
    
    <programlisting>for (X x in c) e      //pseudocode</programlisting>
    
    <!--
    <para>means the value of <literal>result</literal> after execution of the
    following:</para>
    
    <programlisting>OpenList&lt;E&gt; result = none; for (X x in c) { result.add(e); }</programlisting>
    -->
    
    <para>means the same value produced by the Ceylon library method 
    <literal>from()</literal>:</para>
    
    <programlisting>from (X x in c) select (e)</programlisting>
    
    <para>The tables define semantics only. The compiler is permitted to emit equivalent 
    bytecode that produces the same value as the pseudo-code that defines the operator, 
    without actually executing any invocation, for the following operators:</para>
    
    <itemizedlist>
        <listitem>
            <para>all arithmetic operators,</para>
        </listitem>
        <listitem>
            <para>all slotwise operators,</para>
        </listitem>
        <listitem>
            <para>the comparison and equality operators <literal>&equals;</literal>,
            <literal>!=</literal>, <literal>&lt;=&gt;</literal>, <literal>&lt;</literal>,
            <literal>&gt;</literal>, <literal>&lt;=</literal>, <literal>&gt;=</literal>
            when the argument expression types are built-in numeric types,</para>
        </listitem>
        <listitem>
            <para>the <literal>Range</literal> and <literal>Entry</literal> construction 
            operators <literal>..</literal> and <literal>-></literal>,</para>
        </listitem>
        <listitem>
            <para>the sequence concatenation operator <literal>+</literal>,</para>
        </listitem>
        <listitem>
            <para>the identity equality operator <literal>&identical;</literal>, and</para>
        </listitem>
        <listitem>
            <para>all assignment and compound assignment operators.</para>
        </listitem>
    </itemizedlist>
    
    <para>Therefore, listeners registered for the method invocations and class 
    instantiations that define these operators may not be called when the operator 
    expressions are executed.</para>
    
    </section>
    
    <section id="basic">
    <title>Basic invocation and assignment operators</title>
    
        <para>These operators support method invocation and attribute evaluation and
        assignment. The <literal>$</literal> operator is a shortcut for converting
        any expression to a <literal>String</literal>.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs.member</literal></entry>
            <entry>member</entry>
            <entry></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Member &lt;X,T&gt;</literal></entry>
            <entry><literal>Gettable&lt;T&gt;</literal> or
            <literal>T</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs{a=x;b=y;}</literal></entry>
            <entry>invoke</entry>
            <entry></entry>
            <entry><literal>Callable &lt;T,P...&gt;</literal></entry>
            <entry><literal>P...</literal></entry>
            <entry><literal>Gettable&lt;T&gt;</literal> or
            <literal>T</literal></entry>
        </row>
                
        <row><entry namest="first" nameend="last"><emphasis>Assignment</emphasis></entry></row>
    
        <row>
            <entry><literal>lhs := rhs</literal></entry>
            <entry>assign</entry>
            <entry><literal></literal></entry>
            <entry><literal>Settable&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Format</emphasis></entry></row>
        
        <row>
            <entry><literal>$rhs</literal></entry>
            <entry>format</entry>
            <entry><literal>rhs.formatted</literal></entry>
            <entry></entry>
            <entry><literal>Format</literal></entry>
            <entry><literal>String</literal></entry>
        </row>
    
        <row><entry namest="first" nameend="last"><emphasis>Compound invocation assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs.=member</literal></entry>
            <entry>follow</entry>
            <entry><literal>lhs:=lhs.member</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Attribute &lt;X,X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>

        <row>
            <entry><literal>lhs.=member(x,y,z)</literal></entry>
            <entry>apply</entry>
            <entry><literal>lhs:=lhs.member(x,y,z)</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Method &lt;X,X,P..&gt;</literal>,
            together with arguments <literal>P...</literal></entry>
            <entry><literal>X</literal></entry>
        </row>

     </tbody>
    </tgroup>
    </table>
        
        <comment><para>TODO: do we really need the <literal>$</literal> operator?</para></comment>
        
        <!--
        <para>Member specification uses one of three different member specification operators:
        <literal>.</literal>, <literal>.?</literal> or <literal>.*</literal>.</para>
        
        <para>The member specification operator depends upon the type of the receiver expression. 
        If <literal>X</literal> is the type that declares the member, the invocation operator must 
        be:</para>
            
        <itemizedlist>
            <listitem>
                <para><literal>.</literal> if the expression is of type <literal>X</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>.?</literal> if the expression is of type <literal>X?</literal>,
                or</para>
            </listitem>
            <listitem>
                <para><literal>.*</literal> if the expression is of type <literal>Iterable&lt;X&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
                
        <para>The type of an invocation (argument specification) expression depends upon the type of 
        the receiver expression:</para>
            
        <itemizedlist>
            <listitem>
                <para><literal>T</literal> if the receiver expression is of type 
                <literal>Callable&lt;T&gt;</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>T?</literal> if the expression is of type 
                <literal>Callable&lt;T&gt;?</literal>,
                or</para>
            </listitem>
            <listitem>
                <para><literal>Sequence&lt;T&gt;</literal> if the expression is of type 
                <literal>Iterable&lt;Callable&lt;T&gt;&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>The arguments specified in the argument specification must be assignable to the
        parameters of the method reference.</para>
        -->
        
    </section>
        
    <section id="equalitycomparison">
    <title>Equality and comparison operators</title>
    
        <para>These operators compare values for equality, order, magnitude, or membership,
        producing boolean values.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Equality and identity</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs &identical; rhs</literal></entry>
            <entry>identical</entry>
            <entry><literal>identical(lhs,rhs)</literal></entry>
            <entry><literal>IdentifiableObject</literal></entry>
            <entry><literal>IdentifiableObject</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &equals; rhs</literal></entry>
            <entry>equal</entry>
            <entry><literal>lhs.equals(rhs)</literal></entry>
            <entry><literal>Equality&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs != rhs</literal></entry>
            <entry>not equal</entry>
            <entry><literal>!lhs.equals(rhs)</literal></entry>
            <entry><literal>Equality&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Comparison</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs &lt;=&gt; rhs</literal></entry>
            <entry>compare</entry>
            <entry><literal>lhs.compare(rhs)</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Comparison</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &lt; rhs</literal></entry>
            <entry>smaller</entry>
            <entry><literal>lhs.smallerThan(rhs)</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &gt; rhs</literal></entry>
            <entry>larger</entry>
            <entry><literal>lhs.greaterThan(rhs)</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &lt;= rhs</literal></entry>
            <entry>small as</entry>
            <entry><literal>lhs.asSmallAs(rhs)</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &gt;= rhs</literal></entry>
            <entry>large as</entry>
            <entry><literal>lhs.asLargeAs(rhs)</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Containment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs in rhs</literal></entry>
            <entry>in</entry>
            <entry><literal>lhs.contained(rhs)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Category</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Assignability</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs is Rhs</literal></entry>
            <entry>is</entry>
            <entry></entry>
            <entry><literal>Object?</literal></entry>
            <entry>literal <literal>Type&lt;Void&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
                
        <row><entry namest="first" nameend="last"><emphasis>Inheritance</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs extends rhs</literal></entry>
            <entry>extends</entry>
            <entry><literal>lhs.extendsType(rhs)</literal></entry>
            <entry><literal>Type&lt;Void&gt;</literal></entry>
            <entry><literal>Class &lt;Void&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs satisfies rhs</literal></entry>
            <entry>satisfies</entry>
            <entry><literal>lhs.satisfiesType(rhs)</literal></entry>
            <entry><literal>Type&lt;Void&gt;</literal></entry>
            <entry><literal>Type&lt;Void&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
        <comment><para>TODO: Should we have allow the operators <literal>&lt;=</literal> 
        and <literal>&gt;=</literal> to handle partial orders? A particular usecase is
        <literal>Set</literal> comparison.</para></comment>
        
    </section>
                
    <section id="logical">
    <title>Logical operators</title>
    
        <para>These are the usual logical operations for boolean values.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Logical operators</emphasis></entry></row>
        
        <row>
            <entry><literal>!rhs</literal></entry>
            <entry>not</entry>
            <entry><literal>if (rhs) false else true</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs || rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else rhs</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &amp;&amp; rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) rhs else false</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Logical assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs ||= rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else lhs:=rhs</literal></entry>
            <entry><literal>Settable &lt;Boolean&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row>
            <entry><literal>lhs &amp;&amp;= rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) lhs:=rhs else false</literal></entry>
            <entry><literal>Settable &lt;Boolean&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="nullvalues">
    <title>Operators for handling null values</title>
    
        <para>These operators make it easy to work with optional expressions.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Existence</emphasis></entry></row>
        
        <row>
            <entry><!--<<literal>lhs?</literal> or --><literal>lhs exists</literal></entry>
            <entry>exists</entry>
            <entry><literal>if (exists lhs) true else false</literal></entry>
            <entry><literal>Object?</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal><!--??-->lhs nonempty</literal></entry>
            <entry>nonempty</entry>
            <entry><literal>if (nonempty lhs) true else false</literal></entry>
            <entry><literal>Object[]?</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Default</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs ? rhs</literal></entry>
            <entry>default</entry>
            <entry><literal>if (exists lhs) lhs else rhs</literal></entry>
            <entry><literal>T?</literal></entry>
            <entry><literal>T</literal> or <literal>T?</literal></entry>
            <entry><literal>T</literal> or <literal>T?</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Default assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs ?= rhs</literal></entry>
            <entry>default assignment</entry>
            <entry><literal>if (exists lhs) lhs else lhs:=rhs</literal></entry>
            <entry><literal>Settable&lt;T?&gt;</literal></entry>
            <entry><literal>T</literal> or <literal>T?</literal></entry>
            <entry><literal>T</literal> or <literal>T?</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Nullafe invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs?.member</literal></entry>
            <entry>nullsafe member</entry>
            <entry><literal>if (exists lhs) lhs.member else null</literal></entry>
            <entry><literal>X?</literal></entry>
            <entry><literal>Member &lt;X,T&gt;</literal></entry>
            <entry><literal>T?</literal></entry>
        </row>

        <row>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs{a=x;b=y;}</literal></entry>
            <entry>nullsafe invoke</entry>
            <entry><literal>if (exists lhs) lhs(x,y,z) else null</literal></entry>
            <entry><literal>Callable &lt;T,P...&gt;?</literal></entry>
            <entry><literal>P...</literal></entry>
            <entry><literal>T?</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>

    <section id="listmap">
    <title>Correspondence and sequence operators</title>
    
        <para>These operators provide a simplified syntax for accessing values 
        of a <literal>Correspondence</literal>, and for joining and obtaining
        subranges of <literal>Sequence</literal>s.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Keyed element access</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs[index]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.value(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Gettable &lt;Y?&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[index]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.value(index)</literal></entry>
            <entry><literal>OpenCorrespondence &lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Settable &lt;Y?&gt;</literal></entry>
        </row>
        <!--
        <row>
            <entry><literal>lhs[index]</literal></entry>
            <entry>bounded lookup</entry>
            <entry><literal>lhs.value(index)</literal></entry>
            <entry><literal>Y[n]</literal></entry>
            <entry><literal>Bound&lt;#n&gt;</literal></entry>
            <entry><literal>Gettable &lt;Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[index]</literal></entry>
            <entry>bounded lookup</entry>
            <entry><literal>lhs.value(index)</literal></entry>
            <entry><literal>OpenBoundedSequence &lt;Y,n&gt;</literal></entry>
            <entry><literal>Bound&lt;#n&gt;</literal></entry>
            <entry><literal>Settable &lt;Y&gt;</literal></entry>
        </row>
        -->
        <row>
            <entry><literal>lhs?[index]</literal></entry>
            <entry>nullsafe lookup</entry>
            <entry><literal>if (exists lhs) lhs[index] else null</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;?</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Y?</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[indices]</literal></entry>
            <entry>sequenced lookup</entry>
            <entry><literal>lhs.values(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>Y[]</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[indices]</literal></entry>
            <entry>iterated lookup</entry>
            <entry><literal>lhs.values(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>Iterable &lt;X&gt;</literal></entry>
            <entry><literal>Iterable &lt;Y&gt;</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Sequence subranges</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs[x..y]</literal></entry>
            <entry>subrange</entry>
            <entry><literal>range(lhs,x,y)</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry>Two <literal>Natural</literal> values</entry>
            <entry><literal>X[]</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[x...]</literal></entry>
            <entry>upper range</entry>
            <entry><literal>range(lhs,x)</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>X[]</literal></entry>
        </row>
        <!--
        <row>
            <entry><literal>lhs[...y]</literal></entry>
            <entry>lower range</entry>
            <entry><literal>lhs.range(0,y)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        -->
        
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Sequence concatenation</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>join</entry>
            <entry><literal>join(lhs, rhs)</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>X[]</literal></entry>
        </row>
        -->
        
        <row><entry namest="first" nameend="last"><emphasis>Spread invocation</emphasis></entry></row>

        <row>
            <entry><literal>lhs[].member</literal></entry>
            <entry>spread member</entry>
            <entry><literal>for (X x in lhs) x.member</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>Member &lt;X,T&gt;</literal></entry>
            <entry><literal>T[]</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs{a=x;b=y;}</literal></entry>
            <entry>spread invoke</entry>
            <entry><literal>for (C c in lhs) c(x,y,z)</literal></entry>
            <entry><literal>Callable &lt;T,P...&gt;[]</literal></entry>
            <entry><literal>P...</literal></entry>
            <entry><literal>T[]</literal></entry>
        </row>
        <!--  
        
        <row><entry namest="first" nameend="last"><emphasis>Shift</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs &lt;&lt; rhs</literal></entry>
            <entry>left shift</entry>
            <entry><literal>lhs.shiftLeft(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs >> rhs</literal></entry>
            <entry>right shift</entry>
            <entry><literal>lhs.shiftRight(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        
        -->
        
        <!--
        <row>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>cartesian product</entry>
            <entry><literal>lhs.product(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;Pair&lt;X,Y&gt;&gt;</literal></entry>
        </row>
        -->
        
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: Should <literal>x[i..j]</literal> return the elements
    from <literal>i</literal> to <literal>j-1</literal>, like in most other
    languages?</para></comment>
    
    <comment><para>TODO: I'm increasingly warming to the idea of a non-destructive 
    add ("with") operator <literal>@</literal> and <literal>@=</literal>. This is
    an operation that is very efficient for some kinds of data structures (linked lists, 
    etc).</para></comment>
    
    </section>
    
    <section id="constructors">
    <title>Operators for creating objects</title>
    
        <para>These operators simplify the syntax for creating certain commonly 
        used built-in types.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Range and entry constructors</emphasis></entry></row>

        <row>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>range</entry>
            <entry><literal>Range(lhs, rhs)</literal></entry>
            <entry><literal>T given T satisfies Ordinal &amp; Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Range&lt;T&gt;</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs -> rhs</literal></entry>
            <entry>entry</entry>
            <entry><literal>Entry(lhs, rhs)</literal></entry>
            <entry><literal>U given U satisfies Equality&lt;U&gt;</literal></entry>
            <entry><literal>V given V satisfies Equality&lt;V&gt;</literal></entry>
            <entry><literal>Entry&lt;U,V&gt;</literal></entry>
        </row>
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Datetime and interval constructors</emphasis></entry></row>

        <row>
            <entry><literal>lhs @ rhs</literal></entry>
            <entry>datetime</entry>
            <entry><literal>Datetime(lhs, rhs)</literal></entry>
            <entry><literal>Date</literal></entry>
            <entry><literal>Time</literal></entry>
            <entry><literal>Datetime</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>interval</entry>
            <entry><literal>Interval(lhs, rhs)</literal></entry>
            <entry><literal>T given T satisfies Instant</literal></entry>
            <entry><literal>Instant&lt;T&gt;</literal></entry>
            <entry><literal>Interval&lt;T&gt;</literal></entry>
        </row>
        
        -->
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="arithmetic">
    <title>Arithmetic operators</title>
    
        <para>These are the usual mathematical operations for all kinds of
        numeric values.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Increment, decrement</emphasis></entry></row>
        
        <!-- Prefix increment, decrement -->
        
        <row>
            <entry><literal>++rhs</literal></entry>
            <entry>successor</entry>
            <entry><literal>rhs:=rhs.successor</literal></entry>
            <entry></entry>
            <entry><literal>Settable &lt;Ordinal&lt;T&gt;&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>--rhs</literal></entry>
            <entry>predecessor</entry>
            <entry><literal>rhs:=rhs.predecessor</literal></entry>
            <entry></entry>
            <entry><literal>Settable &lt;Ordinal&lt;T&gt;&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <!-- Postfix increment, decrement -->
        
        <row>
            <entry><literal>lhs++</literal></entry>
            <entry>increment</entry>
            <entry><literal>(++lhs).predecessor</literal></entry>
            <entry><literal>Settable &lt;Ordinal&lt;T&gt;&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>lhs--</literal></entry>
            <entry>decrement</entry>
            <entry><literal>(--lhs).successor</literal></entry>
            <entry><literal>Settable &lt;Ordinal&lt;T&gt;&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric operators</emphasis></entry></row>
        
        <!-- Unary positive and negative -->
        
        <row>
            <entry><literal>+rhs</literal></entry>
            <entry></entry>
            <entry><literal>rhs.value</literal></entry>
            <entry></entry>
            <entry><literal>Invertable &lt;I&gt;</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        
        <row>
            <entry><literal>-rhs</literal></entry>
            <entry>negation</entry>
            <entry><literal>rhs.inverse</literal></entry>
            <entry></entry>
            <entry><literal>Invertable &lt;I&gt;</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        
        <!-- Numeric -->
        
        <row>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>sum</entry>
            <entry><literal>lhs.cast&lt;N&gt;() .plus(rhs.cast&lt;N&gt;())</literal></entry>
            <entry><literal>X satisfies Castable&lt;N&gt; &amp; Summable&lt;X&gt;</literal></entry>
            <entry><literal>Y satisfies Castable&lt;N&gt; &amp; Summable&lt;X&gt;</literal></entry>
            <entry><literal>N of X|Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>difference</entry>
            <entry><literal>lhs.cast&lt;N&gt;() .minus(rhs.cast&lt;N&gt;())</literal></entry>
            <entry><literal>X satisfies Castable&lt;N&gt; &amp; Numeric&lt;X&gt;</literal></entry>
            <entry><literal>Y satisfies Castable&lt;N&gt; &amp; Numeric&lt;X&gt;</literal></entry>
            <entry><literal>N of X|Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>product</entry>
            <entry><literal>lhs.cast&lt;N&gt;() .times(rhs.cast&lt;N&gt;())</literal></entry>
            <entry><literal>X satisfies Castable&lt;N&gt; &amp; Numeric&lt;X&gt;</literal></entry>
            <entry><literal>Y satisfies Castable&lt;N&gt; &amp; Numeric&lt;X&gt;</literal></entry>
            <entry><literal>N of X|Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>quotient</entry>
            <entry><literal>lhs.cast&lt;N&gt;() .divided(rhs.cast&lt;N&gt;())</literal></entry>
            <entry><literal>X satisfies Castable&lt;N&gt; &amp; Numeric&lt;X&gt;</literal></entry>
            <entry><literal>Y satisfies Castable&lt;N&gt; &amp; Numeric&lt;X&gt;</literal></entry>
            <entry><literal>N of X|Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs % rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs.cast&lt;N&gt;() .remainder(rhs.cast&lt;N&gt;())</literal></entry>
            <entry><literal>X satisfies Castable&lt;N&gt; &amp; Integral&lt;X&gt;</literal></entry>
            <entry><literal>Y satisfies Castable&lt;N&gt; &amp; Integral&lt;X&gt;</literal></entry>
            <entry><literal>N of X|Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ** rhs</literal></entry>
            <entry>power</entry>
            <entry><literal>lhs.cast&lt;N&gt;() .power(rhs.cast&lt;N&gt;())</literal></entry>
            <entry><literal>X satisfies Castable&lt;N&gt; &amp; Numeric&lt;X&gt;</literal></entry>
            <entry><literal>Y satisfies Castable&lt;N&gt; &amp; Numeric&lt;X&gt;</literal></entry>
            <entry><literal>N of X|Y</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs += rhs</literal></entry>
            <entry>add</entry>
            <entry><literal>lhs:=lhs .plus(rhs.cast&lt;N&gt;())</literal></entry>
            <entry><literal>Settable &lt;Numeric&lt;N&gt;&gt;</literal></entry>
            <entry><literal>Castable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs -= rhs</literal></entry>
            <entry>subtract</entry>
            <entry><literal>lhs:=lhs .minus(rhs.cast&lt;N&gt;())</literal></entry>
            <entry><literal>Settable &lt;Numeric&lt;N&gt;&gt;</literal></entry>
            <entry><literal>Castable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs *= rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>lhs:=lhs .times(rhs.cast&lt;N&gt;())</literal></entry>
            <entry><literal>Settable &lt;Numeric&lt;N&gt;&gt;</literal></entry>
            <entry><literal>Castable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs /= rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>lhs:=lhs .divided(rhs.cast&lt;N&gt;())</literal></entry>
            <entry><literal>Settable &lt;Numeric&lt;N&gt;&gt;</literal></entry>
            <entry><literal>Castable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs %= rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs:=lhs .remainder(rhs.cast&lt;N&gt;())</literal></entry>
            <entry><literal>Settable &lt;Integral&lt;N&gt;&gt;</literal></entry>
            <entry><literal>Castable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Duration arithmetic</emphasis></entry></row>
                
        <row>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>extend</entry>
            <entry><literal>lhs.extend(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>curtail</entry>
            <entry><literal>lhs.curtail(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>lhs.times(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>lhs.divide(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        -->
                
    </tbody>
    </tgroup>
    </table>
    
        <!--
        <para>Built-in converters allow for type promotion of numeric values used in 
        expressions. Converters exist for the following numeric types:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>Natural</literal> to <literal>Integer</literal>,
                <literal>Float</literal>, <literal>Whole</literal> and 
                <literal>Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>Integer</literal> to <literal>Float</literal>,
                <literal>Whole</literal> and <literal>Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>Float</literal> to <literal>Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>Whole</literal> to <literal>Decimal</literal></para>
            </listitem>
        </itemizedlist>
        
        <para>This means that <literal>x + y</literal> is defined for any combination 
        of numeric types <literal>X</literal> and <literal>Y</literal>, except for 
        the combination <literal>Float</literal> and <literal>Whole</literal>, and that
        <literal>x + y</literal> always produces the same value, with the same type, as
        <literal>y + x</literal>.</para>
        -->
        
        <para>Ceylon's numeric type system is designed to accommodate the following
        considerations:</para>
        
        <itemizedlist>
            <listitem>
                <para>The system is extensible and new numeric types may be defined
                by libraries. Numeric types defined by libraries should work the 
                same as built-in numeric types.</para>
            </listitem>
            <listitem>
                <para>Two values of different numeric types should be combinable
                using operators without the need for explicit type conversions, 
                but</para>
            </listitem>
            <listitem>
                <para>implicit type conversions should never lose information
                and</para>
            </listitem>
            <listitem>
                <para>binary operators must be symmetric.</para>
            </listitem>
            <listitem>
                <para>Furthermore, there should be no special cases in the language 
                definition or type checker to accommodate numeric types.</para>
            </listitem>
            <listitem>
                <para>However, it must be possible for the compiler to optimize 
                certain of the built-in numeric types to take advantage of the VM's 
                native support for numeric types.</para>
            </listitem>
            <listitem>
                <para>It is not necessary to encode information about the limits
                of the machine's representation of a numeric value into the type
                system. A single <literal>Integer</literal> class is sufficient
                to represent 32, 64, or 128 bit integer values. A single 
                <literal>Float</literal> class is sufficient to represent single
                and double precision floating point values. It is simply not
                possible for the compiler to detect numeric overflow or loss of
                significant precision.</para>
            </listitem>
        </itemizedlist>
        
    </section>
    
    <section id="slotwise">
    <title>Slotwise operators</title>
    
        <para>The C-style bitwise operators are generalized to apply to other types that 
        are formed from boolean-valued "slots". The interface <literal>Slots</literal> 
        defines the necessary abstraction.</para>
        
        <itemizedlist>
            <listitem>
                <para>The class <literal>Byte</literal> represents a fixed length bit string. 
                In this case, the operators are the standard bitwise operators from other 
                C-like languages.</para>
            </listitem>
            <listitem>
                <para>A <literal>Boolean</literal> can be seen as a bit string of length 
                one, so these operators also apply to <literal>Boolean</literal> values.</para>
            </listitem>
            <listitem>
                <para>A <literal>Set&lt;T&gt;</literal>, together with the <literal>in</literal> 
                operator, may also be viewed in terms of slots, so the operators apply to 
                <literal>Set</literal>s, where <literal>|</literal>, <literal>&amp;</literal>
                and binary <literal>~</literal> are interpreted as set union, intersection 
                and complement operators.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that in Ceylon these operators have a higher precedence than they have 
        in C or Java. Note also that the built-in numeric types are not bit strings, so 
        explicit conversion to <literal>Bits&lt;#n&gt;</literal> is required before these 
        operators may be applied to a numeric value.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Slotwise operators</emphasis></entry></row>
        
        <row>
            <entry><literal>~rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>rhs.complement</literal></entry>
            <entry></entry>
            <entry><literal>FixedSlots&lt;B&gt;</literal></entry>
            <entry><literal>B</literal></entry>
        </row>
        <row>
            <entry><literal>lhs | rhs</literal></entry>
            <entry>or</entry>
            <entry><literal>lhs.or(rhs)</literal></entry>
            <entry><literal>Slots&lt;B&gt;</literal></entry>
            <entry><literal>B</literal></entry>
            <entry><literal>B</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &amp; rhs</literal></entry>
            <entry>and</entry>
            <entry><literal>lhs.and(rhs)</literal></entry>
            <entry><literal>Slots&lt;B&gt;</literal></entry>
            <entry><literal>B</literal></entry>
            <entry><literal>B</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ^ rhs</literal></entry>
            <entry>exclusive or</entry>
            <entry><literal>lhs.xor(rhs)</literal></entry>
            <entry><literal>Slots&lt;B&gt;</literal></entry>
            <entry><literal>B</literal></entry>
            <entry><literal>B</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ~ rhs</literal></entry>
            <entry>complement in</entry>
            <entry><literal>lhs.complement(rhs)</literal></entry>
            <entry><literal>Slots&lt;B&gt;</literal></entry>
            <entry><literal>B</literal></entry>
            <entry><literal>B</literal></entry>
        </row>

        
        <row><entry namest="first" nameend="last"><emphasis>Slotwise assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs |= rhs</literal></entry>
            <entry>or</entry>
            <entry><literal>lhs:=lhs|rhs</literal></entry>
            <entry><literal>Settable &lt;Slots&lt;B&gt;&gt;</literal></entry>
            <entry><literal>B</literal></entry>
            <entry><literal>B</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &amp;= rhs</literal></entry>
            <entry>and</entry>
            <entry><literal>lhs:=lhs&amp;rhs</literal></entry>
            <entry><literal>Settable &lt;Slots&lt;B&gt;&gt;</literal></entry>
            <entry><literal>B</literal></entry>
            <entry><literal>B</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ^= rhs</literal></entry>
            <entry>exclusive or</entry>
            <entry><literal>lhs:=lhs^rhs</literal></entry>
            <entry><literal>Settable &lt;Slots&lt;B&gt;&gt;</literal></entry>
            <entry><literal>B</literal></entry>
            <entry><literal>B</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ~= rhs</literal></entry>
            <entry>complement in</entry>
            <entry><literal>lhs:=lhs~rhs</literal></entry>
            <entry><literal>Settable &lt;Slots&lt;B&gt;&gt;</literal></entry>
            <entry><literal>B</literal></entry>
            <entry><literal>B</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
        <comment><para>TODO: should we support the traditional C-style <literal>&gt;&gt;</literal> 
        and <literal>&lt;&lt;</literal> bitshift operators?</para></comment>
    
    </section>
    
    </section>
    
</chapter>