<chapter id="expressions">
    <title>Expressions</title>
    
    <para>An <emphasis>expression</emphasis> produces a value when executed. An 
    algorithm expressed using functions and expressions, rather than sequences 
    of statements is often easier to understand and refactor. Therefore, Ceylon
    has a highly flexible expressions syntax. Expressions are formed from:</para>
    
    <itemizedlist>
        <listitem>
            <para>literal values, string templates, and self references,</para>
        </listitem>
        <listitem>
            <para>evaluation and assignment of values,</para>
        </listitem>
        <listitem>
            <para>invocation of functions and instantiation of classes,</para> 
        </listitem>
        <listitem>
            <para>callable references, static references, and anonymous functions,</para>
        </listitem>
        <listitem>
            <para>comprehensions,</para>
        </listitem>
        <listitem>
            <para>metamodel references,</para>
        </listitem>
        <listitem>
            <para>enumeration of iterables and tuples, and</para>
        </listitem>
        <listitem>
            <para>operators.</para>
        </listitem>
    </itemizedlist>
    
    <para>Ceylon expressions are validated for typesafety at compile time. To 
    determine whether an expression is assignable to a program element such as 
    a value or parameter, Ceylon considers the <emphasis>type</emphasis> of the 
    expression (the type of the objects that are produced when the expression 
    is evaluated). An expression is assignable to a program element if the type 
    of the expression is assignable to the declared type of the program 
    element.</para>
    
    <para>Within a <literal>dynamic</literal> block, an expression may have no 
    type, in the sense that its type can not be determined using static analysis
    of the code.</para>
    
    <section id="literalvalues">
        <title>Literal values</title>
    
        <para>Ceylon supports literal values of the following types:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>Integer</literal> and <literal>Float</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>Character</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>String</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>The types <literal>Integer</literal>, <literal>Float</literal>, 
        <literal>Character</literal>, and <literal>String</literal> are defined in the 
        module <literal>ceylon.language</literal>.</para>
        
        <comment><para>Note: Ceylon does not need a special syntax for <literal>Boolean</literal> 
        literal values, since <literal>Boolean</literal> is just a class with the cases 
        <literal>true</literal> and <literal>false</literal>. Likewise, <literal>null</literal> 
        is just the singleton value of an anonymous class.</para></comment>
        
        <synopsis>Literal: IntegerLiteral | FloatLiteral | CharacterLiteral | StringLiteral | VerbatimStringLiteral</synopsis>
        
        <para>All literal values are instances of immutable types. The value of a literal 
        expression is an instance of the type. How this instance is produced is not specified 
        here.</para>
    
    <!--section id="datetime">
        <title><literal>Date</literal> and <literal>Time</literal> literals</title>
        
        <para>A <literal>Date</literal> literal has the form:</para>
        
        <programlisting>DateLiteral: 
"'" 
Digit{1,2} "/" Digit{1,2} "/" Digit{4} 
"'"</programlisting>
        
        <para>A <literal>Time</literal> literal has the form:</para>
        
        <programlisting>TimeLiteral: 
"'" 
Digit{1,2} ":" Digit{2} ( ":" Digit{2} ( ":" Digit{3} )? )? 
(" " "AM"|"PM")? 
(" " Character{3,4})? 
"'"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Date date = '25/03/2005';</programlisting>
        <programlisting>Time time = '12:00 AM PST';</programlisting>
        
        <para>A <literal>Datetime</literal> may be composed from a <literal>Date</literal> and 
        a <literal>Time</literal> using the <literal>@</literal> operator.</para>
        
        <programlisting>Datetime datetime = '25/03/2005' @ '12:00 AM PST';</programlisting>
        
        <comment><para>TODO: alternatively, we could follow RFC3339-style datetimes, for example:
        <literal>1996-12-19T16:39:57-08:00</literal>.</para></comment>
        
        <comment><para>TODO: should we allow wildcards and ranges, to get cron-style expressions 
        like <literal>'1/*/*' @ '00:00 GMT'</literal>?</para></comment>
        
        <para>The <literal>..</literal> operator lets us construct intervals:</para>
        
        <programlisting>Interval&lt;Date&gt; timeRange = '0:0:00' .. '12:59:59 PM';</programlisting>
        <programlisting>Interval&lt;Date&gt; dateRange = '1/1/2008' .. '31/12/2007';</programlisting>
        <programlisting>Interval&lt;Datetime&gt; datetimeRange = '1/1/2008' @ '0:0:00' .. '31/12/2007' @ '12:59:59 PM';</programlisting>
        
    </section-->
    
        <!--
        
        <para>The attributes <literal>hours</literal>, <literal>minutes</literal>, <literal>seconds</literal>,
        <literal>years</literal>, <literal>months</literal>, <literal>days</literal>, <literal>weeks</literal>
        of the <literal>Integer</literal> class let us construct durations.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 12.hours + 34.minutes;</programlisting>
        <programlisting>Duration&lt;Date&gt; duration = 1.year + 2.months + 3.days;</programlisting>
        
        <para>Durations may be composed using the arithmetic operators <literal>+</literal>, 
        <literal>-</literal>, <literal>*</literal> and <literal>/</literal>.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 1.seconds / 10 - 1.seconds / 1000;</programlisting> 
        
        <para>The methods <literal>before()</literal> and <literal>after()</literal> let us add and
        subtract durations to and from datetimes.</para>
        
        <programlisting>Time time = 10.seconds.before('12:00 AM');</programlisting>
        <programlisting>Date date = 1.week.after('2/9/1974');</programlisting>
        
        -->
        
        <section id="naturalnumber">
            <title>Integer number literals</title>
            
            <para>An integer literal, as defined in 
            <xref linkend="numericliterals"/>, is an expression of type 
            <literal>Integer</literal>, representing a numeric integer.</para>
            
            <programlisting>Integer five = 5;</programlisting>
            <programlisting>Integer mask = $1111_0000;</programlisting>
            <programlisting>Integer white = #FFFF;</programlisting>
            
        </section>
        
        <section id="floatnumber">
            <title>Floating point number literals</title>
            
            <para>A floating point literal, as defined in 
            <xref linkend="numericliterals"/>, is an expression of type 
            <literal>Float</literal>, a floating-point representation of 
            a numeric value.</para>
            
            <programlisting>shared Float pi = 3.14159;</programlisting>
            
        </section>
        
        <section id="character">
            <title>Character literals</title>
            
            <para>A single character literal, as defined in 
            <xref linkend="characterliterals"/>, is an expression of type 
            <literal>Character</literal>, representing a single 32-bit
            Unicode character.</para>
            
            <programlisting>if (exists ch=string[i], ch &equals; '+') { ... }</programlisting>
            
        </section>
        
        <section id="string">
            <title>Character string literals</title>
            
            <para>A character string literal or verbatim string, as defined 
            in <xref linkend="stringliterals"/>, is an expression of type
            <literal>String</literal>, representing a sequence of Unicode
            characters.</para>
            
            <programlisting>person.name = "Gavin King";</programlisting>
            
            <programlisting>print("Melbourne\tVic\tAustralia\nAtlanta\tGA\tUSA\nGuanajuato\tGto\tMexico\n");</programlisting>
            
            <programlisting>String verbatim = """A verbatim string can have \ or a " in it."""";</programlisting>
            
        </section>
    
    </section>
    
    <section id="stringtemplates">
        <title>String templates</title>
        
        <para>A character <emphasis>string template</emphasis> contains interpolated 
        expressions, surrounded by character string fragments.</para>
        
        <synopsis>StringTemplate: StringStart (ValueExpression StringMid)* ValueExpression StringEnd</synopsis>
        
        <para>Each interpolated expression contained in the string template must have 
        a type assignable to <literal>Object</literal> defined in 
        <literal>ceylon.language</literal>.</para>
        
        <programlisting>print("Hello, ``person.firstName`` ``person.lastName``, the time is ``Time()``.");</programlisting>
        
        <programlisting>print("1 + 1 = ``1 + 1``");</programlisting>
        
        <para>A string template is an expression of type <literal>String</literal>.</para>
        
    </section>
    
    <section id="selfreferences">
        <title>Self references and the current package reference</title>
        
        <para>The type of the following expressions depends upon the context in which 
        they appear.</para>
        
        <synopsis>SelfReference: "this" | "super" | "outer" | "package"</synopsis>
        
        <para>A self reference expression may not occur outside of a class or 
        interface body.</para>
        
        <para>The <emphasis>immediately containing class or interface</emphasis> for
        a program element is the class or interface in which the program element 
        occurs, and which contains no other class or interface in which the program 
        element occurs. If there is no such class or interface, the program element
        has no immediately containing class or interface.</para>
        
        <para>A <literal>this</literal>, <literal>outer</literal>, or 
        <literal>super</literal> self reference must have an immediately containing 
        class or interface. An <literal>outer</literal> self reference must have
        an immediately containing class or interface for its immediately containing 
        class or interface.</para>
        
        <section id="this">
            <title><literal>this</literal></title>
            
            <para>The keyword <literal>this</literal> refers to the current instance,
            as defined in <xref linkend="currentinstanceofaclassorinterface"/>, of the 
            immediately containing class or interface (the class or interface in which 
            the expression appears). Its type is the type of the immediately containing 
            class or interface.</para>
            
        </section>
       
        <section id="outer">
            <title><literal>outer</literal></title>
            
            <para>The keyword <literal>outer</literal> refers to the current instance,
            as defined in <xref linkend="currentinstanceofaclassorinterface"/>, of the 
            class or interface which immediately contains the immediately containing 
            class or interface. Its type is assignable to the type of this class or 
            interface.</para>
            
        </section>
                    
        <section id="super">
            <title><literal>super</literal></title>
            
            <para>The keyword <literal>super</literal> refers to the current instance 
            of the immediately containing class or interface. Its type is the 
            intersection of the immediate superclass and all immediate superinterfaces 
            of the class. A member reference such as <literal>super.x</literal> may not 
            resolve to a <literal>formal</literal> declaration, nor to any member 
            inherited from more than one supertype of the intersection type.</para>
            
            <para>The keyword <literal>super</literal> may occur as the first operand
            of an <literal>of</literal> operator, in which case the second operand is
            any supertype of the class. The expression <literal>(super of Type)</literal>
            has type <literal>Type</literal>. A member reference such as 
            <literal>(super of Type).x</literal> may not resolve to a <literal>formal</literal> 
            member, nor to any member inherited from more than one supertype of 
            <literal>Type</literal>, nor to any member that is refined by the class or 
            any intermediate supertype of the class.</para> 
            
        </section>
        
        <section id="thispackage">
            <title><literal>package</literal></title>
            
            <para>The keyword <literal>package</literal> is not an expression, and
            does not have a well-defined type. However, it may be used to qualify 
            and disambiguate a value reference or callable reference. A value
            reference or callable reference qualified by the keyword 
            <literal>package</literal> always refers to a toplevel member of the
            containing package, never to an imported declaration or nested 
            declaration.</para>
            
        </section>
    
    </section>
    
        <section id="anonymousfunctions">
            <title>Anonymous functions</title>
            
            <para>An anonymous function is a function, as specified in 
            <xref linkend="functions"/>, with no name, defined within an expression. 
            It comprises one or more parameter lists, followed by an expression.</para>
            
            <synopsis>FunctionExpression: ("function" | "void")? Parameters+ (LazySpecifier | Block)</synopsis>
            
            <para>The parameters are the parameters of the function. The lazy 
            specifier or block of code is the implementation of the function. If 
            the <literal>void</literal> keyword is specified, the function is a 
            <literal>void</literal> function. Otherwise, it is a 
            non-<literal>void</literal> function, and its return type is 
            inferred.</para>
            
            <para>The type of an anonymous function expression is the callable 
            type of the function, as specified in 
            <xref linkend="callabletypeoffunction"/>.</para>
            
            <programlisting>(Value x, Value y) => x&lt;=&gt;y</programlisting>
            
            <programlisting>void (String name) => print(name)</programlisting>
            
            <programlisting>(String string) {
    value mid = string.size % 2;
    return [string[0..mid],string[mid+1...]];
}</programlisting>
            
            <para>An anonymous function occurring in an <literal>extends</literal>
            clause may not contain a reference to a variable value.</para>
            
            <comment><para>Note: evaluation of an anonymous function expression,
            as defined in <xref linkend="anonymousfunctionevaluation"/> results
            in instantiation of an object of type <literal>Callable</literal>.
            However, the members of this object are never in scope, do not hide
            other declarations, and are not referenceable from within the 
            anonymous function.</para></comment>
            
            <comment><para>Note: there is almost no semantic difference between the
            following function declarations:</para>
            <programlisting>Float f(Float x)(Float y) => x*y;</programlisting>
            <programlisting>Float(Float) f(Float x) => (Float y) => x*y;</programlisting>
            <para>The first form is strongly preferred.</para></comment>
            
        </section>
        
    <section id="compoundexpressions">
        <title>Compound expressions</title>
        
        <para>An <emphasis>atom</emphasis> is a literal or self reference, a
        string template, an iterable or tuple enumeration, or a parenthesized 
        expression.</para>
        
        <synopsis>Atom: Literal | StringTemplate | SelfReference | GroupedExpression | Iterable | Tuple | DynamicValue</synopsis>
        
        <para>A <emphasis>primary</emphasis> is formed by recursively forming 
        member expressions and invocation expressions from an atom, base 
        expression, or static expression.</para>
        
        <synopsis>Primary: Atom | BaseExpression | MemberExpression | StaticExpression | Invocation | Meta | Dec</synopsis>
        
        <para>More complex expressions are formed by combining expressions using 
        operators, including assignment operators, and anonymous functions.</para>    
        
        <synopsis>ValueExpression: Primary | OperatorExpression</synopsis>
        
        <synopsis>Expression: ValueExpression | FunctionExpression | OperatorInvocation | OperatorMemberExpression</synopsis>
        
        <para>Parentheses are used for grouping:</para>
        
        <synopsis>GroupedExpression: "(" Expression ")"</synopsis>
        
        <para>A compound expression occurring in a <literal>dynamic</literal> 
        block, and involving a qualified or unqualified reference with no type,
        or a reference to a declaration with no type, may also have no type.</para>
        
        <para>In particular, if an operand expression has no type, and the type 
        of the operator expression depends upon the type of the operand, and the 
        operator expression occurs within a <literal>dynamic</literal> block, 
        then the whole operator expression has no type.</para>
        
        <section id="baseexpressions">
            <title>Base expressions</title>
            
            <para>A <emphasis>base expression</emphasis> is an unqualified 
            identifier, with an optional list of type arguments:</para>
            
            <synopsis>BaseExpression: (MemberName | TypeName) TypeArguments?</synopsis>
            
            <para>A base expression is either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>a reference to a toplevel function, toplevel value, or 
                    toplevel class,</para>
                </listitem>
                <listitem>
                    <para>a reference within the lexical scope of the referenced 
                    function, value, or class, or</para>
                </listitem>
                <listitem>
                    <para>a reference within the body of the referenced function,
                    value, or class.</para>
                </listitem>
            </itemizedlist>
            
            <para>The referenced declaration is determined by resolving the unqualified 
            reference as defined by <xref linkend="unqualifiedreferenceresolution"/>.
            The unqualified realization for the unqualified reference is determined
            according to <xref linkend="realizations"/>.</para>
            
            <para>The type argument list, if any, must conform, as defined by
            <xref linkend="typeargumentsandconstraints"/>, to the type parameter list
            of the unqualified realization.</para>
            
            <para>If a base expression is a reference to an attribute, method, or 
            member class of a class, the receiving instance is the current instance of 
            that class, as defined by <xref linkend="currentinstanceofaclassorinterface"/>.
            Otherwise, there is no receiving instance.</para>
        
        </section>
        
        <section id="memberexpressions">
            <title>Member expressions</title>
            
            <para>A <emphasis>member expression</emphasis> is a <emphasis>receiver
            expression</emphasis>, followed by an identifier, with an optional list 
            of type arguments.</para>
            
            <synopsis>MemberExpression: (Primary ".") (MemberName | TypeName) TypeArguments?</synopsis>
            
            <para>A member expression is a reference to a member of a type: an
            attribute, method, or member class.</para>
            
            <para>The referenced member is determined by resolving the qualified 
            reference as defined by <xref linkend="qualifiedreferenceresolution"/>.
            The qualified realization for the qualified reference is determined
            according to <xref linkend="realizations"/>.</para>
            
            <para>The type argument list, if any, must conform, as defined by
            <xref linkend="typeargumentsandconstraints"/>, to the type parameter list
            of the qualified realization.</para>
            
            <para>The receiver expression produces the instance upon which the member 
            is invoked or evaluated. When a member expression is executed, the receiver 
            expresson is evaluated to produce the receiving instance which is held 
            until the member is invoked or evaluated, as defined in 
            <xref linkend="evaluationinvocationandassignment"/>.</para>
            
        </section>
                    
        <section id="valuereferences">
            <title>Value references</title>
            
            <para>A <emphasis>value reference</emphasis> is a base expression or 
            member expression that references a value declaration.</para>
            
            <para>The type of a value reference expression is the type of the 
            realization of the referenced value.</para>
            
            <para>A value declaration is never generic, so a value reference never
            has a type argument list.</para>
            
            <para>A value reference that does not occur within any <literal>dynamic</literal>
            block may not refer to a value declaration or value parameter with no type.</para>
            
            <para>A value reference which occurs within a <literal>dynamic</literal> 
            block and which does not reference any statically typed declaration, or
            which references a value declaration or value parameter with no type, 
            has no type.</para>
            
            <para>If a base expression or member expression does not reference any 
            statically typed declaration, and occurs within a <literal>dynamic</literal> 
            block, then it is considered a value reference.</para>
            
        </section>
        
        <section id="callablereferences">
            <title>Callable references</title>
            
            <para>A <emphasis>callable reference</emphasis> is a base expression or
            member expression that references something&mdash;a function or 
            class&mdash;that can be <emphasis>invoked</emphasis> or 
            <emphasis>instantiated</emphasis> by specifying a list of arguments.</para>
            
            <para>A callable reference may be invoked immediately, or it may be passed 
            to other code which may invoke the reference. A callable reference captures 
            the return type and parameter list types of the function or class it refers 
            to, allowing compile-time validation of argument types when the callable 
            reference is invoked.</para>
            
            <para>The type of a callable reference expression is the callable type of
            the realization of the referenced function or class.</para>
            
            <para>If a callable reference expression refers to a generic declaration, 
            either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>it must be immediately followed by an argument list, 
                    allowing the compiler to infer the type arguments, or</para>
                </listitem>
                <listitem>
                    <para>it must have an explicit type argument list.</para>
                </listitem>
            </itemizedlist>
            
            <para>A callable reference may not appear as the receiver expression of
            a member expression.</para>
            
            <comment><para>Note: this restriction exists to eliminate an ambiguity in
            the interpretation of static expressions such as <literal>Person.string</literal>
            and <literal>Person.equals</literal>.</para></comment>
                    
            <para>A callable reference that does not occur within any <literal>dynamic</literal>
            block may not refer to a function declaration with no return type.</para>
            
            <para>A callable reference which occurs within a <literal>dynamic</literal> 
            block and which references a function declaration with no return type, has 
            no type.</para>
            
            <comment><para>Note: in a future release of the language, we would like to 
            add a syntax for obtaining a callable reference to an attribute, something
            like <literal>person.@name</literal>, to allow attributes to be passed by 
            reference. This would also allow static references like
            <literal>Person.@name</literal>.</para></comment>
            
        </section>
        
        <section id="staticexpressions">
            <title>Static expressions</title>
            
            <para>A <emphasis>static expression</emphasis> is a type, followed by an identifier, 
            with an optional list of type arguments.</para>
            
            <synopsis>StaticExpression: (TypeName TypeArguments? ".")+ (MemberName | TypeName) TypeArguments?</synopsis>
            
            <para>A static expression is a reference to a member of a type: an attribute, method, 
            or member class.</para>
            
            <para>The referenced member is determined by resolving the qualified reference as defined 
            by <xref linkend="qualifiedreferenceresolution"/>. The qualified realization for the 
            qualified reference is determined according to <xref linkend="realizations"/>.</para>
            
            <para>The type argument list, if any, must conform, as defined by
            <xref linkend="typeargumentsandconstraints"/>, to the type parameter list of the 
            qualified realization.</para>
            
            <para>Unlike member expressions, a static expression does not have a receiver expression. 
            All static expressions are callable expressions which accept an argument of the specified 
            type.</para>
            
            <!--comment><para>TODO: should we support static expressions involving union/intersection types 
            and abbreviations, for example <literal>&lt;String[]|Set&lt;Character&gt;&gt;.iterator</literal>?</para></comment-->
            
            <para>A static expression must reference a statically typed declaration with no missing 
            types, even within a <literal>dynamic</literal> block.</para>
            
        </section>
        
        <section id="staticvaluereferences">
            <title>Static value references</title>
            
            <para>A <emphasis>static value reference</emphasis> is a static 
            expression that references an attribute declaration.</para>
            
            <programlisting>List&lt;Anything&gt;.size</programlisting>
            
            <para>The type of a static value reference expression for an attribute 
            whose realization is of type <literal>X</literal>, and with qualifying 
            type <literal>T</literal>, is <literal>X(T)</literal>.</para>
            
            <para>A value declaration is never generic, so a static value reference 
            never ends in a type argument list.</para>
            
        </section>
        
        <section id="staticcallablereferences">
            <title>Static callable references</title>
            
            <para>A <emphasis>static callable reference</emphasis> is a static 
            expression that references something&mdash;a method or member 
            class&mdash;that can be <emphasis>invoked</emphasis> or 
            <emphasis>instantiated</emphasis>.</para>
            
            <programlisting>List&lt;String&gt;.filter</programlisting>
            <programlisting>Iterable&lt;Integer&gt;.map&lt;String&gt;</programlisting>
            
            <para>The type of a static callable reference expression for a method
            or member class whose realization has callable type <literal>C</literal>, 
            and with qualifying type <literal>T</literal>, is <literal>C(T)</literal>.</para>
            
            <para>If a callable reference expression refers to a generic declaration, 
            it must end in an explicit type argument list.</para>
            
        </section>
    
    </section>
    
    <section id="invocationexpressions">
        <title>Invocation expressions</title>
        
        <para>A callable expression&mdash;any expression of type 
        <literal>Callable</literal>&mdash;is <emphasis>invokable</emphasis>. An 
        <emphasis>invocation</emphasis> consists of an <emphasis>invoked expression</emphasis>, 
        together with an argument list and, optionally, an explicit type argument list.</para>
        
        <synopsis>Invocation: Primary Arguments</synopsis>
        
        <para>The invoked expression must be of type <literal>Callable&lt;R,P&gt;</literal>
        for some types <literal>R</literal> and <literal>P</literal>. Then the type of the 
        invocation expression is simply <literal>R</literal>.</para>
        
        <para>If the invoked expression has no type, and occurs within a <literal>dynamic</literal> 
        block, then the whole invocation expression has no type, and the argument list is 
        not type-checked at compile time, unless it is a direct invocation expression.</para>
        
        <para>An invocation expression must specify arguments for parameters of the callable 
        object, either as a positional argument list, or as a named argument list.</para>
        
        <synopsis>Arguments: PositionalArguments | NamedArguments</synopsis>
        
        <para>Every argument list has a type, as specified below in 
        <xref linkend="positionalarguments"/> and <xref linkend="namedarguments"/>. If an 
        invocation is formed from a callable expression of type exactly 
        <literal>Callable&lt;R,P&gt;</literal> and an argument list of type 
        <literal>A</literal>, then <literal>A</literal> must be a subtype of 
        <literal>P</literal>.</para>
            
        <comment><para>TODO: should we support an infix-operator-style syntax for method 
        invocation like <literal>string split ",;".contains</literal>? This is especially 
        nice for conceptually symmetric operations like <literal>a xor b</literal>, or when 
        the argument is an anonymous function like 
        <literal>people map (Person p)=>p.firstName+p.lastName</literal>.</para></comment>
            
        <section id="directinvocations">
            <title>Direct invocations</title>
            
            <para>Any invocation expression where the invoked expression is a callable 
            reference expression is called a <emphasis>direct invocation expression</emphasis> 
            of the function or class to which the callable reference refers.</para> 
            
            <comment><para>TODO: Should we consider <literal>x{y=1;}{z=2;}</literal> a legal
            direct invocation if <literal>x</literal> has multiple parameter lists?</para></comment>
            
            <para>In a direct invocation expression:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the compiler has one item of additional information about the schema 
                    of the method or class that is not reified by the <literal>Callable</literal> 
                    interface: the names of the parameters of the function or class, and
                    therefore named arguments may be used, and</para>
                </listitem>
                <listitem>
                    <para>type argument inference is possible, as defined in 
                    <xref linkend="typeargumentinference"/>, since the compiler has access to 
                    the type parameters and constraints of the function or class.</para>
                </listitem>
            </itemizedlist>
            
            <para>If an invocation expression has a named argument list, it must be a direct
            invocation.</para>
            
            <para>The type of a direct invocation expression is the return type of the 
            realization of the function, or the type of the realization of the class, as 
            defined in <xref linkend="realizations"/>.</para>
            
            <para>If the function has no return type, and occurs within a <literal>dynamic</literal> 
            block, then the whole direct invocation expression has no type.</para>
            
            <para>In a direct invocation expression of a function or class, the restriction
            above on the argument list type is equivalent to the following requirements. Given
            the parameter list of the realization of the function or class, and the arguments 
            of the direct invocation:</para>
            
            <itemizedlist>
                <listitem>
                    <para>for each required parameter, an argument must be given,</para>
                </listitem>
                <listitem>
                    <para>for each defaulted parameter, an argument may optionally be 
                    given,</para>
                </listitem>
                <listitem>
                    <para>if the parameter list has a variadic parameter of type 
                    <literal>T+</literal>, one or more arguments must be given,</para>
                </listitem>
                <listitem>
                    <para>if the parameter list has a variadic parameter of type 
                    <literal>T*</literal>, one or more arguments may optionally be 
                    given,</para>
                </listitem>
                <listitem>
                    <para>no additional arguments may be given,</para>
                </listitem>
                <listitem>
                    <para>for a required or defaulted parameter of type <literal>T</literal>, 
                    the type of the corresponding argument expression must be assignable to 
                    <literal>T</literal>, and</para>
                </listitem>
                <listitem>
                    <para>for a variadic parameter of type <literal>T*</literal> or 
                    <literal>T+</literal>, the type of every corresponding argument 
                    expression must be assignable to <literal>T</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Furthermore, if type argument are inferred, then the inferred type 
            arguments must conform, as defined by <xref linkend="typeargumentsandconstraints"/>, 
            to the type parameter list of the realization of the function or class.</para>
            
            <para>If an argument expression has no type, or if its parameter has no type, 
            and the invocation occurs within a <literal>dynamic</literal> block, then the 
            argument is not type-checked at compile time.</para>
            
            <para>An invocation expression that does not occur within any <literal>dynamic</literal>
            block may not assign an argument to a value parameter with no type.</para>
            
        </section>
        
        <section id="defaultarguments">
            <title>Default arguments</title>
        
            <para>When no argument is assigned to a defaulted parameter by the caller, 
            the default argument defined by the parameter declaration of the realization,
            as defined by <xref linkend="typeargumentsandconstraints"/>, of the function 
            or class is used. The default argument expression is evaluated every time the 
            method is invoked with no argument specified for the defaulted parameter.</para>
            
            <para>This class:</para>
            
            <programlisting>shared class Counter(Integer initialCount=0) { ... }</programlisting>
            
            <para>May be instantiated using any of the following invocations:</para>
            
            <programlisting>Counter()</programlisting>
            <programlisting>Counter(1)</programlisting>
            <programlisting>Counter {}</programlisting>
            <programlisting>Counter { initialCount=10; }</programlisting>
        
        </section>
        
        <section id="tupletypeofarglist">
            <title>The type of a list of arguments</title>
            
            <para>A list of arguments may be formed from:</para>
            
            <itemizedlist>
                <listitem>
                    <para>any number of <emphasis>listed arguments</emphasis>,
                    optionally followed by either</para>
                </listitem>
                <listitem>
                    <para>a <emphasis>spread argument</emphasis>, or</para>
                </listitem>
                <listitem>
                    <para>a <emphasis>comprehension</emphasis>.</para>
                </listitem>
            </itemizedlist>
            
            <synopsis>ArgumentList: ((ListedArgument ",")* (ListedArgument | SpreadArgument | Comprehension))?</synopsis>
            
            <para>Every such list of arguments has a type, which captures the types of 
            the individual arguments in the list. This type is always a subtype of 
            <literal>Anything[]</literal>. The type of an empty list of arguments is 
            <literal>[]</literal>.</para>
            
        </section>
        
        <section id="listedarguments">
            <title>Listed arguments</title>
            
            <para>A listed argument is an expression.</para>
            
            <synopsis>ListedArgument: Expression</synopsis>
            
            <para>If a listed argument is an expression of type <literal>T</literal>, and 
            a list of arguments has type <literal>P</literal> with principal instantiation 
            <literal>Sequential&lt;Y&gt;</literal>, then the type of a new argument list 
            formed by prepending the expression to the first parameter list is 
            <literal>Tuple&lt;T|Y,T,P&gt;</literal>.</para>
            
        </section>
        
        <section id="spreadarguments">
            <title>Spread arguments</title>
            
            <para>A spread argument is an expression prefixed by the 
            <emphasis>spread operator</emphasis> <literal>*</literal>.</para>
            
            <synopsis>SpreadArgument: "* "Expression</synopsis>
            
            <para>The expression type <literal>T</literal> must have the principal 
            instantiation <literal>{X*}</literal> for some type <literal>X</literal>. We 
            form the <emphasis>sequential type of a spread argument</emphasis> as 
            follows:</para>
            
            <itemizedlist>
                <listitem>
                    <para>if the expression type <literal>T</literal> is an invariant 
                    subtype of <literal>X[]</literal>, for some type <literal>X</literal> 
                    then the sequential type of the spread argument is 
                    <literal>T</literal>, or, if not,</para>
                </listitem>
                <listitem>
                    <para>if the expression type <literal>T</literal> is an invariant 
                    subtype of <literal>{X+}</literal>, for some type <literal>X</literal> 
                    then the sequential type of the spread argument is 
                    <literal>[X+]</literal>, or, otherwise,</para>
                </listitem>
                <listitem>
                    <para>the expression type <literal>T</literal> is an invariant 
                    subtype of <literal>{X*}</literal>, for some type <literal>X</literal>
                    and the sequential type of the spread argument is 
                    <literal>X[]</literal>,</para>
                </listitem>
            </itemizedlist>
            
            <para>When a spread argument with an expression type not assignable to 
            <literal>Anything[]</literal> is evaluated, the elements of the iterable
            automatically are packaged into a sequence.</para>
            
            <comment><para>Note: the spread "operator" is not truly an operator in the
            sense of <xref linkend="operators"/>, and so a spread argument is not an 
            expresson. An expression, when evaluated, produces a single value. The
            spread operator produces multiple values. It is therefore more correct to 
            view the spread operator as simply part of the syntax of an argument list.
            </para></comment>
            
            <para>The type of a list of arguments containing only a spread argument of 
            sequential type <literal>S</literal> is simply <literal>S</literal>.</para>
            
        </section>
        
        <section id="comprehensions">
            <title>Comprehensions</title>
            
            <para>A <emphasis>comprehension</emphasis> accepts one or more streams of values 
            and produces a new stream of values. Any instance of <literal>Iterable</literal>
            is considered a stream of values. The comprehension has two or more
            <emphasis>clauses</emphasis>:</para>
            
            <itemizedlist>
                <listitem>
                    <para>A <literal>for</literal> clause specifies a source stream and an 
                    iteration variable, as defined in <xref linkend="iterationvariables"/>, 
                    representing the values produced by the stream.</para>
                </listitem>
                <listitem>
                    <para>An <literal>if</literal> clause specifies a condition list, as
                    defined in <xref linkend="controlstructureconditions"/>, used to filter
                    the values produced by the source stream or streams.</para>
                </listitem>
                <listitem>
                    <para>An expression clause produces the values of the resulting stream.</para>
                </listitem>
            </itemizedlist>
            
            <para>Every comprehension begins with a <literal>for</literal> or <literal>if</literal>
            clause, and ends with an expression clause. There may be any number of intervening 
            <literal>for</literal> or <literal>if</literal> clauses. Each clause in the
            comprehension is considered a child of the clause that immediately precedes 
            it.</para>
            
            <synopsis>Comprehension: InitialComprehensionClause</synopsis>
            <synopsis>InitialComprehensionClause: ForComprehensionClause | IfComprehensionClause</synopsis>
            <synopsis>ForComprehensionClause: "for" ForIterator ComprehensionClause</synopsis>
            <synopsis>IfComprehensionClause: "if" ConditionList ComprehensionClause</synopsis>
            <synopsis>ComprehensionClause: ForComprehensionClause | IfComprehensionClause | Expression</synopsis>
            
            <para>An expression that occurs in a child clause may refer to iteration 
            variables and condition variables declared by parent clauses. The types
            of such variables are specified in <xref linkend="controlstructures"/>.</para>
            
            <comment><para>Note: each child clause can be viewed as a body nested inside 
            the parent clause. The scoping rules for variables declared by comprehension
            clauses reflects this model.</para></comment>
            
            <para>The type of a list of arguments containing only a comprehension is 
            <literal>[T*]</literal> where <literal>T</literal> is the type of the
            expression which terminates the comprehension, or <literal>[T+]</literal>
            if there are no <literal>if</literal> clauses, and if every 
            <literal>for</literal> clause has an iterated expression of nonempty
            type.</para>
            
            <para>An comprehension occurring in an <literal>extends</literal> clause may 
            not contain a reference to a variable value.</para>
            
            <comment><para>Note: a comprehension, like a spread argument, is not considered an 
            expression. An expression, when evaluated, produces a single value. A comprehension,
            produces multiple values, like a spread argument, or like a series of listed 
            arguments. Therefore, a comprehension may only appear in an argument list or an 
            enumeration expression. This is however, no limitation; we can simply wrap the
            comprehension in braces in order to get an expression of type <literal>{T*}</literal>,
            or in brackets to get an expression of type <literal>[T*]</literal>.</para></comment>
            
            <comment><para>TODO: properly define how expressions with no type occurring in a
            <literal>dynamic</literal> block affect comprehensions.</para></comment>
            
        </section>
        
       <section id="positionalarguments">
            <title>Positional argument lists</title>
            
            <para>When invocation arguments are listed positionally, the argument list is 
            enclosed in parentheses.</para>
            
            <synopsis>PositionalArguments: "(" ArgumentList ")"</synopsis>
            
            <para>The type of the positional argument list is the type of the list of arguments 
            it contains.</para>
            
            <!--para>Positional arguments must be listed in the same order as the corresponding
            parameters.</para>
            
            <itemizedlist>
                <listitem>
                    <para>First, an argument of each required parameters must be specified, in the 
                    order in which the required parameters were declared. There must be at least as 
                    many arguments as required parameters.</para>
                </listitem>
                <listitem>
                    <para>Next, arguments of the first arbitrary number of defaulted parameters may 
                    be specified, in the order in which the defaulted parameters were declared. If 
                    there are fewer arguments than defaulted parameters, the remaining defaulted 
                    parameters are assigned their default values.</para>
                </listitem>
                <listitem>
                    <para>Finally, if arguments to all defaulted parameters have been specified,
                    and if the method declares a variadic parameter, an arbitrary number of arguments 
                    to the variadic parameter may be specified. 
                    </para>
                </listitem>
            </itemizedlist>
            
            <para>For example:</para>
            
            <programlisting>(getProduct(id), 1)</programlisting>
            <programlisting>((Float x, Float y) => x+y)</programlisting-->
        
        </section>
        
        <section id="namedarguments">
            <title>Named argument lists</title>
            
            <para>When invocation arguments are listed by name, the argument list is enclosed 
            in braces.</para>
            
            <synopsis>NamedArguments: "{" NamedArgument* ArgumentList "}"</synopsis>
            
            <para>Named arguments may be listed in a different order to the corresponding
            parameters.</para>
            
            <para>Each named argument in a named argument list is either:</para> 
            
            <itemizedlist>
                <listitem>
                    <para>an <emphasis>anonymous argument</emphasis>&mdash;an expression, with
                    no parameter name explicitly specified,</para>
                </listitem>
                <listitem>
                    <para>a <emphasis>specified argument</emphasis>&mdash;a specification 
                    statement where name of the value of function being specified is interpreted
                    as the name of a parameter, or</para>
                </listitem>
                <listitem>
                    <para>an inline getter, function, or anonymous class declaration, whose name 
                    is interpreted as the name of a parameter.</para>
                </listitem>
            </itemizedlist>
            
            <synopsis>NamedArgument: AnonymousArgument | SpecifiedArgument | InlineDeclarationArgument</synopsis>
            
            <para>Additionally, a named argument list has an ordinary list of arguments, which 
            may be empty. This argument list is interpreted as a single argument to a parameter 
            of type <literal>Iterable</literal>.</para>
            
            <programlisting>{ initialCapacity=2; "hello", "world" }</programlisting>
            <programlisting>{ initialCapacity=people.size; loadFactor=0.8; for (p in people) p.name->p }</programlisting>
            
            <comment><para>Note: in a future release of the language, we would like to be able 
            to assign a local name to an anonymous argument or listed argument, allowing it to 
            be referenced later in the argument list. We might consider this a kind of "let"
            expression, perhaps.</para></comment>
            
            <para>Given a parameter list, and a named argument list, we may attempt to construct 
            an <emphasis>equivalent positional argument list</emphasis> as follows:</para>
            
            <itemizedlist>
                <listitem>
                
                    <para>Taking each argument in the named argument list in turn, on the order 
                    they occur lexically:</para>
                    
                    <itemizedlist>
                        <listitem>
                            <para>if the argument is anonymous, assign it to the first unassigned
                            parameter of the parameter list, or</para>
                        </listitem>
                        <listitem>
                            <para>if the argument is named, assign it to the parameter with that
                            name in the parameter list.</para>
                        </listitem>
                    </itemizedlist>
                    
                    <para>If for any argument, there is no unassigned parameter, no parameter with
                    the given name, or the parameter with the given name has already been assigned
                    an argument, construction of the positional argument list fails, and the 
                    invocation is not well-typed.</para>
                
                </listitem>
                <listitem>
                
                    <para>Next, if the parameter list has an unassigned parameter of type exactly
                    <literal>Iterable&lt;T,N&gt;</literal> for some types <literal>T</literal> and
                    <literal>N</literal>, then an iterable enumeration expression, as defined in
                    <xref linkend="enumeration"/>, is formed from the ordinary list of arguments, 
                    and assigned to that parameter.</para>
                    
                    <para>If there is no such parameter, and the the ordinary list of arguments is
                    nonempty, then construction of the positional argument list fails, and the 
                    invocation is not well-typed.</para>
                    
                </listitem>
                <listitem>
                
                    <para>Finally, we assign each unassigned defaulted parameter its default 
                    argument.</para>
                
                </listitem>
            </itemizedlist>
            
            <para>The resulting equivalent positional argument list is formed by ordering
            the arguments according to the position of their corresponding parameters in
            the parameter list, and then replacing any inline value, function, or object
            declarations with a reference to the declaration.</para>
            
            <para>The type of a named argument list is the type of the equivalent positional 
            argument list.</para>
            
            <!--comment><para>TODO: Should the named argument list be allowed to contain arbitrary 
            statements? This is more regular, since you can do it in the body of a class, and 
            attribute/method refinement is the model that we are following here. And it could be 
            very useful when defining structured data.</para></comment-->
            
            <!--comment><para>TODO: Especially, should we support <literal>if/else</literal> and
            <literal>for</literal> in a named argument list. This might be super-useful for
            templating, for example:</para>
            <programlisting>ul { 
    if (error) { 
        color = red;
        li { "oops, something bad happened!" }
    } 
    else { 
        color = yellow;
        for (r in results) {
            li { r.successMessage }
        }
    } 
}</programlisting>
            <para>But the truth is that this would actually be a generally useful part of the 
            expression syntax.</para>
            </comment-->
            
        </section>
        
        <section id="anonymousarguments">
            <title>Anonymous arguments</title>
            
            <para>An anonymous argument is just an expression followed by a semicolon.</para>
            
            <synopsis>AnonymousArgument: Expression ";"</synopsis>
            
            <para>The type of the argument is the type of the expression.</para>
            
        <programlisting>{
    Head { title="Hello"; };
    Body {
        Div { "Hello " name "!" };
    };
}</programlisting>
            
        </section>
        
        <section id="specifiedarguments">
            <title>Specified arguments</title>
            
            <para>A specified argument is a value specification statement or lazy specification 
            statement, as defined in <xref linkend="specificationstatements"/>, where the value
            reference or callable reference is treated as the name of a parameter of the invoked 
            function or class instead of using the usual rules for resolving unqualified names.</para>
            
            <synopsis>SpecifiedArgument: Specification</synopsis>
            
            <itemizedlist>
                <listitem>
                    <para>If a specified argument is a value specification statement, its type 
                    is the type of the specified expression.</para>
                </listitem>
                <listitem>
                    <para>If a specified argument is a lazy specification statement with no 
                    parameter lists, its type is the type of the specified expression.</para>
                </listitem>
                <listitem>
                    <para>Otherwise, if it is a lazy specification statement with a parameter 
                    list, its type is the callable type formed from the type of the expression,
                    interpreted as a function return type, and the types of its parameter lists, 
                    according to <xref linkend="callabletypeoffunction"/>.</para>
                </listitem>
            </itemizedlist>
            
            <comment><para>Note: there is an ambiguity here between assignment expressions 
            and specified arguments. This ambiguity is resolved in favor of interpreting the
            argument as a specified argument. Therefore an anonymous argument in a named 
            argument list may not be an assignment expression.</para></comment>
            
            <programlisting>{ 
    product = getProduct(id); 
    quantity = 1; 
}</programlisting>
            
            <programlisting>{ 
    by(Value x, Value y) => x&lt;=&gt;y;
}</programlisting>
            
        </section>
        
        <section id="inlinedeclarationarguments">
            <title>Inline declaration arguments</title>
            
            <para>An <emphasis>inline declaration argument</emphasis> defines a getter,
            function, or anonymous class, and assigns it to a parameter.</para>
            
            <synopsis>ValueArgument | FunctionArgument | ObjectArgument</synopsis>
            
            <para>An inline getter argument is a streamlined getter declaration, as defined
            in <xref linkend="getters"/>. The type of the argument is the declared or inferred 
            type of the getter.</para>
            
            <synopsis>ValueArgument: ValueHeader (Block | (Specifier | LazySpecifier) ";")</synopsis>
            
            <para>An inline function argument is a streamlined function declaration, as
            defined in <xref linkend="functions"/>. The type of the argument is the callable 
            type of the function, as defined by <xref linkend="callabletypeoffunction"/>.</para>
            
            <synopsis>FunctionArgument: FunctionHeader (Block | LazySpecifier ";")</synopsis>
            
            <para>An inline anonymous class argument is a streamlined anonymous class 
            declaration, as defined in <xref linkend="anonymousclasses"/>. The type of the 
            argument is the anonymous class type.</para>
            
            <synopsis>ObjectArgument: ObjectHeader ClassBody</synopsis>
            
            <para>A named argument may not have type parameters or annotations.</para>
            
            <programlisting>{
    description = "Total";
    value amount { 
        variable Float total = 0.0;
        for (Item item in items) {
            sum += item.amount;
        }
        return total;
    }
}</programlisting>
            
            <programlisting>{ 
    label = "Say Hello"; 
    void onClick() { 
        say("Hello!"); 
    } 
}</programlisting>
            
            <programlisting>{ 
    function by(Value x, Value y) => x&lt;=&gt;y;
}</programlisting>
            
            <programlisting>{
    object iterator 
            satisfies Iterator&lt;Order&gt; {
        variable value done = false;
        shared actual Order|Finished next() {
            if (done) {
                return finished;
            }
            else {
                done=true;
                return order; 
            }
        }
    }   
}</programlisting>
            
        </section>
        
        <section id="enumeration">
            <title>Iterable and tuple enumeration</title>
            
            <para>An <emphasis>enumeration expression</emphasis> is an abbreviation for
            tuple and iterable object instantiation. Iterable enumerations are delimited
            using braces. Tuple enumerations are delimited by brackets.</para>
            
            <synopsis>Iterable: "{" ArgumentList "}"</synopsis>
            <synopsis>Tuple: "[" ArgumentList "]"</synopsis>
            
            <para>The type of an iterable enumeration expression is:</para>
            
            <itemizedlist>
                <listitem>
                    <literal>Empty</literal> if there are no argument expressions, or
                </listitem>
                <listitem>
                    <literal>Iterable&lt;U,Nothing&gt;</literal> where <literal>U</literal>,
                    the argument expression list is an invariant suptype of <literal>U[]</literal>.
                </listitem>
            </itemizedlist>
            
            <para>The type of a tuple enumeration expression is the type of the list of
            arguments it contains.</para>
            
            <programlisting>{String+} = { "hello", "world" };</programlisting>
            <programlisting>[] none = [];</programlisting>
            <programlisting>[Float,Float] xy = [x, y];</programlisting>
            <programlisting>[Float,Float, String*] xy = [x, y, *labels];</programlisting>
            
            <para>Every argument expression must have a type, even if the enumeration expression
            occurs in a <literal>dynamic</literal> block.</para>
            
        </section>
        
        <section id="dynamicenumerations">
            <title>Dynamic enumerations</title>
            
            <para>A <emphasis>dynamic enumeration expression</emphasis> creates a new 
            object with no class by enumerating its members, allowing interoperation 
            with dynamically typed native code.</para>
            
            <synopsis>DynamicValue: "value" NamedArguments</synopsis>
            
            <para>A dynamic enumeration expression has no type.</para>
            
            <para>Any argument names may be specified in the named argument list.</para>
            
            <para>A dynamic enumeration expression must occur inside a
            <literal>dynamic</literal> block.</para>
            
            <comment><para>The semantics of this construct are platform-dependent and
            beyond the scope of this specification.</para></comment>
            
        </section>
        
    </section>
    
    <section id="miscexpressions">
        <title>Conditional expressions and anonymous class expressions</title>
        
        <para>A <emphasis>conditional expression</emphasis> resembles a control 
        structure but is part of the expression syntax, and evaluates to a value.</para> 
        
        <para>An <emphasis>inline class</emphasis> is an anonymous class defined 
        within an expression.</para>
        
        <section id="inlineconditionalexpressions">
            <title>Inline conditional expressions</title>
         
            <comment>
            <para>We plan to support inline <literal>if/then/else</literal> conditional 
            expressions, for example:</para>
            <programlisting>Integer port = if (exists setting = process.propertyValue("port")) 
                        then parseInteger(setting) else 8080;</programlisting>
            <para>Note that this is more powerful than the <literal>then</literal> and
            <literal>else</literal> operators because it allows all kinds of conditions,
            not only boolean conditions.</para>
            <para>Should we also support:</para>
            <itemizedlist>
                <listitem>
                    <para>inline <literal>switch/case/else</literal> conditional 
                    expressions, or even</para>
                </listitem>
                <listitem>
                    <para>inline <literal>try/catch</literal> exceptional conditions?</para>
                </listitem>
            </itemizedlist>
            <para>For example:</para>
            <programlisting>Float evaluated => switch (expr)
        case (is Literal) expr.integer
        case (is Plus) expr.left.evaluated + expr.right.evaluated
        case (is Times) expr.left.evaluated * expr.right.evaluated;</programlisting>
            </comment>
            
        </section>
        
        <section id="letexpressions">
            <title>Let expressions</title>
            
            <comment>
            <para>Should we support let expressions, possibly reusing the keyword
            <literal>given</literal>?</para>
            <programlisting>given (dist = sqrt(x^2+y^2)) [x/dist,y/dist]</programlisting>
            </comment>
        
        </section>
        
        <section id="inlineanonymousclassexpressions">
            <title>Inline anonymous class expressions</title>
            
            <comment>
            <para>Should we support inline <literal>object</literal> declarations, for 
            example:</para>
            <programlisting>iterator => object satisfies Iterable&lt;Nothing&gt; { next() => finished; }</programlisting>
            <para>Or, alternatively, a kind of named argument ""instantiation" syntax for
            interfaces and abstract classes:</para>
            <programlisting>iterator => Iterable { next() => finished; }</programlisting>
            <para>The first option is more flexible, but also more verbose. The second is
            streamlined for the common case and might even be able to do type argument
            inference as shown here.</para> 
            
            <para>If we go with the first option, should we support inline <literal>class</literal> 
            declarations? This would be like an inline <literal>object</literal> and an 
            anonymous function rolled into one. We could even support <literal>class</literal>
            arguments in named argument lists.</para>
            </comment>
        
        </section>
        
    </section>

    <section id="operators">
    <title>Operators</title>
    
    <para>Operators are syntactic shorthand for more complex expressions involving 
    invocation, evaluation, or instantiation. There is no support for user-defined 
    <emphasis>operator overloading</emphasis>:</para> 
    
    <itemizedlist>
        <listitem>
            <para>new operator symbols may not be defined outside of the operators
            specified below, and</para>
        </listitem>
        <listitem>
            <para>the definition of the operators specified below may not be changed 
            or overloaded.</para>
        </listitem>
    </itemizedlist>
    
    <para>However, many of the operators below are defined in terms of 
    <literal>default</literal> or <literal>formal</literal> methods or attributes.
    So, within well-defined limits a concrete implementation may customize the  
    behavior of an operator. This approach is called 
    <emphasis>operator polymorphism</emphasis>.</para>
    
    <para>Some examples:</para>
    
    <programlisting>Float z = x * y + 1.0;</programlisting>
    
    <programlisting>even = n % 2 &equals; 0;</programlisting>
    
    <programlisting>++count;</programlisting>
    
    <programlisting>Integer j = i++;</programlisting>
    
    <programlisting>if ( x > 100 || x &lt; 0 ) { ... }</programlisting>
    
    <programlisting>User user = users[userId] else guest;</programlisting>
    
    <programlisting>List&lt;Item&gt; firstPage = results[0..20];</programlisting>
    
    <programlisting>for (n in 0:length) { ... }</programlisting>
    
    <programlisting>if (char in 'A'..'Z') { ... }</programlisting>
    
    <programlisting>String[] names = people*.name;</programlisting>
    
    <programlisting>this.total += item.price * item.quantity;</programlisting>
        
    <programlisting>Float vol = length^3;</programlisting>
    
    <programlisting>Vector scaled = scale ** vector;</programlisting>
    
    <programlisting>map.define(person.name->person);</programlisting>
    
    <programlisting>if (!document.internal || user is Employee) { ... }</programlisting>
    
    <section id="operatorprecedence">
        <title>Operator precedence</title>
        
        <para>There are 18 distinct operator precedence levels, but these levels
        are arranged into layers in order to make them easier to predict.</para>
        
        <itemizedlist>
            <listitem><para>Operators in layer 1 produce, transform, and combine
            values.</para></listitem>
            <listitem><para>Operators in layer 2 compare or predicate values, producing
            a <literal>Boolean</literal> result.</para></listitem>
            <listitem><para>Operators in layer 3 are logical operators that operate
            upon <literal>Boolean</literal> arguments to produce a <literal>Boolean</literal>
            value.</para></listitem>
            <listitem><para>Operators in layer 4 perform assignment and conditional
            evaluation.</para></listitem>
        </itemizedlist>
        
        <para>Within each layer, postfix operators have a higher precedence than 
        prefix operators, and prefix operators have a higher precedence than 
        binary operators.</para>
        
        <para>There is a single exception to this principal: the binary 
        exponentiation operator <literal>^</literal> has a higher precedence than 
        the prefix operators <literal>+</literal> and <literal>-</literal>. The 
        reason for this is that the following expressions should be equivalent:</para>
        
        <programlisting>-x^2       //means -(x^2)</programlisting>
        <programlisting>0 - x^2    //means 0 - (x^2)</programlisting>
        
        <para>This table defines the relative precedence of the various operators, 
        from highest to lowest, along with associativity rules:</para>
        
        <table>
        <tgroup cols="4">
            <colspec colnum="1" colwidth="2.5*" align="center" colname="first"/>
            <colspec colnum="2" colwidth="2.0*" align="center"/>
            <colspec colnum="3" colwidth="1.0*" align="center"/>
            <colspec colnum="4" colwidth="0.7*" align="center" colname="last"/>
        <thead>
            <row>
                <entry>Operations</entry>
                <entry>Operators</entry>
                <entry>Type</entry>
                <entry>Associativity</entry>
            </row>
        </thead>
        <tbody>
        
            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 1</emphasis></entry>
            </row>
    
            <row>
                <entry>Member invocation and selection, index, span,
                postfix increment, postfix decrement:</entry>
                <entry>
                <literal>.</literal>,
                <literal>*.</literal>, 
                <literal>?.</literal>, 
                <literal>()</literal>,
                <literal>{}</literal>,
                <literal>[]</literal>,
                <literal>[:]</literal>, 
                <literal>[..]</literal>, 
                <literal>[...]</literal>,
                <literal>++</literal>, 
                <literal>--</literal></entry>
                <entry>Binary / ternary / N-ary / unary postfix</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Prefix increment, prefix decrement:</entry>
                <entry>
                <literal>++</literal>, 
                <literal>--</literal>
                </entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Exponentiation:</entry>
                <entry>
                <literal>^</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>            
            <row>
                <entry>Negation:</entry>
                <entry>
                <literal>+</literal>,
                <literal>-</literal>
                </entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <!--row>
                <entry>Default:</entry> 
                <entry><literal>?</literal></entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row-->
            <row>
                <entry>Set intersection:</entry> 
                <entry>
                <literal>&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Set union and complement:</entry> 
                <entry>
                <literal>|</literal>,
                <literal>~</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Multiplication, division, remainder:</entry> 
                <entry>
                <literal>*</literal>, 
                <literal>/</literal>, 
                <literal>%</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Scale:</entry>
                <entry>
                <literal>**</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Addition, subtraction:</entry> 
                <entry>
                <literal>+</literal>, 
                <literal>-</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Range and entry construction:</entry> 
                <entry>
                <literal>..</literal>,
                <literal>:</literal>,  
                <literal>-></literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>

            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 2</emphasis></entry>
            </row>
    
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>exists</literal>, <literal>nonempty</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Comparison, containment,
                assignability, inheritance:</entry> 
                <entry>
                <literal>&lt;=&gt;</literal>,
                <literal>&lt;</literal>, 
                <literal>&gt;</literal>, 
                <literal>&lt;=</literal>, 
                <literal>&gt;=</literal>,
                <literal>in</literal>,
                <literal>is</literal>,
                <literal>of</literal>,
                <literal>satisfies</literal>
                </entry>
                <entry>Binary (and ternary)</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Equality, identity:</entry>
                <entry>
                <literal>&equals;</literal>, 
                <literal>!=</literal>, 
                <literal>&identical;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
        
            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 3</emphasis></entry>
            </row>
    
            <row>
                <entry>Logical not:</entry>
                <entry><literal>!</literal></entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Logical and:</entry> 
                <entry>
                <literal>&amp;&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Logical or:</entry>
                <entry>
                <literal>||</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            
            <row>
                <entry namest="first" nameend="last"><emphasis>Layer 4</emphasis></entry>
            </row>
            
            <row>
                <entry>Conditionals:</entry>
                <entry><literal>then</literal>, 
                <literal>else</literal></entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
    
            <row>
                <entry>Assignment:</entry> 
                <entry>
                <literal>=</literal>, 
                <literal>+=</literal>, 
                <literal>-=</literal>, 
                <literal>*=</literal>, 
                <literal>/=</literal>, 
                <literal>%=</literal>, 
                <literal>&amp;=</literal>, 
                <literal>|=</literal>, 
                <literal>^=</literal>, 
                <literal>~=</literal>, 
                <literal>&amp;&amp;=</literal>, 
                <literal>||=</literal>
                <!--literal>?=</literal-->
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            
        </tbody>
        </tgroup>
        </table>

        <para>It's important to be aware that in Ceylon, compared to other C-like 
        languages, the logical not operator <literal>!</literal> has a very low
        precedence. The following expressions are equivalent:</para>
        
        <programlisting>!x.y &equals; 0.0  //means !(x.y &equals; 0.0)</programlisting>
        <programlisting>x.y != 0.0</programlisting>
            
    </section>
    
    <section id="operatordefinition">
        <title>Operator definition</title>
        
        <para>The following tables define the semantics of the Ceylon operators. 
        There are six basic operators which do not have a definition in terms of 
        other operators or invocations:</para>
        
        <itemizedlist>
            <listitem>
                <para>the <emphasis>member selection</emphasis> operator
                <literal>.</literal> separates the receiver expression and member 
                name in a member expression, as defined above in
                <xref linkend="memberexpressions"/>,</para>
            </listitem>
            <listitem>
                <para>the <emphasis>argument specification</emphasis> operators
                <literal>()</literal> and <literal>{}</literal> specify the 
                argument list of an invocation, as defined in
                <xref linkend="invocationexpressions"/> and 
                <xref linkend="invocation"/>,</para>
            </listitem>
            <listitem>
                <para>the <emphasis>assignment</emphasis> operator
                <literal>=</literal> assigns a new value to a variable and 
                returns the new value after assignment, as defined in
                <xref linkend="assignment"/>,</para>
            </listitem>
            <listitem>
                <para>the <emphasis>identity</emphasis> operator
                <literal>&identical;</literal> evaluates to <literal>true</literal> 
                if its argument expressions evaluate to references to the same 
                object, as defined in <xref linkend="objectinstancesidentity"/>,
                or to <literal>false</literal> otherwise,</para>
            </listitem>
            <listitem>
                <para>the <emphasis>assignability</emphasis> operator
                <literal>is</literal> evaluates to <literal>true</literal> if 
                its argument expression evaluates to an instance of a class, as 
                defined in <xref linkend="objectinstancesidentity"/>, that is a 
                subtype of the specified type, or to <literal>false</literal> 
                otherwise, and</para>
            </listitem>
            <listitem>
                <para>the <emphasis>coverage</emphasis> operator
                <literal>of</literal> narrows or widens the type of an expression 
                to any specified type that covers the expression type, as defined
                by <xref linkend="coverage"/>, without affecting the value of the
                expression.</para>
            </listitem>
        </itemizedlist>
            
        <para>All other operators are defined below in terms of other operators 
        and/or invocations.</para>
        
        <para>In the tables, the following pseudo-code is used, which is not legal
        Ceylon syntax:</para>
        
        <para>First,</para>
        
        <programlisting>if (b) then x else y   //pseudocode</programlisting>
        
        <para>means the value of <literal>result</literal> after execution of the
        following:</para>
        
        <programlisting>X result; if (b) { result=x; } else { result=y; }</programlisting>
        
        <para>Second,</para>
        
        <programlisting>let t=x in y   //pseudocode</programlisting>
        
        <para>means the value of <literal>result</literal> after execution of the
        following:</para>
        
        <programlisting>X t = x; Y result=y;</programlisting>
    
    </section>
    
    <section id="basic">
    <title>Basic invocation and assignment operators</title>
    
        <para>These operators support method invocation and attribute evaluation and
        assignment.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs.member</literal></entry>
            <entry>member</entry>
            <entry></entry>
            <entry><literal>X</literal></entry>
            <entry>a member of <literal>X</literal>, of type
            <literal>T</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs{a=x;b=y;}</literal></entry>
            <entry>invoke</entry>
            <entry></entry>
            <entry><literal>Callable &lt;T,P&gt;</literal></entry>
            <entry>argument list of type <literal>P</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
                
        <row><entry namest="first" nameend="last"><emphasis>Assignment</emphasis></entry></row>
    
        <row>
            <entry><literal>lhs = rhs</literal></entry>
            <entry>assign</entry>
            <entry><literal></literal></entry>
            <entry>variable of type <literal>X</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Coverage</emphasis></entry></row>
    
        <row>
            <entry><literal>lhs of Type</literal></entry>
            <entry>of</entry>
            <entry><literal></literal></entry>
            <entry><literal>X</literal></entry>
            <entry>a literal type <literal>T</literal> that covers 
            <literal>X</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
     </tbody>
    </tgroup>
    </table>
        
    </section>
        
    <section id="equalitycomparison">
    <title>Equality and comparison operators</title>
    
        <para>These operators compare values for equality, order, magnitude, or membership,
        producing boolean values.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Equality and identity</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs &identical; rhs</literal></entry>
            <entry>identical</entry>
            <entry><literal>identical(lhs,rhs)</literal></entry>
            <entry><literal>X given X satisfies Identifiable</literal></entry>
            <entry><literal>Y given Y satisfies Identifiable</literal>
            where <literal>X&amp;Y</literal> is not <literal>Nothing</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &equals; rhs</literal></entry>
            <entry>equal</entry>
            <entry><literal>lhs.equals(rhs)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs != rhs</literal></entry>
            <entry>not equal</entry>
            <entry><literal>!lhs.equals(rhs)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Comparison</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs &lt;=&gt; rhs</literal></entry>
            <entry>compare</entry>
            <entry><literal>lhs.compare(rhs)</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Comparison</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &lt; rhs</literal></entry>
            <entry>smaller</entry>
            <entry><literal>lhs.compare(rhs)==smaller</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &gt; rhs</literal></entry>
            <entry>larger</entry>
            <entry><literal>lhs.compare(rhs)==larger</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &lt;= rhs</literal></entry>
            <entry>small as</entry>
            <entry><literal>lhs.compare(rhs)!=larger</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &gt;= rhs</literal></entry>
            <entry>large as</entry>
            <entry><literal>lhs.compare(rhs)!=smaller</literal></entry>
            <entry><literal>Comparable &lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Containment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs in rhs</literal></entry>
            <entry>in</entry>
            <entry><literal>let x=lhs in rhs.contains(x)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Category</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Assignability</emphasis></entry></row>
        
        <row>
            <entry><literal>rhs is Type</literal></entry>
            <entry>is</entry>
            <entry></entry>
            <entry>any type which is not a subtype of 
            <literal>T</literal>, whose intersection with 
            <literal>T</literal> is not <literal>Nothing</literal></entry>
            <entry>any literal type <literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Inheritance</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs extends rhs</literal></entry>
            <entry>extends</entry>
            <entry></entry>
            <entry><literal>Type&lt;Anything&gt;</literal></entry>
            <entry><literal>Class &lt;Anything&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row>
            <entry><literal>satisfies Type rhs</literal></entry>
            <entry>satisfies</entry>
            <entry></entry>
            <entry>literal <literal>Type&lt;Anything&gt;</literal></entry>
            <entry><literal>Type&lt;Anything&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        -->
        
    </tbody>
    </tgroup>
    </table>
    
        <comment><para>TODO: Should we have allow the operators <literal>&lt;=</literal> 
        and <literal>&gt;=</literal> to handle partial orders? A particular usecase is
        <literal>Set</literal> comparison.</para></comment>
        
        <para>A <emphasis>bounded comparison</emphasis> is an abbreviation 
        for two binary comparisons:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>l&lt;x&lt;u</literal> means 
                <literal>x&gt;l &amp;&amp; x&lt;u</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>l&lt;=x&lt;u</literal> means 
                <literal>x&gt;=l &amp;&amp; x&lt;u</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>l&lt;x&lt;=u</literal> means 
                <literal>x&gt;l &amp;&amp; x&lt;=u</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>l&lt;=x&lt;=u</literal> means 
                <literal>x&gt;=l &amp;&amp; x&lt;=u</literal></para>
            </listitem>
        </itemizedlist>
        
        <para>for expressions <literal>l</literal>, <literal>u</literal>, 
        and <literal>x</literal>.</para>
        
        <para>These abbreviations have the same precedence as the binary 
        <literal>&lt;</literal> and <literal>&lt;=</literal> operators, and, 
        like the binary forms, are not associative.</para>
        
    </section>
                
    <section id="logical">
    <title>Logical operators</title>
    
        <para>These are the usual logical operations for boolean values.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Logical operators</emphasis></entry></row>
        
        <row>
            <entry><literal>!rhs</literal></entry>
            <entry>not</entry>
            <entry><literal>if (rhs) false else true</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs || rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else rhs</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &amp;&amp; rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) rhs else false</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Logical assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs ||= rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else lhs=rhs</literal></entry>
            <entry>variable of type <literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row>
            <entry><literal>lhs &amp;&amp;= rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) lhs=rhs else false</literal></entry>
            <entry>variable of type <literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="nullvalues">
    <title>Operators for handling null values</title>
    
        <para>These operators make it easy to work with optional expressions.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Existence</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs exists</literal></entry>
            <entry>exists</entry>
            <entry><literal>if (exists lhs) true else false</literal></entry>
            <entry>any type whose intersections with <literal>Object</literal>
            and <literal>Null</literal> are not <literal>Nothing</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>lhs nonempty</literal></entry>
            <entry>nonempty</entry>
            <entry><literal>if (nonempty lhs) true else false</literal></entry>
            <entry>any subtype of <literal>Anything[]?</literal>
            whose intersections with <literal>[]</literal> and 
            <literal>[Nothing+]</literal> are not <literal>Nothing</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
                
        <row><entry namest="first" nameend="last"><emphasis>Nullsafe invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs?.member</literal></entry>
            <entry>nullsafe attribute</entry>
            <entry><literal>if (exists lhs) lhs.member else null</literal></entry>
            <entry><literal>X?</literal></entry>
            <entry>an attribute of type <literal>T</literal>
            of <literal>X</literal></entry>
            <entry><literal>T?</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs?.member</literal></entry>
            <entry>nullsafe method</entry>
            <entry></entry>
            <entry><literal>X?</literal></entry>
            <entry>a method of callable type 
            <literal>Callable &lt;T,P&gt;</literal> 
            of <literal>X</literal></entry>
            <entry><literal>Callable &lt;T?,P&gt;</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>

    <section id="listmap">
    <title>Correspondence and sequence operators</title>
    
        <para>These operators provide a simplified syntax for accessing values 
        of a <literal>Correspondence</literal>, and for joining and obtaining
        subranges of <literal>Sequence</literal>s.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Keyed item access</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs[index]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.item(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Y?</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Spans and segments</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs[from:length]</literal></entry>
            <entry>segment</entry>
            <entry><literal>lhs.segment(from,length)</literal></entry>
            <entry><literal>Ranged&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal>, <literal>Integer</literal></entry>
            <entry><literal>Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[from..to]</literal></entry>
            <entry>span</entry>
            <entry><literal>lhs.span(from,to)</literal></entry>
            <entry><literal>Ranged&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal>, <literal>X</literal></entry>
            <entry><literal>Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[from...]</literal></entry>
            <entry>upper span</entry>
            <entry><literal>lhs.spanFrom(from)</literal></entry>
            <entry><literal>Ranged&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Y</literal></entry>
        </row>
        <row>
            <entry><literal>lhs[...to]</literal></entry>
            <entry>lower span</entry>
            <entry><literal>lhs.spanTo(to)</literal></entry>
            <entry><literal>Ranged&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Y</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Spread invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs*.member</literal></entry>
            <entry>spread attribute</entry>
            <entry><literal>[ for (X x in lhs) x.member ]</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry>attribite of <literal>X</literal> of
            type <literal>T</literal></entry>
            <entry><literal>T[]</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs*.member</literal></entry>
            <entry>spread method</entry>
            <entry></entry>
            <entry><literal>X[]</literal></entry>
            <entry>method of <literal>X</literal> of
            callable type <literal>Callable &lt;T,P&gt;</literal></entry>
            <entry><literal>Callable &lt;T[],P&gt;</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Spread multiplication</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs ** rhs</literal></entry>
            <entry>scale</entry>
            <entry><literal>rhs.scale(lhs)</literal></entry>
            <entry><literal>Y</literal></entry>
            <entry><literal>Scalable&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    <para>There are two special cases related to sequences. A type <literal>X</literal>
    is a <emphasis>sequence type</emphasis> if <literal>X</literal> is a subtype of 
    <literal>Sequential&lt;Anything&gt;</literal>.</para>
    
    <para>For any sequence type <literal>X</literal> and integer <literal>n</literal>, 
    we can form the <emphasis><literal>n</literal>th tail type, <literal>Xn</literal>, 
    of <literal>X</literal></emphasis> as follows:</para>
    
    <itemizedlist>
        <listitem>
            <para>for every <literal>i&lt;=0</literal>, <literal>Xi</literal> 
            is <literal>X</literal>, and</para>
        </listitem>
        <listitem>
            <para>for every <literal>i&gt;0</literal>, if <literal>Xi</literal> 
            has the principal instantiation <literal>Tuple&lt;Ui,Fi,Yi&gt;</literal> 
            then <literal>X(i+1)</literal> is <literal>Yi</literal>, or, 
            otherwise, <literal>X(i+1)</literal> is <literal>Xi</literal>.</para>
        </listitem>
    </itemizedlist>
    
    <para>For any sequence type <literal>X</literal> and integer <literal>n</literal>, 
    we can form the <emphasis><literal>n</literal>th element type, <literal>En</literal>, 
    of <literal>X</literal></emphasis> as follows:</para>
        
    <itemizedlist>
        <listitem>
            <para>if <literal>Xn</literal> has the principal instantiation
            <literal>Tuple&lt;Un,Fn,Yn&gt;</literal> then <literal>En</literal> 
            is <literal>Fn</literal>, or, otherwise, <literal>Xn</literal>
            has the principal instantiation <literal>Sequential&lt;Fn&gt;</literal> 
            and <literal>En</literal> is <literal>Fn?</literal>.</para>
        </listitem>
    </itemizedlist>
    
    <para>Then the two special cases are:</para>
    
    <itemizedlist>
        <listitem>
    <para>The type of an expression of form <literal>x[i...]</literal> where
    <literal>x</literal> is of tuple type <literal>X</literal> and 
    <literal>n</literal> is an integer literal is <literal>Xn</literal>.</para>
        </listitem>
        <listitem>
    <para>The type of an expression of form <literal>x[i]</literal> where
    <literal>x</literal> is of tuple type <literal>X</literal> and 
    <literal>n</literal> is an integer literal is <literal>En</literal>.</para>
        </listitem>
    </itemizedlist>
    
    </section>
    
    <section id="constructors">
    <title>Operators for creating objects</title>
    
        <para>These operators simplify the syntax for instantiating certain 
        commonly used built-in types.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Range and entry constructors</emphasis></entry></row>

        <row>
            <entry><literal>lhs..rhs</literal></entry>
            <entry>spanned range</entry>
            <entry><literal>Range(lhs, rhs)</literal></entry>
            <entry><literal>T given T satisfies Ordinal &amp; Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Range&lt;T&gt;</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs:rhs</literal></entry>
            <entry>segmented range</entry>
            <entry><literal>if (lhs&lt;=0) [] else TODO</literal></entry>
            <entry><literal>T given T satisfies Ordinal &amp; Comparable&lt;T&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>T[]</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs->rhs</literal></entry>
            <entry>entry</entry>
            <entry><literal>Entry(lhs, rhs)</literal></entry>
            <entry><literal>U given U satisfies Object</literal></entry>
            <entry><literal>V given V satisfies Object</literal></entry>
            <entry><literal>Entry&lt;U,V&gt;</literal></entry>
        </row>
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Datetime and interval constructors</emphasis></entry></row>

        <row>
            <entry><literal>lhs @ rhs</literal></entry>
            <entry>datetime</entry>
            <entry><literal>Datetime(lhs, rhs)</literal></entry>
            <entry><literal>Date</literal></entry>
            <entry><literal>Time</literal></entry>
            <entry><literal>Datetime</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>interval</entry>
            <entry><literal>Interval(lhs, rhs)</literal></entry>
            <entry><literal>T given T satisfies Instant</literal></entry>
            <entry><literal>Instant&lt;T&gt;</literal></entry>
            <entry><literal>Interval&lt;T&gt;</literal></entry>
        </row>
        
        -->
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="conditionals">
    <title>Conditional operators</title>
    
        <para>Two special operators allow emulation of the famous ternary
        operator of C-like languages.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Conditionals</emphasis></entry></row>

        <row>
            <entry><literal>lhs then rhs</literal></entry>
            <entry>then</entry>
            <entry><literal>if (lhs) then rhs else null</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>T given T satisfies Object</literal></entry>
            <entry><literal>T?</literal></entry>
        </row>
        
        <row>
            <entry><literal>lhs else rhs</literal></entry>
            <entry>else</entry>
            <entry><literal>if (exists lhs) then lhs else rhs</literal></entry>
            <entry><literal>U</literal> such that <literal>null is U</literal></entry>
            <entry><literal>V</literal></entry>
            <entry><literal>U&amp;Object|V</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="arithmetic">
    <title>Arithmetic operators</title>
    
        <para>These are the usual mathematical operations for all kinds of
        numeric values.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Increment, decrement</emphasis></entry></row>
        
        <!-- Prefix increment, decrement -->
        
        <row>
            <entry><literal>++rhs</literal></entry>
            <entry>successor</entry>
            <entry><literal>rhs=rhs.successor</literal></entry>
            <entry></entry>
            <entry>variable of type <literal>Ordinal&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>--rhs</literal></entry>
            <entry>predecessor</entry>
            <entry><literal>rhs=rhs.predecessor</literal></entry>
            <entry></entry>
            <entry>variable of type <literal>Ordinal&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <!-- Postfix increment, decrement -->
        
        <row>
            <entry><literal>lhs++</literal></entry>
            <entry>increment</entry>
            <entry><literal>(++lhs).predecessor</literal></entry>
            <entry>variable of type <literal>Ordinal&lt;T&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>lhs--</literal></entry>
            <entry>decrement</entry>
            <entry><literal>(--lhs).successor</literal></entry>
            <entry>variable of type <literal>Ordinal&lt;T&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric operators</emphasis></entry></row>
        
        <!-- Unary positive and negative -->
        
        <row>
            <entry><literal>+rhs</literal></entry>
            <entry></entry>
            <entry><literal>rhs.positiveValue</literal></entry>
            <entry></entry>
            <entry><literal>Invertable &lt;I&gt;</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        
        <row>
            <entry><literal>-rhs</literal></entry>
            <entry>negation</entry>
            <entry><literal>rhs.negativeValue</literal></entry>
            <entry></entry>
            <entry><literal>Invertable &lt;I&gt;</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        
        <!-- Numeric -->
        
        <row>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>sum</entry>
            <entry><literal>lhs.plus(rhs)</literal></entry>
            <entry><literal>Summable&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>difference</entry>
            <entry><literal>lhs.minus(rhs)</literal></entry>
            <entry><literal>Invertable &lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>product</entry>
            <entry><literal>lhs.times(rhs)</literal></entry>
            <entry><literal>Numeric&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>quotient</entry>
            <entry><literal>lhs.divided(rhs)</literal></entry>
            <entry><literal>Numeric&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>lhs % rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs.remainder(rhs)</literal></entry>
            <entry><literal>Integral&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ^ rhs</literal></entry>
            <entry>power</entry>
            <entry><literal>lhs.power(rhs)</literal></entry>
            <entry><literal>Exponentiable &lt;X,Y&gt;</literal></entry>
            <entry><literal>Y</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs += rhs</literal></entry>
            <entry>add</entry>
            <entry><literal>lhs=lhs.plus(rhs)</literal></entry>
            <entry>variable of type <literal>Summable&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs -= rhs</literal></entry>
            <entry>subtract</entry>
            <entry><literal>lhs=lhs.minus(rhs)</literal></entry>
            <entry>variable of type <literal>Invertable &lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs *= rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>lhs=lhs.times(rhs)</literal></entry>
            <entry>variable of type <literal>Numeric&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs /= rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>lhs=lhs.divided(rhs)</literal></entry>
            <entry>variable of type <literal>Numeric&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>lhs %= rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs=lhs.remainder(rhs)</literal></entry>
            <entry>variable of type <literal>Integral&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
                
    </tbody>
    </tgroup>
    </table>
    
        <para>Arithmetic operators automatically widen from <literal>Integer</literal> 
        to <literal>Float</literal> when necessary. If one operand expression is 
        of static type <literal>Integer</literal>, and the other is of type 
        <literal>Float</literal>, the operand of type <literal>Integer</literal> 
        is widened to a <literal>Float</literal> in order to make the operator 
        expression well-typed. Widening is performed by evaluating the attribute 
        <literal>float</literal> defined by <literal>Integer</literal>.</para>
        
        <comment><para>Note: this is the only circumstance in the language where 
        implicit type conversion occurs. In fact, it is more correct to view this 
        behavior as an instance of operator overloading than as an implicit type 
        conversion. Implicit widening does not occur when an expression of type 
        <literal>Integer</literal> is merely assigned to the type 
        <literal>Float</literal>, since such behavior would result in ambiguities 
        when generics come into play.</para></comment>
            
        <!--para>Ceylon's numeric type system is designed to accommodate the following
        considerations:</para>
        
        <itemizedlist>
            <listitem>
                <para>The system is extensible and new numeric types may be defined
                by libraries. Numeric types defined by libraries should work the 
                same as built-in numeric types.</para>
            </listitem>
            <listitem>
                <para>Two values of different numeric types should be combinable
                using operators without the need for explicit type conversions, 
                but</para>
            </listitem>
            <listitem>
                <para>implicit type conversions should never lose information
                and</para>
            </listitem>
            <listitem>
                <para>binary operators must be symmetric.</para>
            </listitem>
            <listitem>
                <para>Furthermore, there should be no special cases in the language 
                definition or type checker to accommodate numeric types.</para>
            </listitem>
            <listitem>
                <para>However, it must be possible for the compiler to optimize 
                certain of the built-in numeric types to take advantage of the VM's 
                native support for numeric types.</para>
            </listitem>
            <listitem>
                <para>It is not necessary to encode information about the limits
                of the machine's representation of a numeric value into the type
                system. A single <literal>Integer</literal> class is sufficient
                to represent 32, 64, or 128 bit integer values. A single 
                <literal>Float</literal> class is sufficient to represent single
                and double precision floating point values. It is simply not
                possible for the compiler to detect numeric overflow or loss of
                significant precision.</para>
            </listitem>
        </itemizedlist-->
        
    </section>
    
    <section id="sets">
    <title>Set operators</title>
    
    <para>These operators provide traditional mathematical operations for sets.</para>
    
    <table>
    <tgroup cols="6">
        <colspec colnum="1" colwidth="4.5*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="3.0*" align="center"/>
        <colspec colnum="3" colwidth="7.0*" align="center"/>
        <colspec colnum="4" colwidth="4.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Set operators</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs | rhs</literal></entry>
            <entry>union</entry>
            <entry><literal>lhs.union(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;X|Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &amp; rhs</literal></entry>
            <entry>intersection</entry>
            <entry><literal>lhs.intersection(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;X&amp;Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ~ rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>lhs.complement(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Object&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>

        
        <row><entry namest="first" nameend="last"><emphasis>Set assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>lhs |= rhs</literal></entry>
            <entry>union</entry>
            <entry><literal>lhs=lhs|rhs</literal></entry>
            <entry>variable of type <literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs &amp;= rhs</literal></entry>
            <entry>intersection</entry>
            <entry><literal>lhs=lhs&amp;rhs</literal></entry>
            <entry>variable of type <literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Object&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>lhs ~= rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>lhs=lhs~rhs</literal></entry>
            <entry>variable of type <literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Object&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    </section>
    
    <section id="operatorstyleexpressions">
        <title>Operator-style member and invocation expressions</title>
        
        <para>An member expression or a method invocation with a single positional 
        argument may be written using an <emphasis>operator-style</emphasis> syntax.
        This syntax has an extremely low precedence, just above the precedence of 
        the assignment operator, is not associative, and does not form a legal 
        expression statement.</para>
        
        <programlisting>0..max by step</programlisting>
        
        <para>In an <emphasis>operator-style invocation expression</emphasis>, the 
        invoked method name and optional type arguments occur in an infix location 
        between two expressions. The first expression is interpreted as the receiver 
        expression, and the second expression is interpreted as a positional argument 
        to the first parameter of the method.</para> 
        
        <synopsis>OperatorInvocation: ValueExpression MemberName TypeArguments? Expression</synopsis>

        <para>The semantics of this syntax are identical to ordinary invocation 
        expressions, as defined in <xref linkend="invocationexpressions"/>.</para>
        
        <para>In an <emphasis>operator-style member expression</emphasis>, the 
        member name and optional type arguments occur in a postfix location after
        an expression. The expression is interpreted as the receiver expression.</para> 
        
        <synopsis>OperatorMemberExpression: ValueExpression MemberName TypeArguments?</synopsis>
        
        <para>The semantics of this syntax are identical to ordinary member expression,
        as defined in <xref linkend="memberexpressions"/>.</para>
                    
        <comment><para>TODO: Should we rather use this syntax as a sugar for invocation
        of a toplevel function?</para></comment>
        
    </section>
        
    <section id="metamodelexpressions">
        <title>Metamodel expressions</title>
        
        <para>A <emphasis>metamodel expression</emphasis> is a reference to
        a type, a class, a function, or a value. It evaluates to a metamodel 
        object whose static type captures the type itself, the callable type 
        of the class, the callable type of the function, or the type of the 
        value, respectively.</para>
        
        <synopsis>Meta: TypeMeta | BaseMeta | MemberMeta</synopsis>
        
        <para>A <emphasis>type metamodel expression</emphasis> is a type, as
        defined by <xref linkend="type"/>, surrounded by backticks.</para>
        
        <synopsis>TypeMeta: "`" Type "`"</synopsis>
        
        <para>The type may or may not be a reference to a class or interface.</para>
        
        <programlisting>Class&lt;Person,[Name]&gt; personClass = `Person`;</programlisting>
        <programlisting>Interface&lt;List&lt;String&gt;&gt; stringListInterface = `List&lt;String&gt;`;</programlisting>
        <programlisting>UnionType&lt;Integer|Float&gt; numberType = `Number`;</programlisting>
        <programlisting>Type&lt;Element&gt; elementType = `Element`;</programlisting>        
        
        <para>A <emphasis>base metamodel expression</emphasis> is a member name, 
        with an optional list of type arguments, surrounded by backticks.</para>
        
        <synopsis>BaseMeta: "`" MemberName TypeArguments? "`"</synopsis>
        
        <para>A base metamodel expression is a reference to a value or function. 
        The referenced declaration is determined according to
        <xref linkend="unqualifiedreferenceresolution"/>.</para>
        
        <para>A <emphasis>member metamodel expression</emphasis> is a qualifier, 
        followed by a member name, with an optional list of type arguments, 
        surrounded by backticks.</para>
        
        <synopsis>MemberMeta: "`" MetaQualifier "." MemberName TypeArguments? "`"</synopsis>
        
        <para>The member metamodel expression qualifier is a type, as defined by 
        <xref linkend="type"/>, or a base expression referring to an anonymous 
        class declaration.</para>
        
        <synopsis>MetaQualifier: QualifiedType | GroupedType | MemberName</synopsis>
        
        <para>A member metamodel expression is a reference to an attribute or 
        method of the type identified by the qualifier. The member is resolved 
        as a member of the type according to 
        <xref linkend="qualifiedreferenceresolution"/>.</para>
        
        <programlisting>Function&lt;Float,[{Float+}]&gt; sumFunction = `sum&lt;Float&gt;`;</programlisting>
        <programlisting>Attribute&lt;Person,String&gt; personNameAttribute = `Person.name`;</programlisting>
        <programlisting>Method&lt;Person,Anything,[String]&gt; personSayMethod = `Person.say`;</programlisting>
        <programlisting>Value&lt;Integer&gt; systemMillis = `system.milliseconds`;</programlisting>
        
        <para>Type argument inference is impossible in a metamodel expression,
        so type arguments must be explicitly provided for every generic 
        declaration.</para>
        
        <section id="typeofametamodelexpression">
            <title>Type of a metamodel expression</title>
            
            <para>The type of a metamodel expression depends upon the kind of 
            declaration referenced:</para>
            
            <itemizedlist>
                <listitem>
                    <para>for a toplevel value of type <literal>R</literal>, 
                    the type is <literal>Value&lt;R&gt;</literal>,</para>
                </listitem>
                <listitem>
                    <para>for a toplevel function of callable type 
                    <literal>Callable&lt;R,P&gt;</literal>, the type is 
                    <literal>Function&lt;R,P&gt;</literal>,</para>
                </listitem>
                <listitem>
                    <para>for a toplevel class of callable type 
                    <literal>Callable&lt;R,P&gt;</literal>, the type is 
                    <literal>Class&lt;R,P&gt;</literal>,</para>
                </listitem>
                <listitem>
                    <para>for a class nested in a block of callable type 
                    <literal>Callable&lt;R,P&gt;</literal>, the type is 
                    <literal>Class&lt;R,Nothing&gt;</literal>, and</para>
                </listitem>
                <listitem>
                    <para>for a toplevel interface or interface nested 
                    in a block of type <literal>R</literal>, the type is 
                    <literal>Interface&lt;R&gt;</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <comment><para>Note: members of anonymous classes are treated as 
            toplevels here.</para></comment>
            
            <para>Furthermore, given a member of a type <literal>T</literal>:</para>
            
            <itemizedlist>
                <listitem>
                    <para>for an attribute of type <literal>R</literal>, the 
                    type is <literal>Attribute&lt;T,R&gt;</literal>,</para>
                </listitem>
                <listitem>
                    <para>for a method of callable type 
                    <literal>Callable&lt;R,P&gt;</literal>, the type is 
                    <literal>Method&lt;T,R,P&gt;</literal>,</para>
                </listitem>
                <listitem>
                    <para>for a member class of callable type 
                    <literal>Callable&lt;R,P&gt;</literal>, the type is 
                    <literal>MemberClass&lt;T,R,P&gt;</literal>, and</para>
                </listitem>
                <listitem>
                    <para>for a nested interface of type 
                    <literal>R</literal>, the type is 
                    <literal>MemberInterface&lt;T,R&gt;</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Finally:</para>
            
            <itemizedlist>
                <listitem>
                    <para>for a union type <literal>T</literal>, the type is
                    <literal>UnionType&lt;T&gt;</literal>,</para>
                </listitem>
                <listitem>
                    <para>for an intersection type <literal>T</literal>, the 
                    type is <literal>IntersectionType&lt;T&gt;</literal>,</para>
                </listitem>
                <listitem>
                    <para>for the type <literal>Nothing</literal>, the type is 
                    <literal>Type&lt;Nothing&gt;</literal>, and</para>
                </listitem>
                <listitem>
                    <para>for a type parameter <literal>T</literal>, the type is
                    <literal>Type&lt;T&gt;</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>If a type alias occurs inside a typed metamodel expression, it 
            is replaced by its definition, after substituting type arguments, 
            before determining the type of the metamodel expression.</para>
            
        </section>
        
    </section>
    
    <section id="referenceexpressions">
        <title>Reference expressions</title>
        
        <para>A <emphasis>reference expression</emphasis> is a reference to
        a program element and evaluates to a detyped metamodel of the program 
        element. Reference expressions are used primarily in annotations, 
        especially the documentation annotations listed in 
        <xref linkend="documentation"/>. A reference expression may refer to:</para>
        
        <itemizedlist>
            <listitem>
                <para>a class, interface, type alias, or type parameter,</para>
            </listitem>
            <listitem>
                <para>a function or value, or</para>
            </listitem>
            <listitem>
                <para>a package or module.</para>
            </listitem>
        </itemizedlist>
        
        <synopsis>Dec: TypeDec | MemberDec | PackageDec | ModuleDec</synopsis>
        
        <section id="declarationreferences">
            <title>Declaration references</title>
            
            <para>Declaration reference expressions may be qualified by a
            <emphasis>member declaration qualifier</emphasis>, a sequence
            of identifiers identifying a class or interface declaration or 
            an anonymous class declaration:</para>
            
            <synopsis>MemberDecQualifier: (TypeName ".")+ | MemberName</synopsis>
            
            <para>Each identifier in the member declaration qualifier is 
            the name of a class, interface, or anonymous class.</para>
            
            <para>A <emphasis>class reference expression</emphasis>, 
            <emphasis>interface reference expression</emphasis>,
            <emphasis>alias reference expression</emphasis>, or
            <emphasis>type parameter reference expression</emphasis> is an
            optional member declaration qualifier, followed by the name of
            a class, interface, alias, or anonymous class, with the keyword 
            <literal>class</literal>, <literal>interface</literal>, 
            <literal>alias</literal>, or <literal>given</literal>, respectively, 
            surrounded by backticks.</para>
            
            <synopsis>TypeKeyword: "class" | "interface" | "alias" | "given"</synopsis>
            
            <synopsis>TypeDec: "`" TypeKeyword MemberDecQualifier? (TypeName | MemberName) "`"</synopsis>
            
            <para>A <emphasis>value reference expression</emphasis> or
            <emphasis>function reference expression</emphasis> is an optional 
            member declaration qualifier, followed by the name of a function,
            value, or anonymous class, with the keyword <literal>value</literal> 
            or <literal>function</literal>, surrounded by backticks.</para>
            
            <synopsis>MemberKeyword: "value" | "function"</synopsis>
            
            <synopsis>MemberDec: "`" MemberKeyword MemberDecQualifier? MemberName "`"</synopsis>
            
            <para>A reference expression is a reference to a declaration. The 
            referenced declaration is determined according to
            <xref linkend="unqualifiedreferenceresolution"/> and
            <xref linkend="qualifiedreferenceresolution"/>. The kind of the
            referenced declaration must match the kind of reference indicated
            by the keyword.</para>
            
            <programlisting>ClassDeclaration personClass = `class Person`;</programlisting>
            <programlisting>InterfaceDeclaration stringListInterface = `interface List`;</programlisting>
            <programlisting>AliasDeclaration numberAlias = `alias Number`;</programlisting>
            <programlisting>TypeParameter elementTypeParameter = `given Element`;</programlisting>
            <programlisting>ValueDeclaration personNameAttribute = `value Person.name`;</programlisting>
            <programlisting>FunctionDeclaration personSayMethod = `function Person.say`;</programlisting>
            <programlisting>FunctionDeclaration processWriteMethod = `function process.write`;</programlisting>
            <programlisting>ClassDeclaration processClass = `class process`;</programlisting>
            
        </section>
        
        <section id="packageandmodulereferences">
            <title>Package and module references</title>
            
            <para>A <emphasis>package reference expression</emphasis> is a package
            name, as defined by <xref linkend="packages"/>, with the keyword
            <literal>package</literal>, surrounded by backticks.</para>
            
            <synopsis>PackageDec: "`" "package" FullPackageName "`"</synopsis>
            
            <para>The package name must refer to a package from which an 
            <literal>import</literal> statement in the same compilation unit may 
            import declarations, as defined by <xref linkend="imports"/>.</para>
            
            <programlisting>Package modelPackage = `package ceylon.language.meta.model`;</programlisting>
            
            <para>A <emphasis>module reference expression</emphasis> is a module
            name, as defined by <xref linkend="modulenamesandversionidentifiers"/>, 
            with the keyword <literal>module</literal>, surrounded by backticks.</para>
            
            <synopsis>ModuleDec: "`" "module" FullPackageName "`"</synopsis>
            
            <para>The module name must refer to the module to which the 
            compilation unit belongs, as specified by <xref linkend="sourcelayout"/>, 
            or to a module imported by the module to which the compilation unit 
            belongs, as defined by <xref linkend="moduledescriptors"/>.</para>
            
            <programlisting>Module languageModule = `module ceylon.language`;</programlisting>
        
        </section>
        
        <section id="typeofareferenceexpression">
            <title>Type of a reference expression</title>
            
            <para>The type of a reference expression depends upon the kind of 
            program element referenced:</para>
            
            <itemizedlist>
                <listitem>
                    <para>for a module, the type is 
                    <literal>Module</literal>,</para>
                </listitem>
                <listitem>
                    <para>for a package, the type is 
                    <literal>Package</literal>,</para>
                </listitem>
                <listitem>
                    <para>for a value, the type is 
                    <literal>ValueDeclaration</literal>,</para>
                </listitem>
                <listitem>
                    <para>for a function, the type is 
                    <literal>FunctionDeclaration</literal>,</para>
                </listitem>
                <listitem>
                    <para>for a type parameter, the type is 
                    <literal>TypeParameter</literal>,</para>
                </listitem>
                <listitem>
                    <para>for a type alias declared using the keyword
                    <literal>alias</literal>, the type is 
                    <literal>AliasDeclaration</literal>,</para>
                </listitem>
                <listitem>
                    <para>for a class or class alias, the type is 
                    <literal>ClassDeclaration</literal>, and</para>
                </listitem>
                <listitem>
                    <para>for an interface or interface alias, the type 
                    is <literal>InterfaceDeclaration</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>For a reference to an anonymous class, the type depends
            upon the keyword, <literal>class</literal>, or <literal>value</literal>, 
            specified in the reference expression:</para>
            
            <itemizedlist>
                <listitem>
                    <para>for a class reference expression, the type is 
                    <literal>ClassDeclaration</literal>, but</para>
                </listitem>
                <listitem>
                    <para>for a value reference expression, the type is 
                    <literal>ValueDeclaration</literal>.</para>
                </listitem>
            </itemizedlist>
            
        </section>
        
    </section>
    
 </chapter>
